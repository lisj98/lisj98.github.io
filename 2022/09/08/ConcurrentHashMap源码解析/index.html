<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Java、数据结构">
    <meta name="description" content="所见即所得">
    <meta name="author" content="Lisj">
    
    <title>
        
            ConcurrentHashMap源码解析 |
        
        BlogOfLisj
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/l-solid.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"lisj98.github.io","root":"/","language":"en","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#FF00FF","avatar":"/images/Neymar.jpg","favicon":"/images/l-solid.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"What you see is what you get."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="BlogOfLisj" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                BlogOfLisj
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">ConcurrentHashMap源码解析</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/Neymar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Lisj</span>
                        
                            <span class="author-label">中忍</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-09-08 22:13:10</span>
        <span class="mobile">2022-09-08 22:13</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E9%9B%86%E5%90%88/">集合</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>8.7k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>38 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>TODO：红黑树的逻辑</p>
<h1 id="1-前情提要"><a href="#1-前情提要" class="headerlink" title="1. 前情提要"></a>1. 前情提要</h1><p>ConcurrentHashMap继承了AbstractMap，实现了ConcurrentMap接口，ConcurrentMap接口实现了Map接口，也就是说它和HashMap并没有直接的联系</p>
<p>ConcurrentHashMap的key和value都不能为空</p>
<p>ConcurrentHashMap是线程安全的Map，JDK 1.8中这个线程安全主要是通过CAS(比较和替换)+自旋来实现的，JDK 1.7中是通过加锁实现的</p>
<p>JDK1.7的结构是维护了一个大小为16的Segment数组，然后每个Segment数组中又分别维护了一个哈希表，也就是说数组套数组套链表，每个线程操作各自的Segment数组，互不影响</p>
<p>JDK1.8的结构类似于HashMap，没有Segment数组的概念，就是维护了一个哈希表，保证线程安全的实现方式主要是CAS+自旋，什么是CAS+自旋呢，就是线程在要操作某个变量的时候，先和自己的副本比较一下变量值，如果两者是相同的就直接修改，如果两者不同就不修改，回到代码块最开始的循环处，再执行一次循环，就这样循环往复，直到能修改值为止</p>
<p>JDK1.7的ConcurrentHashMap示例：</p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/JDK1.2emddb6cg0e8.webp" alt="JDK1"></p>
<p>JDK1.8的ConcurrentHashMap示例：</p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/JDK1.6t3yso8mo8o0.webp" alt="JDK1"></p>
<h1 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h1><h2 id="2-1-属性"><a href="#2-1-属性" class="headerlink" title="2.1. 属性"></a>2.1. 属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大容量 2^30</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树化节点个数(链表-&gt;树)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表化节点个数(树-&gt;链表)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树化最小的容量要求</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小迁移步长</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容戳位数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大扩容线程数 2^16-1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在sizeCtl中扩容戳的位移 16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span> <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标志forwarding node节点，forwarding node是桶数组扩容时的辅助节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表的桶数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容后的新数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本计数器值，在没有线程竞争时用作维护Map元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计数数组，用在线程竞争时各个线程共同维护Map元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sizeCtl，线程间共享变量，用以标识数组现在的状态以及线程能执行的操作</span></span><br><span class="line"><span class="comment"> * 为0，代表数组没有被初始化，数组容量为16(空参构造)；</span></span><br><span class="line"><span class="comment"> * 为正数，如果数组没有初始化则代表数组的初始容量，如果数组已经初始化了则代表数组扩容阈值(数组的初始容量*0.75)</span></span><br><span class="line"><span class="comment"> * 为-1，代表一个线程正在进行数组初始化，其他线程就不能初始化了</span></span><br><span class="line"><span class="comment"> * 小于0并且不为-1，则表示数组正在扩容，-(1+n)表示此时有n个线程正在共同完成数组的扩容操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记扩容线程扩容数组时的起始位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示是否有线程正在操作数组，0表示没有，1表示有</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;	<span class="comment">//当前类对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> SIZECTL;	<span class="comment">//sizeCtl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> TRANSFERINDEX;	<span class="comment">//transferIndex</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> BASECOUNT;	<span class="comment">//baseCount</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLSBUSY;	<span class="comment">//cellsBusy</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLVALUE;	<span class="comment">//value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">		Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">		SIZECTL = U.objectFieldOffset</span><br><span class="line">		(k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br><span class="line">		TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">		(k.getDeclaredField(<span class="string">&quot;transferIndex&quot;</span>));</span><br><span class="line">		BASECOUNT = U.objectFieldOffset</span><br><span class="line">		(k.getDeclaredField(<span class="string">&quot;baseCount&quot;</span>));</span><br><span class="line">		CELLSBUSY = U.objectFieldOffset</span><br><span class="line">		(k.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">		Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">		CELLVALUE = U.objectFieldOffset</span><br><span class="line">		(ck.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">		Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">		ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">		<span class="type">int</span> <span class="variable">scale</span> <span class="operator">=</span> U.arrayIndexScale(ak);</span><br><span class="line">		<span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">		ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2.2. 方法"></a>2.2. 方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.无参构造，什么都是默认的，在put时才初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.指定初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">//initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)，计算出大于原值加一半又加1的最接近2的幂，要分情况分析，如initialCapacity为31，则容量为64，而initialCapacity为17，则容量为32</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">	           MAXIMUM_CAPACITY :</span><br><span class="line">	           tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//sizeCtl见属性详解</span></span><br><span class="line">	<span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.复制一个Map</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">	putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.指定初始容量、负载因子，并发线程数固定为1</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.指定初始容量、负载因子和估计的并发线程数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">	<span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">		initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">	<span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">	          MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">	<span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tableSizeFor方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和HashMap的处理逻辑一致，计算出一个大于c的最接近2的幂，具体解析见HashMap的该方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候该用无参构造，什么时候该用有参构造呢？我们通常直接使用无参构造，什么都用默认的，但是如果一开始就能确定集合里有多少个元素的话，就应该用有参构造来确定初始容量，因为频繁的扩容很消耗性能，只有在无法确定集合里有多少元素的情况下才应该使用无参构造。</p>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.put方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.putIfAbsent方法</span></span><br><span class="line"><span class="keyword">public</span> V putIfAbsent方法(K key, V value) &#123;</span><br><span class="line">	<span class="keyword">return</span> putVal(key, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.putAll方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> putAll方法(Map&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; m) &#123;</span><br><span class="line">	tryPresize(m.size());</span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet())</span><br><span class="line">		putVal(e.getKey(), e.getValue(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.putVal方法</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">//key和value都不能为空</span></span><br><span class="line">	<span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//计算hash值确定桶下标，spread方法返回值：(h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS，和HashMap计算hash值的计算方法一样</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">	<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">//链表节点的个数</span></span><br><span class="line">	<span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">		Node&lt;K,V&gt; f;</span><br><span class="line">		<span class="type">int</span> n, i, fh;</span><br><span class="line">		<span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//table无具体指向，即没初始化则初始化数组</span></span><br><span class="line">			tab = initTable();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//链表首节点为空，即当前桶内无元素，则创建节点</span></span><br><span class="line">			<span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">			             <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">				<span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//首节点的hash值为-1，则代表该节点是一个forwarding node，即桶数组当前位置存储了一个forwarding node，而forwarding node是对数组进行扩容迁移的标志，也就表示目前正有线程对桶数组进行迁移，那么本线程就要协助迁移数组</span></span><br><span class="line">			tab = helpTransfer(tab, f);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//正常往链表节点后添加元素</span></span><br><span class="line">			<span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//锁住链表首节点，相当于锁住当前桶，同时也不会影响对其他桶的操作</span></span><br><span class="line">			<span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//tabAt再判断一次是防止链表节点变成了树节点，那么接下来的操作就不适用了</span></span><br><span class="line">				<span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">					<span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">						binCount = <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">							K ek;</span><br><span class="line">							<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">							        ((ek = e.key) == key ||</span><br><span class="line">							         (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//链表首节点为所查询节点，修改原值</span></span><br><span class="line">								oldVal = e.val;</span><br><span class="line">								<span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">									e.val = value;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">                            <span class="comment">//链表首节点不为所查询节点，往后添加</span></span><br><span class="line">							Node&lt;K,V&gt; pred = e;</span><br><span class="line">							<span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">								pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">								                          value, <span class="literal">null</span>);</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//若之前链表已经进化成红黑树，则用红黑树的逻辑</span></span><br><span class="line">						Node&lt;K,V&gt; p;</span><br><span class="line">						binCount = <span class="number">2</span>;</span><br><span class="line">						<span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">						                                      value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">							oldVal = p.val;</span><br><span class="line">							<span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">								p.val = value;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//判断是否需要将链表进化成红黑树</span></span><br><span class="line">					treeifyBin(tab, i);</span><br><span class="line">				<span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">					<span class="keyword">return</span> oldVal;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//addCount：1.维护集合长度，2.判断是否需要扩容</span></span><br><span class="line">	addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put加锁图解：</p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/put%E5%8A%A0%E9%94%81.4o02hw60p8o0.webp" alt="put加锁"></p>
<h3 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.initTable</span></span><br><span class="line"><span class="comment">//初始化哈希表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab;</span><br><span class="line">	<span class="type">int</span> sc;</span><br><span class="line">	<span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是刚创建Map，调用的有参构造，那sizeCtl肯定大于0，调用的是无参构造，那sizeCtl肯定等于0</span></span><br><span class="line">		<span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//sizeCtl&lt;0，要么表示某一个线程正在初始化数组，要么表示数组正在扩容，因此其他线程不能干扰本线程的操作，所以需要调用yield()方法让出CPU执行权</span></span><br><span class="line">			Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//sizeCtl&gt;0，要么表示还没有开始初始化数组，要么数组已经初始化完成表示的是阈值。而sc在上个if判断条件中记录的是旧sizeCtl的值，SIZECTL和sc进行比较，相同则说明sizeCtl没有被其他线程修改，则可以继续进行，将sc的值改成-1，表示当前线程正在初始化数组，其他线程就不能操作数组了，不相同则说明其他线程修改了sizectl的值，那么就需要重新循环直到两个值相等为止(CAS+自旋)</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">					<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="comment">//指向一个真正的桶数组，之前的table只是个引用</span></span><br><span class="line">					Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">					table = tab = nt;</span><br><span class="line">                    <span class="comment">//&gt;&gt;&gt;2表示除以4，n-1/4n=0.75n，又赋值给sizectl，而此时数组已经初始化完了，那么sizectl就表示扩容阈值了</span></span><br><span class="line">					sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				sizeCtl = sc;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resizeStamp方法"><a href="#resizeStamp方法" class="headerlink" title="resizeStamp方法"></a>resizeStamp方法</h3><p>该方法表示一个扩容戳(16位)，根据它可以判断多线程是否为同一批次，操作同一数组，并且可以得到原数组的长度。</p>
<p>n为原数组的长度，numberOfLeadingZeros(n)方法用来计算n中1前面的0有多少个，然后跟1&lt;&lt;15进行或运算</p>
<p>举个例子，n&#x3D;32(0…0 0…0 0…0 00100000)，1前面有26个0，那么就用(0…0 0…0 0…0 00011010)与(0…0 0…0 10000000 0…0)进行或运算，得到结果(0…0 0…0 10000000 00011010)。</p>
<p>这个扩容戳有什么用呢，在数组迁移时会用到，它会用来规定一个批次，多线程根据这个批次号来确定扩容的原数组。后面使用它时它将作为int类型的高16位来使用，低16位就表示扩容线程数</p>
<p>比如上面的结果(0…0 0…0 10000000 00011010)，后面该值会左移16位，那么(10000000 00011010)就变成了高16位，而这个值肯定是由32得出来的，那么多线程就知道当前扩容的数组长度为32，也就知道当前是对哪个数组进行扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.resizeStamp</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">resizeStamp</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h3><ol>
<li>维护元素数量</li>
<li>判断是否需要扩容</li>
</ol>
<p>获取集合长度的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.size</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line">	<span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">	        (n &gt; (<span class="type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">	        (<span class="type">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcurrentHashMap.sumCount</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">	CounterCell[] as = counterCells;</span><br><span class="line">	CounterCell a;</span><br><span class="line">	<span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line">	<span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">				sum += a.value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>baseCount变量，put元素时线程要维护这个变量，进行++操作</p>
<p>CounterCell数组也是用来维护Map元素数量的，在多线程环境下，两个线程同时对baseCount操作，那么肯定有一个成功，一个失败，成功的那个自然用baseCount记录数量，失败的那个就要用CounterCell数组来记录元素数量，最后把数组中所有的value值和baseCount加起来就是整个Map的元素数量</p>
<p>它是这样一种结构：CounterCell数组类似于哈希表中的桶，每个桶中有一个CounterCell对象，这个对象又有一个属性value，计算Map中元素数量就是将每个桶中CounterCell对象的value值加起来再加上baseCount，得到的总数就是集合的元素数量</p>
<p>CounterCell数组和baseCount都是多线程共享的变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.addCount</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">	CounterCell[] as;</span><br><span class="line">	<span class="type">long</span> b, s;</span><br><span class="line">    <span class="comment">//(as = counterCells) != null成立则直接到b处，baseCount语句不执行，baseCount=0</span></span><br><span class="line">    <span class="comment">//(as = counterCells) != null不成立则到a处，说明baseCount的累加操作失败，比如两个线程同时进来，那么一个添加成功，一个添加失败，失败的那个就会进到a处，这时，失败的就会利用数组中的CounterCell记录数量，而成功的则用baseCount记录数量</span></span><br><span class="line">	<span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">	        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">		CounterCell a;</span><br><span class="line">		<span class="type">long</span> v;</span><br><span class="line">		<span class="type">int</span> m;</span><br><span class="line">        <span class="comment">//标识是否有多线程竞争</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//a</span></span><br><span class="line">        <span class="comment">//as == null || (m = as.length - 1) &lt; 0表示数组为空或长度为0</span></span><br><span class="line">        <span class="comment">//(a = as[ThreadLocalRandom.getProbe() &amp; m]) == null表示当前线程负责的桶位中没有CounterCell对象</span></span><br><span class="line">        <span class="comment">//U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)表示当前线程对应的桶位不为空，但是累加失败</span></span><br><span class="line">		<span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">		        (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">		        !(uncontended =</span><br><span class="line">		              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">			fullAddCount(x, uncontended);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//b.s是通过累加CounterCell数组中每一个CounterCell对象的value值加上baseCount得来的，到这一步的条件是上面if语句中的(as = counterCells) != null成立，即CounterCell数组不为空</span></span><br><span class="line">		s = sumCount();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//check就是传进来的binCount，即链表节点个数。第一次put时会进入到这个条件中</span></span><br><span class="line">	<span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		Node&lt;K,V&gt;[] tab, nt;</span><br><span class="line">		<span class="type">int</span> n, sc;</span><br><span class="line">        <span class="comment">//s为Map中元素总数，&gt;=阈值时需要扩容</span></span><br><span class="line">		<span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">		        (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">			<span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;	<span class="comment">//sc&lt;0表示有其他线程正在进行扩容</span></span><br><span class="line">                <span class="comment">//不需要协助扩容，5个条件见helpTransfer方法的解释</span></span><br><span class="line">				<span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">				        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">				        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//需要协助扩容，则线程数+1。高16位扩容戳不变，低16位+1</span></span><br><span class="line">				<span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">					transfer(tab, nt);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">			                               (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//没有线程进行扩容，则当前线程负责扩容，sizectl的值形式变为(高16位扩容戳+低16位线程数)，为什么是+2不是+1，在下面的helpTransfer方法中有解释</span></span><br><span class="line">				transfer(tab, <span class="literal">null</span>);</span><br><span class="line">			s = sumCount();		<span class="comment">//返回元素总数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fullAddCount方法"><a href="#fullAddCount方法" class="headerlink" title="fullAddCount方法"></a>fullAddCount方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.fullAddCount</span></span><br><span class="line"><span class="comment">//addCount方法中累加baseCount失败，或者CounterCell数组已经得到初始化的线程会进到这个方法中，使用CounterCell数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">fullAddCount</span><span class="params">(<span class="type">long</span> x, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">	<span class="type">int</span> h;</span><br><span class="line">    <span class="comment">//获取当前线程的hash值，hash值相同的线程负责一个CounterCell[]数组的一格</span></span><br><span class="line">	<span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">		ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">		h = ThreadLocalRandom.getProbe();	<span class="comment">//初始化后重新获取hash值</span></span><br><span class="line">		wasUncontended = <span class="literal">true</span>;	<span class="comment">//为true表示当前桶位没有线程竞争</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		CounterCell[] as;</span><br><span class="line">		CounterCell a;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="type">long</span> v;</span><br><span class="line">        <span class="comment">//a.桶不为空，给那些c.累加baseCount失败，b.没抢占初始化的那些线程使用</span></span><br><span class="line">		<span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//1.当前桶位为空</span></span><br><span class="line">			<span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当前桶位没有线程在填入CounterCell对象，cellsBusy为0表示没有线程正在使用数组，为1表示有线程正在使用数组</span></span><br><span class="line">				<span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="type">CounterCell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x);	<span class="comment">//新建一个CounterCell对象，value值为1，后续会自加</span></span><br><span class="line">                    <span class="comment">//没有线程正在操作数组，则修改cellsBusy为1，表示我要往数组里插入对象了，其他线程就不能插手了</span></span><br><span class="line">					<span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">					        U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">						<span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;	<span class="comment">//为true表示对象填入成功</span></span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							CounterCell[] rs;</span><br><span class="line">							<span class="type">int</span> m, j;</span><br><span class="line">                            <span class="comment">//counterCells数组不为空，并且线程对应桶位为空，则填入CounterCell对象</span></span><br><span class="line">							<span class="keyword">if</span> ((rs = counterCells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">							        (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">							        rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">								rs[j] = r;</span><br><span class="line">								created = <span class="literal">true</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							cellsBusy = <span class="number">0</span>;	<span class="comment">//填入对象完成，cellsBusy修改为0，其他线程可以操作数组了</span></span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (created)</span><br><span class="line">							<span class="keyword">break</span>;	<span class="comment">//创建对象并且填入桶成功，退出循环</span></span><br><span class="line">						<span class="keyword">continue</span>;	<span class="comment">//不成功继续循环</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				collide = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//2.进不来，一直为false</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">				wasUncontended = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//3.对应的桶位不为空，直接累加CounterCell对象的value值，然后退出循环，累加失败(有其他线程修改过)则重新计算线程hash值，继续循环</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//4.数组被其他的线程修改了，或者数组长度超过了可用CPU大小，则重新计算hash值，继续循环</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">				collide = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//5.用来控制重新计算线程hash值,当前桶位有对象，累加value又失败了，数组又没被其他线程修改过，则将collide置为true，并重新计算hash值，如果又一轮失败了，那么直接进入6中</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">				collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//6.没有其他线程正在操作数组</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">			         U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//如果CAS自旋失败两次则直接扩容数组</span></span><br><span class="line">					<span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">						CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">						<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">							rs[i] = as[i];</span><br><span class="line">						counterCells = rs;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					cellsBusy = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				collide = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">			&#125;</span><br><span class="line">			h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        <span class="comment">//b.如果有多个因累加baseCount失败而同时进入本方法的线程，第一个抢占了本if语句的线程，CounterCells数组为空(counterCells == as)，更没有其他线程在对数组进行操作(cellsBusy == 0)，它就初始化数组，初始长度为2，并且将cellsBusy设为1，告诉其他线程我正在初始化数组，你们继续循环</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">		           U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">				<span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">					CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[<span class="number">2</span>];</span><br><span class="line">					rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x);</span><br><span class="line">					counterCells = rs;</span><br><span class="line">					init = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				cellsBusy = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//数组初始化完成，当前负责初始化的线程退出循环</span></span><br><span class="line">			<span class="keyword">if</span> (init)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//c.如果有多个因累加baseCount失败而同时进入本方法的线程，a中CounterCells数组为空，b中又被其他线程抢了先，那么就尝试再一次累加baseCount，累加成功则退出循环，执行自己下一步；累加失败则继续循环，最终在a中操作</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">			<span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算集合总数图解：</p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/%E8%AE%A1%E7%AE%97%E9%9B%86%E5%90%88%E6%80%BB%E6%95%B0.50ezwqf3n0w0.webp" alt="计算集合总数"></p>
<h3 id="helpTransfer方法"><a href="#helpTransfer方法" class="headerlink" title="helpTransfer方法"></a>helpTransfer方法</h3><p>put、replace、compute等往Map中放元素的时候会触发helpTransfer操作，而修改Map中的元素时必定会触发addCount操作，addCount中有这样一个操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.addCount</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">	transfer(tab, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>即这个时候SIZECTL也就是sizectl已经被修改为<code>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</code>了，含义就是高16位扩容戳标记本批次线程，低16位为2表示目前有一个线程参加扩容了。这里理解时要忽略高16位的扩容戳，因为扩容戳首位肯定是1，那么忽略掉之后sizectl就是-2，表示此时数组正在扩容，扩容线程数为2-1&#x3D;1，为什么是+2不是+1呢，因为-1表示数组正在初始化</p>
<p>所以下面helpTransfer中，sc并不是传统意义上的负几负几，而是我们忽略掉扩容戳之后的数，因此理解上忽略掉高16位的扩容戳，而代码实现上结合高16位扩容戳+低16位线程数</p>
<p>另外SIZECTL(sizeCtl)是一个静态变量，所以一个线程在put-&gt;addCount-&gt;transfer一系列操作中修改了这个值的时候，另一个线程进来put-&gt;helpTransfer得到的是修改后的值，也就是<code>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</code>这个值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协助迁移数组(扩容时是创建一个新桶数组，再把旧数组的值迁移到新数组中)</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">	Node&lt;K,V&gt;[] nextTab;	<span class="comment">//指向新数组</span></span><br><span class="line">	<span class="type">int</span> sc;</span><br><span class="line">	<span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">	        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//只要参数tab.length是一样的，那么rs这个值必定是一样的，因此它跟addCount()方法中的rs必定是一样的</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">		<span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">		        (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//a</span></span><br><span class="line">			<span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">			        sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//sc+1即后16位+1，表示增加了一个线程来协助扩容</span></span><br><span class="line">			<span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">				transfer(tab, nextTab);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nextTab;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码a中：</p>
<ul>
<li>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs用来判断线程是否为同一批次，即扩容戳是否一致，是否操作的同一数组</li>
<li>sc &#x3D;&#x3D; rs + 1，在transfer()方法中，如果数组迁移完毕了有这样一个操作：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.transfer</span></span><br><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	finishing = advance = <span class="literal">true</span>;</span><br><span class="line">	i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sc - 1表示低16位-1，表示减去一个协助扩容的线程，每一个进入transfer方法的线程如果发现数组迁移完毕了，那么自己就退出扩容，线程数-1，每一个都这样操作，直到所有线程都-1，那么就回归到了最开始的情况，而最开始是+2，初始情况必定有一个线程，初始情况的这个线程也-1了，最后的sc自然是(16位扩容戳+0000000000000001)，而(rs&lt;&lt;16)+1也是这个数，所以两数相等就表示扩容完毕，就没必要再协助扩容了</p>
<ul>
<li>sc &#x3D;&#x3D; rs + MAX_RESIZERS表示达到了最大扩容线程数，不能再有线程进来协助扩容了</li>
<li>transferIndex &lt;&#x3D; 0表示已经没有要迁移的桶了</li>
</ul>
<p>sc &#x3D;&#x3D; rs + 1和sc &#x3D;&#x3D; rs + MAX_RESIZERS有bug，其中的rs应该为(rs&lt;&lt;16)</p>
<h3 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h3><p>tryPresize、helpTransfer、addCount时会触发transfer操作，通俗点说，只要元素数量达到了阈值就会触发transfer方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.transfer</span></span><br><span class="line"><span class="comment">//迁移数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="comment">//如果是多CPU，那么每个线程划分任务，一个线程负责一块范围或者多块范围的桶，最小任务数是16，即一个线程最少要负责16个相接的桶</span></span><br><span class="line">	<span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">		stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">	<span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">//创建两倍大小的新数组</span></span><br><span class="line">			Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">			nextTab = nt;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">			sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录线程开始迁移的桶位，从后往前迁移</span></span><br><span class="line">		transferIndex = n;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//记录新数组的末尾</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    <span class="comment">//若某个桶位迁移完成了，则在该桶中放入一个ForwardingNode节点</span></span><br><span class="line">	ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;		<span class="comment">//advance用来表示当前桶位是否已经迁移完毕</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; 	<span class="comment">//finishing用来表示整个数组是否已经迁移完毕</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        <span class="comment">//i记录当前正在迁移桶位的下标</span></span><br><span class="line">        <span class="comment">//bound记录迁移的最后一个桶位的下标</span></span><br><span class="line">        <span class="comment">//数组从后往前迁移，所以i从右往左，bound在最左边</span></span><br><span class="line">		Node&lt;K,V&gt; f;</span><br><span class="line">		<span class="type">int</span> fh;</span><br><span class="line">		<span class="keyword">while</span> (advance) &#123;</span><br><span class="line">			<span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">			<span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                <span class="comment">//a.i移到了bound左边或者finishing为true说明整个桶数组已经迁移完毕。若线程负责的区间中右端根本没有值，则会进入这个条件中，一直到无值的桶位中forwarding node补全为止；若区间右端有值，则一定先进入c条件中，等到全部迁移完才会进入本条件中，最开始肯定是先进入到c条件中的</span></span><br><span class="line">				advance = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//b.nextIndex或者说transferIndex&lt;=0和上面情况一样，也是说明整个桶数组已经迁移完毕</span></span><br><span class="line">				i = -<span class="number">1</span>;</span><br><span class="line">				advance = <span class="literal">false</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">			           (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">			            nextBound = (nextIndex &gt; stride ?</span><br><span class="line">			                         nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">//c.nextIndex - stride是为了控制区间，限定当前线程所负责的最后一个桶位，比如30-16，那么当前线程应该从30处理到14，这个区间中的16个桶位就是由它负责，bound限定不动为14，i一直从右向左移(30,29,28,27......14)。而如果只有1个线程的话，那么在迁移到14时，a条件中的--i已经小于bound了，那么就要在此条件中重新限定范围区间</span></span><br><span class="line">                <span class="comment">//要注意一点，这里的TRANSFERINDEX每次会更新为nextBound，如果有另外的线程进来协助扩容，就会根据当前已经更新后的TRANSFERINDEX值重新计算任务区间，即另外的线程领到下一个区间，多个线程就这样循环领取任务，这里就是多线程协助扩容的关键所在</span></span><br><span class="line">				bound = nextBound;</span><br><span class="line">				i = nextIndex - <span class="number">1</span>;</span><br><span class="line">				advance = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">			<span class="type">int</span> sc;</span><br><span class="line">            <span class="comment">//迁移完成</span></span><br><span class="line">            <span class="comment">//a.所有桶位迁移完毕后先进b维护线程数，由最后一个线程进a来维护新数组</span></span><br><span class="line">			<span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">				nextTable = <span class="literal">null</span>;</span><br><span class="line">				table = nextTab;</span><br><span class="line">                <span class="comment">//重新计算阈值1.5n，等同于2n*0.75</span></span><br><span class="line">				sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//b.所有桶位迁移完毕后先进这里，sc-1即低16位-1，表示减去一个扩容的线程数。如果我不是最后一个线程，那么sc - 2后肯定不等于resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，那么直接返回，我自己的部分迁移完成了，我去接着自己的操作，由最后一个线程完成新数组的指向；如果我是最后一个数组，那么sc - 2后肯定等于resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，则直接将对应标志位置为true</span></span><br><span class="line">            <span class="comment">//这里sc-1和sc-2不要看成sc-3，正确流程应该是sc记录原sizectl值，然后sc-1赋值给sizectl，sc-2还是原sizectl-2</span></span><br><span class="line">			<span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				finishing = advance = <span class="literal">true</span>;</span><br><span class="line">				i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//当前桶位无元素，则直接在桶中添加forwarding node</span></span><br><span class="line">			advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//当前桶位的节点hash值为MOVED，也就是-1，说明当前节点已经是forwarding node节点了，直接将advance置为true，表示当前桶位已经处理过了</span></span><br><span class="line">			advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//锁住首节点</span></span><br><span class="line">			<span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//tabAt再判断一次是防止链表节点变成了树节点，那么接下来的操作就不适用了</span></span><br><span class="line">				<span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">					Node&lt;K,V&gt; ln, hn;</span><br><span class="line">					<span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//runBit是用来确定某个桶中的值在扩容后到底应该放在新桶中的高位还是低位，若fh&gt;n，则runBit==n;若fh&lt;n，则runBit==0</span></span><br><span class="line">                        <span class="comment">//例如，原桶容量为32，阈值为24，其中存了一个key为63的节点，63%32=31，那么在原桶中，63应该被放在tab[31]的位置，但是扩容后，新桶容量为64了，63%64=63，那么在新桶中，63就应该被放在nextTab[63]的位置，而nextTab[31]的位置就应该置null了</span></span><br><span class="line">						<span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">						Node&lt;K,V&gt; lastRun = f;	<span class="comment">//lastRun记录节点</span></span><br><span class="line">                        <span class="comment">//上一条语句的lastRun = f;是判断链表首节点应该放在新桶中的高位还是低位，这个for语句是判断链表首节点后面的节点应该放在新桶的高位还是低位</span></span><br><span class="line">						<span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="comment">//b和runBit的作用一样</span></span><br><span class="line">							<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="comment">//举个例子，若tab[1]存了1和33，在判断33时，runBit=0，而如果不经过下面if判断与runBit = b;操作，那么lastRun就被存到了新桶的低位，这肯定是不行的。而经过这个判断后，b=33，runBit=33，lastRun就被存到高位，正确</span></span><br><span class="line">							<span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">								runBit = b;</span><br><span class="line">								lastRun = p;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//fh&lt;=n，原值放在低位</span></span><br><span class="line">							ln = lastRun;</span><br><span class="line">							hn = <span class="literal">null</span>;</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//fh&gt;n，原值放在高位</span></span><br><span class="line">							hn = lastRun;</span><br><span class="line">							ln = <span class="literal">null</span>;</span><br><span class="line">						&#125;</span><br><span class="line">                        <span class="comment">//上面一个for循环处理了链表首节点后面的节点，这一个for循环处理链表首节点</span></span><br><span class="line">						<span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">							<span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash;</span><br><span class="line">							<span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">							<span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">							<span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">								ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">							<span class="type">else</span></span><br><span class="line">								<span class="variable">hn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">						&#125;</span><br><span class="line">                        <span class="comment">//将低位值ln放在新桶下标为i的节点</span></span><br><span class="line">						setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//将高位值hn放在新桶下标为i+n的节点</span></span><br><span class="line">						setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//将原桶中的当前节点设置为forwarding node节点</span></span><br><span class="line">						setTabAt(tab, i, fwd);</span><br><span class="line">						advance = <span class="literal">true</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">						TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">						TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">						TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">						<span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">							<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">							TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">							(h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">							<span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">								<span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">									lo = p;</span><br><span class="line">								<span class="keyword">else</span></span><br><span class="line">									loTail.next = p;</span><br><span class="line">								loTail = p;</span><br><span class="line">								++lc;</span><br><span class="line">							&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">								<span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">									hi = p;</span><br><span class="line">								<span class="keyword">else</span></span><br><span class="line">									hiTail.next = p;</span><br><span class="line">								hiTail = p;</span><br><span class="line">								++hc;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">						     (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">						hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">						     (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">						setTabAt(nextTab, i, ln);</span><br><span class="line">						setTabAt(nextTab, i + n, hn);</span><br><span class="line">						setTabAt(tab, i, fwd);</span><br><span class="line">						advance = <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元素根据key值重新分配桶位：</p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/%E5%85%83%E7%B4%A0%E6%A0%B9%E6%8D%AEkey%E5%80%BC%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E6%A1%B6%E4%BD%8D.1fpa4quzhlr4.webp" alt="元素根据key值重新分配桶位"></p>
<p>单线程任务迁移：</p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1%E8%BF%81%E7%A7%BB.490olvlc7ok0.webp" alt="单线程任务迁移"></p>
<p>多线程协助扩容：</p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8D%8F%E5%8A%A9%E6%89%A9%E5%AE%B9.1wle838nfhts.webp" alt="多线程协助扩容"></p>
<h3 id="tryPresize方法"><a href="#tryPresize方法" class="headerlink" title="tryPresize方法"></a>tryPresize方法</h3><h3 id="isEmpty方法"><a href="#isEmpty方法" class="headerlink" title="isEmpty方法"></a>isEmpty方法</h3><p>判断集合是否为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.isEmpty</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> sumCount() &lt;= <span class="number">0L</span>; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.get</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab;</span><br><span class="line">	Node&lt;K,V&gt; e, p;</span><br><span class="line">	<span class="type">int</span> n, eh;</span><br><span class="line">	K ek;</span><br><span class="line">	<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">	<span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">	        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">//1.首节点为所求</span></span><br><span class="line">		<span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">				<span class="keyword">return</span> e.val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.hash值小于0，有多种情况</span></span><br><span class="line">		<span class="comment">//2.1.树节点的hash值为-2，则调用的TreeNode内部类的find方法</span></span><br><span class="line">		<span class="comment">//2.2.forwading node节点的hash值为-1，则调用ForwardingNode内部类的find方法</span></span><br><span class="line">		<span class="comment">//2.3.RESERVED节点的hash值为-3，则调用ReservationNode内部类的find方法</span></span><br><span class="line">		<span class="comment">//把这个条件放在while循环之前就是为了根据节点类型的不同调用特殊的子类方法</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">//3.首节点不为所求则向后遍历</span></span><br><span class="line">		<span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">			        ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">				<span class="keyword">return</span> e.val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcurrentHashMap.getOrDefault</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">	V v;</span><br><span class="line">	<span class="keyword">return</span> (v = get(key)) == <span class="literal">null</span> ? defaultValue : v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="containsKey方法"><a href="#containsKey方法" class="headerlink" title="containsKey方法"></a>containsKey方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.containsKey</span></span><br><span class="line"><span class="comment">//实际调用的key方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="containsValue方法"><a href="#containsValue方法" class="headerlink" title="containsValue方法"></a>containsValue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.containsValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">	Node&lt;K,V&gt;[] t;</span><br><span class="line">	<span class="keyword">if</span> ((t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">		Traverser&lt;K,V&gt; it = <span class="keyword">new</span> <span class="title class_">Traverser</span>&lt;K,V&gt;(t, t.length, <span class="number">0</span>, t.length);</span><br><span class="line">		<span class="keyword">for</span> (Node&lt;K,V&gt; p; (p = it.advance()) != <span class="literal">null</span>; ) &#123;</span><br><span class="line">			V v;</span><br><span class="line">			<span class="keyword">if</span> ((v = p.val) == value || (v != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-补充"><a href="#3-补充" class="headerlink" title="3. 补充"></a>3. 补充</h1><h2 id="unSafe类"><a href="#unSafe类" class="headerlink" title="unSafe类"></a>unSafe类</h2><h3 id="compareAndSwapInt方法"><a href="#compareAndSwapInt方法" class="headerlink" title="compareAndSwapInt方法"></a>compareAndSwapInt方法</h3><p>是一个本地方法，用C语言编写的</p>
<p>var1：对象</p>
<p>var2：内存中的值</p>
<p>var4：期望值</p>
<p>var5：新值</p>
<p>如果var1对象的var2和var4值相等，就让var2&#x3D;var5，并返回true，否则不修改且返回false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="tabAt方法"><a href="#tabAt方法" class="headerlink" title="tabAt方法"></a>tabAt方法</h3><h3 id="casTabAt方法"><a href="#casTabAt方法" class="headerlink" title="casTabAt方法"></a>casTabAt方法</h3><h3 id="objectFieldOffset方法"><a href="#objectFieldOffset方法" class="headerlink" title="objectFieldOffset方法"></a>objectFieldOffset方法</h3><p>objectFieldOffset()方法用来获取类的某一字段的偏移量，也就是内存地址，那么在使用SIZECTL时，它就能获取到内存中sizeCtl的值，也就是说，如果没有其他的线程修改掉sizeCtl的值时，这两个值始终是相同的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> SIZECTL;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> TRANSFERINDEX;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> BASECOUNT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLSBUSY;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLVALUE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">		Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">		SIZECTL = U.objectFieldOffset</span><br><span class="line">		(k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br><span class="line">		TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">		(k.getDeclaredField(<span class="string">&quot;transferIndex&quot;</span>));</span><br><span class="line">		BASECOUNT = U.objectFieldOffset</span><br><span class="line">		(k.getDeclaredField(<span class="string">&quot;baseCount&quot;</span>));</span><br><span class="line">		CELLSBUSY = U.objectFieldOffset</span><br><span class="line">		(k.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">		Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">		CELLVALUE = U.objectFieldOffset</span><br><span class="line">		(ck.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">		Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">		ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">		<span class="type">int</span> <span class="variable">scale</span> <span class="operator">=</span> U.arrayIndexScale(ak);</span><br><span class="line">		<span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">		ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p>baseCount基础变量，添加元素后线程要维护这个变量，进行++操作，如果有多个线程同时对baseCount进行操作，就会有冲突，有冲突线程就会对counterCells数组里面的具体counterCells对象的value属性进行++操作，最后baseCount的值就是数组里所有value值的总和</p>
<p>counterCells数组就是用来维护baseCount的</p>
<p>对数组中每一个对象都没操作成功就说明这个数组该扩容了，扩容的标准就是线程的数量，或者说计算机CPU的核数，因为一个线程操作一个数组位</p>
<p>值加成功就退出循环，加失败就一直循环，即自旋</p>
<p>sumCount当前集合的长度，就是通过baseCount和对counterCells对象的value累加获得的</p>
<p>判断集合长度的目的就是为了扩容</p>
<p>transfer(x,x)协助扩容，transfer(x,null)自行扩容</p>
<p>transfer方法就是扩容方法</p>
<p>nextTable是扩容后的新数组</p>
<p>transferIndex是旧数组的size</p>
<p>把原来大数组划分为几个小块，一个线程负责一个块去进行数据迁移到新数组，stride就是块的数目，根据CPU的核数即线程数计算，一个线程最少负责size为16的数组迁移</p>
<p>synchronized(f)保证迁移的时候别的线程没有添加节点，锁住的就是当前链表的首节点</p>
<p>helpTansfer帮助扩容</p>
<p>协助扩容是以领任务的方式从后往前，最小任务数量是16</p>
<p>位运算效率最高，因为是二进制运算</p>
<p>加锁影响效率，所以用CAS+自旋的操作</p>
<h2 id="ConcurrentHashMap为什么不允许空键和空值"><a href="#ConcurrentHashMap为什么不允许空键和空值" class="headerlink" title="ConcurrentHashMap为什么不允许空键和空值"></a>ConcurrentHashMap为什么不允许空键和空值</h2><p>代码层面，get(null)，计算hash值的时候就抛异常了，而HashMap里若key&#x3D;&#x3D;null，hash值会被设为0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.get</span></span><br><span class="line"><span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());		<span class="comment">//此处抛异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap.get</span></span><br><span class="line"><span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap.hash</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>再说containsKey方法，里面调用get方法，也是抛异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>再说containsValue方法，对value是否为空进行了判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br></pre></td></tr></table></figure>

<p>put方法，根本put不进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br></pre></td></tr></table></figure>

<p>这是实现</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：ConcurrentHashMap源码解析</li>
        <li>Post author：Lisj</li>
        <li>Create time：2022-09-08 22:13:10</li>
        <li>
            Post link：https://lisj98.github.io/2022/09/08/ConcurrentHashMap源码解析/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/ConcurrentHashMap/">#ConcurrentHashMap</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/09/08/IO%E7%90%86%E8%AE%BA/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">IO理论</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/09/08/LinkedHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LinkedHashMap源码解析</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Lisj</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%89%8D%E6%83%85%E6%8F%90%E8%A6%81"><span class="nav-text">1. 前情提要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-text">2. 源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%B1%9E%E6%80%A7"><span class="nav-text">2.1. 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%96%B9%E6%B3%95"><span class="nav-text">2.2. 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put%E6%96%B9%E6%B3%95"><span class="nav-text">put方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#initTable%E6%96%B9%E6%B3%95"><span class="nav-text">initTable方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resizeStamp%E6%96%B9%E6%B3%95"><span class="nav-text">resizeStamp方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#addCount%E6%96%B9%E6%B3%95"><span class="nav-text">addCount方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fullAddCount%E6%96%B9%E6%B3%95"><span class="nav-text">fullAddCount方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#helpTransfer%E6%96%B9%E6%B3%95"><span class="nav-text">helpTransfer方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transfer%E6%96%B9%E6%B3%95"><span class="nav-text">transfer方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tryPresize%E6%96%B9%E6%B3%95"><span class="nav-text">tryPresize方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isEmpty%E6%96%B9%E6%B3%95"><span class="nav-text">isEmpty方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get%E6%96%B9%E6%B3%95"><span class="nav-text">get方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#containsKey%E6%96%B9%E6%B3%95"><span class="nav-text">containsKey方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#containsValue%E6%96%B9%E6%B3%95"><span class="nav-text">containsValue方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E8%A1%A5%E5%85%85"><span class="nav-text">3. 补充</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#unSafe%E7%B1%BB"><span class="nav-text">unSafe类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#compareAndSwapInt%E6%96%B9%E6%B3%95"><span class="nav-text">compareAndSwapInt方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tabAt%E6%96%B9%E6%B3%95"><span class="nav-text">tabAt方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#casTabAt%E6%96%B9%E6%B3%95"><span class="nav-text">casTabAt方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objectFieldOffset%E6%96%B9%E6%B3%95"><span class="nav-text">objectFieldOffset方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E7%A9%BA%E9%94%AE%E5%92%8C%E7%A9%BA%E5%80%BC"><span class="nav-text">ConcurrentHashMap为什么不允许空键和空值</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>




<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
