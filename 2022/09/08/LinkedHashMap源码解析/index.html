<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Java、数据结构">
    <meta name="description" content="所见即所得">
    <meta name="author" content="Lisj">
    
    <title>
        
            LinkedHashMap源码解析 |
        
        BlogOfLisj
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/l-solid.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"lisj98.github.io","root":"/","language":"en","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#FF00FF","avatar":"/images/Neymar.jpg","favicon":"/images/l-solid.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"What you see is what you get."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="BlogOfLisj" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                BlogOfLisj
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LinkedHashMap源码解析</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/Neymar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Lisj</span>
                        
                            <span class="author-label">中忍</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-09-08 22:12:08</span>
        <span class="mobile">2022-09-08 22:12</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E9%9B%86%E5%90%88/">集合</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/LinkedHashMap/">LinkedHashMap</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>4.3k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>20 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>TODO：红黑树的逻辑</p>
<h1 id="1-前情提要"><a href="#1-前情提要" class="headerlink" title="1. 前情提要"></a>1. 前情提要</h1><p>LinkedHashMap继承了HashMap</p>
<p>LinkedHashMap和HashMap的不同之处就在于前者维护了一个双向链表，而后者包含的是单向链表。要注意这个双向链表不是说每个桶里的都是单独的双向链表，而是所有桶里的所有节点都连了起来构成了一个双向链表。具体理解见<a href="#222">2.2.2. put方法</a>。</p>
<p>LinkedHashMap能保证插入顺序，即最后遍历出来的集合和插入时的顺序是一致的，而不是HashMap那种随机的。要说明的一点是HashMap里也不是随机的，它这个随机指的是插入顺序和遍历顺序不一致，不管你怎么插入，它的遍历方式默认是根据桶的顺序从前往后一个链表一个链表的输出，所以它每一个桶中的单向链表是可以保证顺序的，但是整体结合起来就不能保证顺序了。具体见<a href="#2218">2.2.18. 几个迭代器</a>。</p>
<p>LinkedHashMap中还有一种按访问时间排序的排序方式，最不常访问-&gt;最近访问，需要通过一种特殊的构造器来实现。put, putIfAbsent, get, getOrDefault, compute, computeIfAbsent, computeIfPresent, merge 这些方法都会对被访问的Entry更新一次访问，replace方法只有在被访问Entry的值得到修改之后才会更新访问，putAll方法会给所有Entry条目更新一次访问。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">8</span>,<span class="number">0.75f</span>,<span class="literal">true</span>);</span><br><span class="line">map.put(<span class="string">&#x27;c&#x27;</span>,<span class="number">4</span>);</span><br><span class="line">map.put(<span class="string">&#x27;e&#x27;</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="string">&#x27;d&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">map.replace(<span class="string">&#x27;e&#x27;</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;Character, Integer&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Character character, Integer integer)</span> &#123;</span><br><span class="line">		System.out.println(character+<span class="string">&quot; &quot;</span>+integer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c <span class="number">4</span></span><br><span class="line">d <span class="number">1</span></span><br><span class="line">e <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>其他的允许空键空值、初始容量、负载因子、非同步、迭代器快速失败就和就和HashMap一样了</p>
<p>说白了，LinkedHashMap就是为了解决HashMap无法保证输出顺序的问题而生的。</p>
<h1 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h1><h2 id="2-1-静态常量"><a href="#2-1-静态常量" class="headerlink" title="2.1. 静态常量"></a>2.1. 静态常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表头节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表尾节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否按访问时间排序，构造函数中会用到</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2.2. 方法"></a>2.2. 方法</h2><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/LinkedHashMap/LinkedHashMap%E5%85%A8%E9%83%A8%E6%96%B9%E6%B3%95.1ri1zh0sh5og.webp" alt="LinkedHashMap全部方法"></p>
<h3 id="2-2-1-构造方法"><a href="#2-2-1-构造方法" class="headerlink" title="2.2.1. 构造方法"></a>2.2.1. 构造方法</h3><p>五种，基本上都是调用父类HashMap的操作，值得注意的是e.设定按访问时间排序的那种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.无参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>();</span><br><span class="line">	accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.指定初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(initialCapacity);</span><br><span class="line">	accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.指定初始容量和负载因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">	accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//d.复制一个Map</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>();</span><br><span class="line">	accessOrder = <span class="literal">false</span>;</span><br><span class="line">	putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//e.设定为按访问时间排序，accessOrder = true</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                     <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                     <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">	<span class="built_in">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-put方法"><a href="#2-2-2-put方法" class="headerlink" title="2.2.2. put方法"></a>2.2.2. put方法<a id="222"></a></h3><p>全部调用父类HashMap的put方法，但是父类HashMap是个单向链表，这是个双向链表，怎么适用的呢？head和tail在哪里初始化的呢？答案是这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap.putVal</span></span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>由于子类LinkedHashMap重写了newNode方法，因此创建的节点是特殊双向链表类型的节点，这个节点大体上还是HashMap中的节点没变，每个桶中单向链表的链接方式也没变，但是每个Entry对象中多了一个before和after对象，这就意味着在原哈希表不变的基础上将每个节点按照插入的顺序前后链接了起来，而不管这个节点落在了哪个桶中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap.newNode</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">	LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">	    <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">	linkNodeLast(p);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap.linkNodeLast</span></span><br><span class="line"><span class="comment">//head和tail都是在这里初始化的</span></span><br><span class="line"><span class="comment">//第一次插入节点，tail和head都为空，因此指向同一节点p(首次插入的节点)；之后last不可能为空，则tail向后移动,head始终不变</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">	LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">	tail = p;</span><br><span class="line">	<span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">		head = p;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		p.before = last;</span><br><span class="line">		last.after = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/LinkedHashMap/Node%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.1inwe8wyl9b.gif" alt="Node初始化过程"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap.Entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">	Entry&lt;K,V&gt; before, after;	<span class="comment">//before, after分别指向当前节点的前驱结点和后继节点</span></span><br><span class="line">	Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">		<span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/LinkedHashMap/LinkedHashMap%E9%9D%9E%E5%B8%B8%E8%A7%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.4dakza8830u0.webp" alt="LinkedHashMap非常规双向链表"></p>
<p>如果你把这个“双向链表”理解成了每个桶中单向链表修改成双向链表，那么一定有个疑问，LinkedHashMap使用的是HashMap的put方法，那些tab[i]命中桶的逻辑在LinkedHashMap中没有实现，怎么命中的呢？通过这个图就知道，HashMap我什么都没动，只是拿过来添加了另外的两条线，我什么都用HashMap的，只是最后遍历输出时用我自己的遍历方法而已。</p>
<h3 id="2-2-3-get方法"><a href="#2-2-3-get方法" class="headerlink" title="2.2.3. get方法"></a>2.2.3. get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和父类HashMap的get方法基本一致，只不过多了一个是否需要按访问时间进行排序的判断条件</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (accessOrder)</span><br><span class="line">		afterNodeAccess(e);</span><br><span class="line">	<span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////设定一个默认值，若查询到节点则以节点的value返回；若未查询到节点则以自定义的默认值返回</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> defaultValue;</span><br><span class="line">       <span class="keyword">if</span> (accessOrder)</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">       <span class="keyword">return</span> e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-afterNodeAccess方法"><a href="#2-2-4-afterNodeAccess方法" class="headerlink" title="2.2.4. afterNodeAccess方法"></a>2.2.4. afterNodeAccess方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将最近访问的节点移动到最后，适用于按访问时间排序输出时</span></span><br><span class="line"><span class="comment">//注意这个方法只是操作双向链表的(红线，与黑线无关)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">	LinkedHashMap.Entry&lt;K,V&gt; last;	<span class="comment">//e是需要移动的节点,last是原链表最后一个节点</span></span><br><span class="line">	<span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">		LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">		    (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;	<span class="comment">//a</span></span><br><span class="line">		p.after = <span class="literal">null</span>;	<span class="comment">//b</span></span><br><span class="line">		<span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">			head = a;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			b.after = a;	<span class="comment">//c</span></span><br><span class="line">		<span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">			a.before = b;	<span class="comment">//d</span></span><br><span class="line">		<span class="type">else</span></span><br><span class="line">			<span class="variable">last</span> <span class="operator">=</span> b;</span><br><span class="line">		<span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">			head = p;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p.before = last;	<span class="comment">//e</span></span><br><span class="line">			last.after = p;	<span class="comment">//f</span></span><br><span class="line">		&#125;</span><br><span class="line">		tail = p;	<span class="comment">//g</span></span><br><span class="line">		++modCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合put方法最后的那张图，这个方法实际上并没有对基础哈希表(黑线)做什么改变，它只是将双向链表中某一个节点(红线)移动到链表末尾(head、tail、after、before都是LinkedHashMap特有的，比HashMap多的)，从而实现按访问时间排序的目的。</p>
<p>abcdefg分别对应下图中的7张图：</p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/LinkedHashMap/afterNodeAccess%E6%93%8D%E4%BD%9C.2tphyh44use0.gif" alt="afterNodeAccess操作"></p>
<h3 id="2-2-5-afterNodeInsertion方法"><a href="#2-2-5-afterNodeInsertion方法" class="headerlink" title="2.2.5. afterNodeInsertion方法"></a>2.2.5. afterNodeInsertion方法</h3><p>插入节点后移除创建最久的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">	LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">//但是removeEldestEntry()这个方法在不重写的情况下返回false，所以永远不会进入这个if语句</span></span><br><span class="line">    <span class="comment">//那这个方法有什么用？可能是重新实现一个LinkedHashMap时会用到吧，重写removeEldestEntry()这个方法</span></span><br><span class="line">	<span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">		<span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">		removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-6-removeEldestEntry方法"><a href="#2-2-6-removeEldestEntry方法" class="headerlink" title="2.2.6. removeEldestEntry方法"></a>2.2.6. removeEldestEntry方法</h3><p>移除创建最久的Entry</p>
<p>官方文档中写着可以通过这种方法控制Entry的条目数，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方法是个protected方法，这意味着只有在和LinkedHashMap同包的类才能使用，所以重新实现一个LinkedHashMap再重写这个方法时才能用到？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-7-afterNodeRemoval方法"><a href="#2-2-7-afterNodeRemoval方法" class="headerlink" title="2.2.7. afterNodeRemoval方法"></a>2.2.7. afterNodeRemoval方法</h3><p>HashMap.removeNode方法后处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap.removeNode</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	afterNodeRemoval(node);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于仅修改双向链表的指向</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">	LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">	    (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">	p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">		head = a;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		b.after = a;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">		tail = b;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-8-containsValue方法"><a href="#2-2-8-containsValue方法" class="headerlink" title="2.2.8. containsValue方法"></a>2.2.8. containsValue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用双向链表遍历，速度更快；HashMap是先定位桶，再遍历链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after) &#123;</span><br><span class="line">		<span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> e.value;</span><br><span class="line">		<span class="keyword">if</span> (v == value || (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-9-clear方法"><a href="#2-2-9-clear方法" class="headerlink" title="2.2.9. clear方法"></a>2.2.9. clear方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比HashMap多了一步，将双向链表的首尾节点置空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>.clear();</span><br><span class="line">	head = tail = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-10-replaceAll方法"><a href="#2-2-10-replaceAll方法" class="headerlink" title="2.2.10. replaceAll方法"></a>2.2.10. replaceAll方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换所有key的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; function)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (function == <span class="literal">null</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">	<span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">	<span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">		e.value = function.apply(e.key, e.value);</span><br><span class="line">	<span class="keyword">if</span> (modCount != mc)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">map.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="number">33</span>,<span class="number">1</span>);</span><br><span class="line">map.replaceAll(<span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//第一个参数为key，第二个参数为value</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer integer, Integer integer2)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> integer+integer2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">	Map.Entry&lt;Integer, Integer&gt; m = it.next();</span><br><span class="line">	System.out.println(m.getKey()+<span class="string">&quot; &quot;</span>+m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">17</span> <span class="number">25</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">33</span> <span class="number">34</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-11-replacementNode方法"><a href="#2-2-11-replacementNode方法" class="headerlink" title="2.2.11. replacementNode方法"></a>2.2.11. replacementNode方法</h3><p>用新节点替换旧节点(链表)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被调用地方：HashMap.untreeify：红黑树退化为链表</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">	Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">		Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">			hd = p;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tl.next = p;</span><br><span class="line">		tl = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap.replacementNode</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap.replacementNode</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="comment">//q记录要替换的原节点p</span></span><br><span class="line">	LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">    <span class="comment">//t为初始化完成的q</span></span><br><span class="line">	LinkedHashMap.Entry&lt;K,V&gt; t =</span><br><span class="line">	    <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">    <span class="comment">//用t替换p</span></span><br><span class="line">	transferLinks(q, t);</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap和LinkedHashMap中处理逻辑基本一致，都是创建一个新节点复制原节点的信息，再将新节点链接起来，只不过LinkedHashMap中多了双向链表的逻辑</p>
<h3 id="2-2-12-replacementTreeNode方法"><a href="#2-2-12-replacementTreeNode方法" class="headerlink" title="2.2.12. replacementTreeNode方法"></a>2.2.12. replacementTreeNode方法</h3><p>用新节点替换旧节点(红黑树)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被调用地方：HashMap.treeifyBin：链表进化为红黑树</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n, index;</span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">		resize();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">		TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">			<span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">				hd = p;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				p.prev = tl;</span><br><span class="line">				tl.next = p;</span><br><span class="line">			&#125;</span><br><span class="line">			tl = p;</span><br><span class="line">		&#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">		<span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">			hd.treeify(tab);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap.replacementTreeNode</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap.replacementTreeNode</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">	LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">	TreeNode&lt;K,V&gt; t = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">	transferLinks(q, t);</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap和LinkedHashMap中处理逻辑基本一致，都是创建一个新节点复制原节点的信息，再将新节点链接起来，只不过LinkedHashMap中多了双向链表的逻辑</p>
<h3 id="2-2-13-transferLinks方法"><a href="#2-2-13-transferLinks方法" class="headerlink" title="2.2.13. transferLinks方法"></a>2.2.13. transferLinks方法</h3><p>更新双向链表中的链接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * src：原Entry</span></span><br><span class="line"><span class="comment"> * dst：目的Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span><br><span class="line"><span class="params">                           LinkedHashMap.Entry&lt;K,V&gt; dst)</span> &#123;</span><br><span class="line">	LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">	LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">		head = dst;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		b.after = dst;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">		tail = dst;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		a.before = dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-14-forEach方法"><a href="#2-2-14-forEach方法" class="headerlink" title="2.2.14. forEach方法"></a>2.2.14. forEach方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据双向链表的顺序输出；HashMap是根据桶的顺序一个链表一个链表的输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">	<span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">	<span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">		action.accept(e.key, e.value);</span><br><span class="line">	<span class="keyword">if</span> (modCount != mc)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-15-entrySet方法"><a href="#2-2-15-entrySet方法" class="headerlink" title="2.2.15. entrySet方法"></a>2.2.15. entrySet方法</h3><p>将LinkedHashMap里的每个&lt;K,V&gt;(键值对)封装成Entry对象，并返回Entry对象的Set集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">	Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">	<span class="keyword">return</span> (es = entrySet) == <span class="literal">null</span> ? (entrySet = <span class="keyword">new</span> <span class="title class_">LinkedEntrySet</span>()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<p>entrySet属性定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>

<p>LinkedEntrySet内部类定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedEntrySet内部类定义</span></span><br><span class="line"><span class="comment">//继承于AbstractSet，是一个Entry对象的Set集合</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedEntrySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">	<span class="comment">//EntrySet的大小，即LinkedHashMap的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空HashMap</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123;</span><br><span class="line">		LinkedHashMap.<span class="built_in">this</span>.clear();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取遍历Entry对象的迭代器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedEntryIterator</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断LinkedHashMap中是否含有某对键值对，传入的参数应该是个Entry对象，即封装好后的键值对</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">		Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">		<span class="keyword">return</span> candidate != <span class="literal">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除LinkedHashMap中某对键值对，参数要求同上</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">			Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">			<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">			<span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">		<span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, Spliterator.SIZED |</span><br><span class="line">		                                Spliterator.ORDERED |</span><br><span class="line">		                                Spliterator.DISTINCT);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历EntrySet，在accept()方法中自定义操作</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">		<span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">		<span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">			action.accept(e);</span><br><span class="line">		<span class="keyword">if</span> (modCount != mc)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">map1.put(<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">map1.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map1.put(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">map2.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map2.put(<span class="number">9</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//iterator()方法获取迭代器，it实际是一个LinkedEntryIterator对象</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map1.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">	Map.Entry&lt;Integer, Integer&gt; entry1 = it.next();</span><br><span class="line">	<span class="comment">//contains()方法</span></span><br><span class="line">	<span class="keyword">if</span>(map2.entrySet().contains(entry1)) &#123;</span><br><span class="line">		flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//remove()方法</span></span><br><span class="line">		map2.entrySet().remove(entry1);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;key：&quot;</span>+entry1.getKey()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;Value：&quot;</span>+entry1.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//forEach()方法</span></span><br><span class="line">map2.entrySet().forEach(entry2 -&gt; System.out.println(<span class="string">&quot;key：&quot;</span>+entry2.getKey()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;Value：&quot;</span>+entry2.getValue()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//size()方法</span></span><br><span class="line">System.out.println(map1.entrySet().size());</span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key：<span class="number">1</span> Value：<span class="number">9</span></span><br><span class="line">key：<span class="number">17</span> Value：<span class="number">8</span></span><br><span class="line">key：<span class="number">5</span> Value：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">key：<span class="number">9</span> Value：<span class="number">9</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-16-keySet方法"><a href="#2-2-16-keySet方法" class="headerlink" title="2.2.16. keySet方法"></a>2.2.16. keySet方法</h3><p>返回所有key的Set集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原理和entrySet方法一样</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">	Set&lt;K&gt; ks = keySet;</span><br><span class="line">	<span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">		ks = <span class="keyword">new</span> <span class="title class_">LinkedKeySet</span>();</span><br><span class="line">		keySet = ks;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<p>keySet属性定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;K&gt;        keySet;</span><br></pre></td></tr></table></figure>

<p>LinkedKeySet内部类定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedKeySet内部类定义</span></span><br><span class="line"><span class="comment">//原理和LinkedEntrySet内部类一样</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedKeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123;</span><br><span class="line">		LinkedHashMap.<span class="built_in">this</span>.clear();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedKeyIterator</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> containsKey(o);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title function_">spliterator</span><span class="params">()</span>  &#123;</span><br><span class="line">		<span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, Spliterator.SIZED |</span><br><span class="line">		                                Spliterator.ORDERED |</span><br><span class="line">		                                Spliterator.DISTINCT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> K&gt; action)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">		<span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">		<span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">			action.accept(e.key);</span><br><span class="line">		<span class="keyword">if</span> (modCount != mc)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例类比entrySet方法</p>
<h3 id="2-2-17-values方法"><a href="#2-2-17-values方法" class="headerlink" title="2.2.17. values方法"></a>2.2.17. values方法</h3><p>返回所有value的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">	Collection&lt;V&gt; vs = values;</span><br><span class="line">	<span class="keyword">if</span> (vs == <span class="literal">null</span>) &#123;</span><br><span class="line">		vs = <span class="keyword">new</span> <span class="title class_">LinkedValues</span>();</span><br><span class="line">		values = vs;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<p>values属性定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure>

<p>LinkedValues内部类定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedValues内部类定义</span></span><br><span class="line"><span class="comment">//原理和LinkedEntrySet内部类一样</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedValues</span> <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;V&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123;</span><br><span class="line">		LinkedHashMap.<span class="built_in">this</span>.clear();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedValueIterator</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> containsValue(o);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, Spliterator.SIZED |</span><br><span class="line">		                                Spliterator.ORDERED);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">		<span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">		<span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">			action.accept(e.value);</span><br><span class="line">		<span class="keyword">if</span> (modCount != mc)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例类比entrySet方法</p>
<h3 id="2-2-18-几个迭代器"><a href="#2-2-18-几个迭代器" class="headerlink" title="2.2.18. 几个迭代器"></a>2.2.18. 几个迭代器<a id="2218"></a></h3><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/LinkedHashMap/LinkedHashMap%E5%87%A0%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8.3wnmjm0gbpw0.webp" alt="LinkedHashMap几个迭代器"></p>
<p>大体和HashMap的迭代器差不多</p>
<p>区别就在于迭代输出方式，HashMap是根据桶的顺序从前往后一个链表一个链表的输出，LinkedHashMap是根据双向链表链接的顺序输出</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>,<span class="number">0.75f</span>);</span><br><span class="line"><span class="comment">//1，17，33在同一个桶里</span></span><br><span class="line">map.put(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">map.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="number">33</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">	Map.Entry&lt;Integer, Integer&gt; m = it.next();</span><br><span class="line">	System.out.println(m.getKey()+<span class="string">&quot; &quot;</span>+m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个it引用指向的是一个LinkedEntryIterator对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap.LinkedEntryIterator</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedEntryIterator</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashIterator</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Map.Entry&lt;K,V&gt; <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nextNode();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而输出时调用到了next()方法，实际上调用了nextNode()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap.nextNode</span></span><br><span class="line"><span class="keyword">final</span> LinkedHashMap.Entry&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">	LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">	<span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">	<span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">	current = e;</span><br><span class="line">	next = e.after;</span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就是在双向链表中根据after这个属性往后遍历，所以插入顺序是怎么样的，输出顺序就是怎么样的(不按访问时间排序的情况下)。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：LinkedHashMap源码解析</li>
        <li>Post author：Lisj</li>
        <li>Create time：2022-09-08 22:12:08</li>
        <li>
            Post link：https://lisj98.github.io/2022/09/08/LinkedHashMap源码解析/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/LinkedHashMap/">#LinkedHashMap</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/09/08/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">ConcurrentHashMap源码解析</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/09/08/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">HashMap源码解析</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Lisj</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%89%8D%E6%83%85%E6%8F%90%E8%A6%81"><span class="nav-text">1. 前情提要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-text">2. 源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F"><span class="nav-text">2.1. 静态常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%96%B9%E6%B3%95"><span class="nav-text">2.2. 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.1. 构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-put%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.2. put方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-get%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.3. get方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-afterNodeAccess%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.4. afterNodeAccess方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-5-afterNodeInsertion%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.5. afterNodeInsertion方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-6-removeEldestEntry%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.6. removeEldestEntry方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-7-afterNodeRemoval%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.7. afterNodeRemoval方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-8-containsValue%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.8. containsValue方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-9-clear%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.9. clear方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-10-replaceAll%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.10. replaceAll方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-11-replacementNode%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.11. replacementNode方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-12-replacementTreeNode%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.12. replacementTreeNode方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-13-transferLinks%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.13. transferLinks方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-14-forEach%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.14. forEach方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-15-entrySet%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.15. entrySet方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-16-keySet%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.16. keySet方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-17-values%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.17. values方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-18-%E5%87%A0%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">2.2.18. 几个迭代器</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>




<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
