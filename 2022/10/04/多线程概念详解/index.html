<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Java、数据结构">
    <meta name="description" content="所见即所得">
    <meta name="author" content="Lisj">
    
    <title>
        
            多线程概念详解 |
        
        BlogOfLisj
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/l-solid.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"lisj98.github.io","root":"/","language":"en","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#FF00FF","avatar":"/images/Neymar.jpg","favicon":"/images/l-solid.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"What you see is what you get."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="BlogOfLisj" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                BlogOfLisj
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">多线程概念详解</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/Neymar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Lisj</span>
                        
                            <span class="author-label">中忍</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-10-04 14:03:19</span>
        <span class="mobile">2022-10-04 14:03</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/">多线程概念</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>5.7k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>20 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="1-进程和线程的区别？"><a href="#1-进程和线程的区别？" class="headerlink" title="1. 进程和线程的区别？"></a>1. 进程和线程的区别？</h1><ul>
<li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位，一个进程包含多个线程；</li>
<li>并发性：多个进程可以并发执行，多个线程也可以并发执行；</li>
<li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有资源，但可以访问所属进程的资源；</li>
<li>系统开销：在创建和撤销进程的时候，都要为其分配和释放资源，所以创建和撤销进程的资源要大于创建和撤销线程的资源；</li>
<li>内存空间：进程有独立的地址空间，线程有自己的堆栈和局部变量，但没有独立的地址空间。</li>
</ul>
<h1 id="2-什么叫线程安全？"><a href="#2-什么叫线程安全？" class="headerlink" title="2. 什么叫线程安全？"></a>2. 什么叫线程安全？</h1><p>如果代码所在进程中有多个线程在同时运行，并且这些线程会同时运行某一段代码，如果每次运行的结果和单线程运行这段代码的结果一致，而且各个变量的值也和预期的一样，那么这段代码就是线程安全的。</p>
<h1 id="3-线程的几种状态？"><a href="#3-线程的几种状态？" class="headerlink" title="3. 线程的几种状态？"></a>3. 线程的几种状态？</h1><ul>
<li><code>新建状态（NEW）</code>：新创建了一个线程对象；</li>
<li><code>就绪状态（RUNNABLE）</code>：线程处于可运行状态，除了CPU之外，其他的运行所需资源都已全部获得；</li>
<li><code>运行状态（RUNNING）</code>：就绪状态的线程获得了CPU的使用权，程序代码开始执行；</li>
<li><code>阻塞状态（BLOCKED）</code>：线程因某种原因而放弃CPU，暂时停止运行。阻塞的情况分三种：<ul>
<li><code>无条件等待阻塞</code>：调用了wait()、join()、LockSupport.park等方法、等待获得资源锁、等待某个I&#x2F;O请求完成。wait()需要另一线程调用notify()或notifyAll()唤醒；join()需要等待线程执行特定时间；</li>
<li><code>特定时间等待阻塞</code>：调用了sleep()、wait(time)、join(time)、LockSupport.parkNanos、LockSupport.parkUntil等方法。</li>
</ul>
</li>
<li><code>终止状态（TERMINATED）</code>：线程执行完毕或因异常退出了run()方法，该线程结束生命周期。</li>
</ul>
<h1 id="4-Java创建多线程后，调用start-和run-方法的区别？"><a href="#4-Java创建多线程后，调用start-和run-方法的区别？" class="headerlink" title="4. Java创建多线程后，调用start()和run()方法的区别？"></a>4. Java创建多线程后，调用start()和run()方法的区别？</h1><p>调用start()方法会执行一系列诸如线程状态检查、加入其对应的线程组、判断是否启动成功并维护线程组等动作，然后线程会被放到等待队列，等待CPU调度，这意味着<code>该线程并不会马上执行</code>，start()方法体中会调用到具体任务的run()方法；</p>
<p>而单单调用run()方法的话只是<code>普普通通地调用Runnable对象的一个方法，并没有经历start()方法所做的线程的准备工作</code>，和普通对象调用普通方法一样。<br><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%B0%83%E7%94%A8run%E5%92%8Cstart%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB.21ggpijdyqow.webp" alt="调用run和start方法的区别"><br><code>补充</code>：<code>定义任务用Runnable或Callable接口</code>，区别是前者不产生返回值，后者产生返回值，后者通常结合<code>Future</code>和<code>FutureTask</code>使用，用于异步获取结果，调用ExecutorService对象的submit()方法会产生Future对象，可以用isDone()方法来查询Future是否完成，用get()方法来获取结果；<code>定义线程用Thread</code>。</p>
<h1 id="5-对Future和FutureTask的理解？"><a href="#5-对Future和FutureTask的理解？" class="headerlink" title="5. 对Future和FutureTask的理解？"></a>5. 对Future和FutureTask的理解？</h1><ul>
<li><code>Future</code>是一个接口，为Runnable或Callable任务提供：①取消②查询是否取消成功③查询是否执行成功④获取执行结果的功能；</li>
<li><code>FutureTask</code>是Future接口的实现类，它既可以作为一个Runnable任务，也可以作为一个Future，它具备Future接口的所有功能，还额外提供了许多其他功能，例如设置结果，处理可能发生的中断等。</li>
</ul>
<p><code>Future模式的思想</code>就是在子线程执行的时候，主线程不阻塞仍继续执行，等到主线程需要子线程的执行结果时再去获取子线程的执行结果（此时子线程没有执行完成的话就会阻塞直至完成），主线程还可以根据一定的逻辑对子线程进行操作，例如设置是否需要阻塞等待子线程完成。</p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Future%E6%96%B9%E6%B3%95.6us4lzm0uys0.webp" alt="Future方法"></p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/FutureTask%E6%96%B9%E6%B3%95.14tsdz50pzs0.webp" alt="FutureTask方法"></p>
<h1 id="6-怎么解决共享资源竞争，实现线程安全？"><a href="#6-怎么解决共享资源竞争，实现线程安全？" class="headerlink" title="6. 怎么解决共享资源竞争，实现线程安全？"></a>6. 怎么解决共享资源竞争，实现线程安全？</h1><ul>
<li>使用<code>synchronized</code>关键字修饰方法或代码块：只有获得锁的线程才能访问资源；</li>
<li>使用<code>显示的Lock对象</code>对代码块进行加锁释放锁：只有获得锁的线程才能访问资源；</li>
<li>使用<code>原子类（AtomicInteger，AtomicLong，AtomicReference）</code>来保证原子性：原子操作是不能被线程调度机制中断的操作，一旦开始，那么就会在线程上下文切换之前完成，这样就保证了其他线程来不及修改这个变量，仅适用于简单操作，<code>原子性</code>就是其他线程不能对本线程做出的修改进行干涉，即不能中途插入进来改变变量的值；</li>
<li>使用<code>volatile</code>修饰域：只要某个线程对这个域进行了修改，其他的线程都将看到变化；</li>
<li>使用<code>线程本地存储（ThreadLocal）</code>：根除对变量的共享，为使用相同变量的每个不同的线程都创建不同的存储。</li>
</ul>
<h1 id="7-synchronized，volatile和CAS的区别？"><a href="#7-synchronized，volatile和CAS的区别？" class="headerlink" title="7. synchronized，volatile和CAS的区别？"></a>7. synchronized，volatile和CAS的区别？</h1><ul>
<li>synchronized保证可见性和原子性，会导致其他线程阻塞，属于悲观锁；</li>
<li>volatile保证可见性，不保证原子性，禁止指令重排，不需要加锁；</li>
<li>CAS保证可见性及原子性，不会导致其他线程阻塞，属于乐观锁。</li>
</ul>
<p><code>补充</code>：<br><code>Java内存模型</code>：Java所有变量都存储在主内存中，所有线程都可以访问；每个线程创建时，JVM会为其创建一个私有的工作内存，里面保存该线程使用到的变量的副本；线程对变量的操作都必须在自己的工作内存中进行，读取时从主内存将变量读取到工作内存中，在工作内存中修改完毕后再刷新到主内存中。<br><code>指令重排</code>：是指代码的执行过程有时并不是按照代码书写过程来的，编译器和CPU可以保证在输出结果一致的情况下对代码进行重排序优化，以提高执行效率。<br><code>内存屏障</code>：内存屏障是一个CPU指令，可以禁止指令重排，它可以确保屏障前的指令不会排到屏障后面，屏障后的指令不会排到屏障前面，即在内存屏障这条指令执行时，它前面的指令都已执行完毕。<br><code>volatile和内存屏障的关系</code>：当用volatile修饰一个变量时，会在对变量进行读操作前插入一个读屏障指令，在对变量进行写操作后插入一个写屏障指令。<br><code>volatile为什么不能保证原子性呢</code>：修改volatile变量分为四步，①从主内存中读取变量到工作内存中；②修改变量值；③写回到工作内存；④刷新回主内存。举个例子，一个变量i被volatile修饰，两个线程想对这个变量修改，都对其进行自增操作也就是i++，在字节码及底层，i++被抽象为三个操作：即先取值，再自加，再赋值三个操作，线程A首先得到了i的初始值100，但是还没来得及修改，就阻塞了，这时线程B开始了，它也得到了i的值，由于i的值未被修改，即使是被volatile修饰，主存的变量还没变化，那么线程B得到的值也是100，之后对其进行加1操作，得到101后，将新值写入到缓存中，再刷入主存中。根据可见性的原则，这个主存的值可以被其他线程可见。问题来了，线程A已经读取到了i的值为100，也就是说读取的这个原子操作已经结束了，接下来就不会再读取而是直接对变量进行改动了，所以这个可见性来的有点晚，即线程A不知道变量i已经被线程B修改了还在傻乎乎地延续它自己的修改，线程A阻塞结束后，继续将100这个值加1，得到101，再将值写到缓存，最后刷入主存，所以即便是volatile具有可见性，也不能保证对它修饰的变量具有原子性。</p>
<h1 id="8-用volatile修饰的变量和用atomic修饰的变量有什么不同？"><a href="#8-用volatile修饰的变量和用atomic修饰的变量有什么不同？" class="headerlink" title="8. 用volatile修饰的变量和用atomic修饰的变量有什么不同？"></a>8. 用volatile修饰的变量和用atomic修饰的变量有什么不同？</h1><p>用volatile修饰的变量不具有原子性，用atomic修饰的变量具有原子性。</p>
<h1 id="9-使用volatile关键字的场景？"><a href="#9-使用volatile关键字的场景？" class="headerlink" title="9. 使用volatile关键字的场景？"></a>9. 使用volatile关键字的场景？</h1><ul>
<li>对变量的写操作不依赖于当前值，比如自增、自减等操作；</li>
<li>该变量不宜和其他变量位于同一表达式中。</li>
</ul>
<p>总而言之，就是需要满足原子性操作的前提。</p>
<h1 id="10-synchronized和Lock的区别？"><a href="#10-synchronized和Lock的区别？" class="headerlink" title="10. synchronized和Lock的区别？"></a>10. synchronized和Lock的区别？</h1><ul>
<li>synchronized是一个关键字，而Lock是一个接口；</li>
<li>synchronized是隐式的加锁，Lock是显式的加锁；</li>
<li>synchronized可以作用在方法和代码块上，而Lock只能作用在代码块上；</li>
<li>synchronized是阻塞式加锁，而Lock中的tryLock()支持非阻塞式加锁；</li>
<li>synchronized没有超时机制，而Lock中的tryLock()可以支持超时机制；</li>
<li>synchronized不可中断，而Lock中的lockInterruptibly()可中断的获取锁。（ReentrantLock.lockInterruptibly()允许在等待时由其它线程调用等待线程的Thread.interrupt()方法来中断等待线程的等待而直接返回，这时不用获取锁，而会抛出一个InterruptedException。ReentrantLock.lock()方法不允许Thread.interrupt()中断，使检测到Thread.isInterrupted()一样会继续尝试获取锁，失败则继续休眠。只是在最后获取锁成功后再把当前线程置为interrupted状态,然后再中断线程）；</li>
<li>synchronized采用的是monitor对象监视器，Lock的底层原理是AQS；</li>
<li>synchronized只有一个同步队列和一个等待队列，而Lock有一个同步队列，可以有多个等待队列（同步队列：排队取锁的线程所在的队列；等待队列：调用wait()方法后，线程会从同步队列转移到等待队列）；</li>
<li>synchronized是非公平锁，而Lock可以是公平锁也可以是非公平锁；</li>
<li>synchronized用notify()方法进行唤醒，而Lock用condition唤醒；</li>
<li>Lock有ReadWriteLock支持并发读。</li>
</ul>
<h1 id="11-对wait-，notify-，和notifyAll-的理解？"><a href="#11-对wait-，notify-，和notifyAll-的理解？" class="headerlink" title="11. 对wait()，notify()，和notifyAll()的理解？"></a>11. 对wait()，notify()，和notifyAll()的理解？</h1><ul>
<li>wait()会在等待外部事件产生变化的时候将任务挂起，并且只有在notify()或notifyAll()发生时，即发生了某些令人感兴趣的事件时，这个任务才会被唤醒并重新执行；</li>
<li>wait()方法释放锁，notify()或notifyAll()方法加锁；</li>
<li>只能在同步控制方法或同步代码块（即用synchronized修饰）里调用wait()，notify()或notifyAll()方法；</li>
<li>在调用wait()，notify()或notifyAll()方法前必须先获得对象的锁；</li>
<li>notify()唤醒单个线程，但是不能指定具体条件，所以只有一个线程在等待时（即只有一个线程调用了wait()方法）才适用，notifyAll()唤醒所有等待线程（即所有调用了wait()方法的线程）。</li>
</ul>
<h1 id="12-wait-和sleep-的区别？"><a href="#12-wait-和sleep-的区别？" class="headerlink" title="12. wait()和sleep()的区别？"></a>12. wait()和sleep()的区别？</h1><ul>
<li>调用sleep()方法会导致此线程暂停执行指定时间，将CPU时间片让给其他线程，但是它<code>不会释放已获得的对象锁</code>；</li>
<li>调用wait()方法<code>会释放对象锁</code>，只有针对此对象调用notify()或notifyAll()方法后线程才会继续执行。</li>
</ul>
<h1 id="13-对yield-，join-的理解？"><a href="#13-对yield-，join-的理解？" class="headerlink" title="13. 对yield()，join()的理解？"></a>13. 对yield()，join()的理解？</h1><ul>
<li>yield()方法用于暂停正在执行的线程，将CPU的控制权转交给其他线程，本线程<code>进入就绪状态（注意不是阻塞状态）</code>，意在合理控制线程的执行流程；</li>
<li>join()方法可理解为<code>插队</code>，当一个线程需要等待另一个线程的返回结果时，就需要用到该方法，调用该方法的线程的优先级达到最高，其他线程要等待该线程执行完毕。</li>
</ul>
<h1 id="14-Java中什么是竞态条件？"><a href="#14-Java中什么是竞态条件？" class="headerlink" title="14. Java中什么是竞态条件？"></a>14. Java中什么是竞态条件？</h1><p>当多个线程访问同一资源时，如果对线程访问资源的顺序有要求，就称存在竞态条件。</p>
<h1 id="15-定时线程的使用？"><a href="#15-定时线程的使用？" class="headerlink" title="15. 定时线程的使用？"></a>15. 定时线程的使用？</h1><ul>
<li>使用定时器Timer类；</li>
<li>使用定时调度线程池ScheduledExecutorService。</li>
</ul>
<h1 id="16-线程同步常见方法？"><a href="#16-线程同步常见方法？" class="headerlink" title="16. 线程同步常见方法？"></a>16. 线程同步常见方法？</h1><p>sleep()，wait()，notify()，notifyAll()，await()，signal()，signalAll()。</p>
<h1 id="17-如何停止一个线程？"><a href="#17-如何停止一个线程？" class="headerlink" title="17. 如何停止一个线程？"></a>17. 如何停止一个线程？</h1><ul>
<li>run()方法或call()方法执行完后线程自动停止；</li>
<li>使用interrupt()方法中断线程。</li>
</ul>
<h1 id="18-interrupt-，interrupted-，isInterrupted-方法的区别？"><a href="#18-interrupt-，interrupted-，isInterrupted-方法的区别？" class="headerlink" title="18. interrupt()，interrupted()，isInterrupted()方法的区别？"></a>18. interrupt()，interrupted()，isInterrupted()方法的区别？</h1><ul>
<li><code>interrupt()</code>方法用于中断线程，但是仅仅是将线程的中断状态设置为ture，线程是否真的中断需要线程自己时不时的判断这个状态来决定。具体地说，当一个线程调用interrupt()方法时，①如果线程处于阻塞状态（sleep()，wait()，join()等），那么线程将立即退出阻塞状态，中断标志位复位为false，并抛出一个InterruptedException异常；②如果线程处于I&#x2F;O阻塞状态，那么中断标志位将置为true，并抛出一个ClosedByInterruptException异常(ClosedByInterruptException异常不是InterruptedException异常)；③如果线程处于NIO阻塞状态，那么中断标志位将置为true，并立即结束轮询操作；④如果线程处于正常状态，那么中断标志位将置为true。也就是说，线程检查到中断标志位为true时，就自行停止线程，处于阻塞状态的线程在检测到InterruptedException异常后，需要在catch中停止线程。</li>
<li><code>interrupted()</code>方法用于返回当前线程的中断状态，并且会清除中断标志（即中断标志复位为false），也就是说，如果一个被中断线程（中断标志为true）调用了该方法，那么返回的结果是true，但是当前线程的中断状态标志被清除为false了，下一次再调用该方法返回的状态结果就是false了。</li>
<li><code>isInterrupted()</code>方法用于返回调用该方法的线程对象所对应的线程的中断状态，但是它不会修改中断标志。interrupted()方法和isInterrupted()方法都是用来返回线程的中断状态的，区别就在于作用的线程对象不同，还有是否要清除中断标志状态位。</li>
</ul>
<p>中断标志位的判断：中断线程时，当线程抛出了一个InterruptedException异常，或者调用了interrupted()方法时，中断标志位会被复位为false，其他时候都为true。</p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/interrupt()%E3%80%81interrupted()%E3%80%81isInterrupted()%E5%8C%BA%E5%88%AB.78005z3pai00.webp" alt="interrupt()、interrupted()、isInterrupted()区别"></p>
<h1 id="19-线程池的优点？"><a href="#19-线程池的优点？" class="headerlink" title="19. 线程池的优点？"></a>19. 线程池的优点？</h1><ul>
<li>重用存在的线程，减少开销；</li>
<li>可有效地控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免阻塞；</li>
<li>可提供定时执行，并发数控制等功能。</li>
</ul>
<h1 id="20-实现多线程有哪些方式（线程的创建方式）？"><a href="#20-实现多线程有哪些方式（线程的创建方式）？" class="headerlink" title="20. 实现多线程有哪些方式（线程的创建方式）？"></a>20. 实现多线程有哪些方式（线程的创建方式）？</h1><ul>
<li>实现Runnable接口，重写run()方法，再将Runnable对象传给Thread的构造函数；</li>
<li>实现Callable接口，重写call()方法，再结合Future接口，将Future对象传给Thread的构造函数；</li>
<li>继承Thread类，重写run()方法，Thread实现了Runnable接口，因此含有run()方法；</li>
<li>使用线程池。</li>
</ul>
<h1 id="21-什么是乐观锁和悲观锁？"><a href="#21-什么是乐观锁和悲观锁？" class="headerlink" title="21. 什么是乐观锁和悲观锁？"></a>21. 什么是乐观锁和悲观锁？</h1><ul>
<li><code>乐观锁</code>：就像它的名字一样，对并发间操作产生的线程安全问题持乐观状态，它认为竞争不总是会发生，因此它不需要持有锁，将比较-替换两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，则进行相应的重试机制；</li>
<li><code>悲观锁</code>：还是像它的名字一样，对并发间操作产生的线程安全问题持悲观状态，它认为竞争总是会发生，因此每次对某资源进行操作时，总是会对资源进行加锁，除非它释放锁，不然别的线程只有一直等待。</li>
</ul>
<h1 id="22-什么叫死锁？"><a href="#22-什么叫死锁？" class="headerlink" title="22. 什么叫死锁？"></a>22. 什么叫死锁？</h1><p>某个线程在等待另一个线程，而后者又等待别的线程，这样一直下去，直到这个链条上的线程又在等待第一个线程释放锁，这就造成了各个线程之间相互等待无法释放锁，导致线程无法继续执行下去，这被称为死锁。</p>
<h1 id="23-产生死锁的四个必要条件？"><a href="#23-产生死锁的四个必要条件？" class="headerlink" title="23. 产生死锁的四个必要条件？"></a>23. 产生死锁的四个必要条件？</h1><ul>
<li><code>互斥条件</code>：线程使用的资源中至少有一个是不能共享的；</li>
<li><code>请求与保持条件</code>：一个线程因请求资源而阻塞时，对已获得的资源保持不放；</li>
<li><code>不剥夺条件</code>：资源不能被线程强行抢占；</li>
<li><code>循环等待条件</code>：若干线程之间形成一种头尾相连的循环等待资源关系。</li>
</ul>
<p>同时满足以上四个条件时，就会产生死锁。</p>
<h1 id="24-导致死锁的原因？"><a href="#24-导致死锁的原因？" class="headerlink" title="24. 导致死锁的原因？"></a>24. 导致死锁的原因？</h1><ul>
<li>资源竞争不当</li>
<li>线程获取锁的顺序不当</li>
</ul>
<h1 id="25-守护（后台）线程和非守护线程的区别？"><a href="#25-守护（后台）线程和非守护线程的区别？" class="headerlink" title="25. 守护（后台）线程和非守护线程的区别？"></a>25. 守护（后台）线程和非守护线程的区别？</h1><p><code>守护线程</code>是指程序运行的时候在后台提供一种通用服务的线程。当所有的非守护线程结束时，程序也就终止了，也就是JVM停止运行了，同时会杀死进程中的所有守护线程，换句话说，只要有任何非守护线程还在运行，程序就不会终止，守护线程也不会被干掉。守护线程的一个例子就是垃圾回收器，只要JVM不停止，垃圾收集器就会一直运行下去。</p>
<h1 id="26-什么是多线程的上下文切换？"><a href="#26-什么是多线程的上下文切换？" class="headerlink" title="26. 什么是多线程的上下文切换？"></a>26. 什么是多线程的上下文切换？</h1><p>多线程的上下文切换是指CPU的控制权由一个正在运行的线程切换到另一个处于就绪状态并等待CPU执行权的线程的过程。</p>
<h1 id="27-怎么唤醒一个阻塞的线程？"><a href="#27-怎么唤醒一个阻塞的线程？" class="headerlink" title="27. 怎么唤醒一个阻塞的线程？"></a>27. 怎么唤醒一个阻塞的线程？</h1><ul>
<li>sleep()或join()导致的阻塞：等待时间完成或上一个线程执行完成；</li>
<li>wait()：使用notify()或notifyAll()。</li>
</ul>
<h1 id="28-线程池中execute-和submit-方法的区别？"><a href="#28-线程池中execute-和submit-方法的区别？" class="headerlink" title="28. 线程池中execute()和submit()方法的区别？"></a>28. 线程池中execute()和submit()方法的区别？</h1><ul>
<li>execute()是Executor接口中的方法，submit()是ExecutorService接口中的方法，ExecutorService接口继承了Executor接口；</li>
<li>execute()只能接受Runnable任务参数，submit()既可以接受Runnable任务参数也可以接受Callable任务参数；</li>
<li>execute()没有返回值，submit()返回Future类型对象。</li>
</ul>
<p>实际上submit()内部还是执行的execute()方法，只不过它既执行了任务还添加了一个返回值。</p>
<h1 id="29-如果提交任务时，线程池队列已满，这时会发生什么？"><a href="#29-如果提交任务时，线程池队列已满，这时会发生什么？" class="headerlink" title="29. 如果提交任务时，线程池队列已满，这时会发生什么？"></a>29. 如果提交任务时，线程池队列已满，这时会发生什么？</h1><p>非定长的队列会先扩容，扩容到不能再扩容了就调用拒绝策略，定长的线程池队列会直接调用拒绝策略。</p>
<h1 id="30-线程池的类型？"><a href="#30-线程池的类型？" class="headerlink" title="30. 线程池的类型？"></a>30. 线程池的类型？</h1><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%B1%BB%E5%9E%8B.48aamkpke2g0.webp" alt="线程池的类型"><br><code>补充</code>：7.默认线程池修改<br><code>ThreadPool threadPoolExecutor = new ThreadPoolExecutor(参数);</code></p>
<h1 id="31-线程池的几个重要参数？"><a href="#31-线程池的几个重要参数？" class="headerlink" title="31. 线程池的几个重要参数？"></a>31. 线程池的几个重要参数？</h1><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0.3wr65k37cns0.webp" alt="线程池的几个重要参数"></p>
<h1 id="32-线程池的阻塞队列有哪些？"><a href="#32-线程池的阻塞队列有哪些？" class="headerlink" title="32. 线程池的阻塞队列有哪些？"></a>32. 线程池的阻塞队列有哪些？</h1><table>
<thead>
<tr>
<th align="left">线程池类型</th>
<th align="left">队列类型</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>newCachedThreadPool</strong></td>
<td align="left"><strong>SynchronousQueue</strong></td>
<td align="left">同步队列，无缓冲，拿一个出来，放一个进去，例如生产者-消费者模式</td>
</tr>
<tr>
<td align="left"><strong>newFixedThreadPool</strong></td>
<td align="left"><strong>LinkedBlockingQueue</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>newScheduledThreadPool</strong></td>
<td align="left"><strong>DelayedWorkQueue</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>newSingleThreadExecutor</strong></td>
<td align="left"><strong>LinkedBlockingQueue</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>newSingleThreadScheduledExecutor</strong></td>
<td align="left"><strong>DelayedWorkQueue</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>newWorkStealingPool</strong></td>
<td align="left">可使用多种队列，每个线程对应一种队列</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>ThreadPoolExecutor</strong></td>
<td align="left">自行通过参数指定</td>
<td align="left">默认</td>
</tr>
</tbody></table>
<h1 id="33-线程池的拒绝策略有哪些？"><a href="#33-线程池的拒绝策略有哪些？" class="headerlink" title="33. 线程池的拒绝策略有哪些？"></a>33. 线程池的拒绝策略有哪些？</h1><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.3cezqfohock0.webp" alt="线程池的拒绝策略"></p>
<h1 id="锁到底是什么？锁的又是什么？"><a href="#锁到底是什么？锁的又是什么？" class="headerlink" title="锁到底是什么？锁的又是什么？"></a>锁到底是什么？锁的又是什么？</h1><p>首先要了解Java对象头的概念，Java对象头由以下三个部分组成：</p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4.3uw0o01uai80.webp" alt="Java对象头"></p>
<p>而其中跟锁有关的就是Mark Word这部分。</p>
<p>Mark Word记录了对象和锁的信息，在不同的锁状态下存储的内容不同，在32位JVM中的存储内容如下：</p>
<p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Mark-Word%E5%9B%BE%E7%A4%BA.12strgudcze8.webp" alt="Mark-Word图示"></p>
<p>Java中的锁状态分为4种：无锁、偏向锁、轻量级锁、重量级锁，在Mark Word中以锁标志位区分，其中无锁和偏向锁的锁标志位都是01，但是特意添加了一个1bit位来区分是否是偏向锁。</p>
<p>随着锁的竞争，锁会从偏向锁逐步升级到重量级锁，只能升级不能降级。</p>
<p>加锁过程：</p>
<ol>
<li>在无锁状态下，就是一个普通的Java对象，包含对象的HashCode、分代年龄。锁标志位01、是否偏向锁为0表示无锁；</li>
<li>当对对象进行了同步控制，比如用synchronized修饰了之后，在只有单线程A使用对象的情况下，会升级为偏向锁，这时Mark Word部分会记录当前线程A的id；</li>
<li>当线程A再次试图获得对象锁时，JVM发现该对象目前处于偏向锁状态下，并且线程id就是线程A的id，那么表示线程A已经获得了该对象的锁，可以执行同步代码；</li>
<li>当另一个线程B试图获得对象锁时，JVM检查该对象处于偏向锁状态下，并且线程id不是线程B的id，那么先让线程B通过CAS操作来竞争锁，如果竞争成功，则修改Mark Word中的线程id；如果竞争失败，说明当前有多个线程在竞争同一对象锁，那么对象锁由偏向锁升级为轻量级锁；</li>
<li>此时，JVM会在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储对象头中Mark Word的拷贝。具体做法是将对象头Mark Word拷贝到Lock Record中，再将对象头Mark Word中相应的指针更新为指向Lock Record，并将Lock Record里的owner指针指向对象的Mark Word。由于以上操作都是CAS操作，如果操作成功，代表线程抢到了同步锁，就把锁标志位改成00，执行同步代码；如果操作失败，表示抢锁失败，继续自旋不断尝试。而如果自旋次数过多，或者一个线程已经持有锁，一个线程在自旋，又有第三个线程来访时，轻量级锁升级为重量级锁；</li>
<li>重量级锁状态下，锁标志位改为10，除非线程主动释放对象锁，否则所有其他线程都必须阻塞等待。</li>
</ol>
<p>再来解决问题，锁是什么？锁住的又是什么？锁住的是对象，锁其实就是对象头里的Mark Word中的3bit位标识，线程通过公平或者非公平的方式来修改Mark Word中的线程id或者指针，而JVM通过锁状态和线程id或指针来判断当前线程是否具有执行同步代码的权限。</p>
<p>以synchronized为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步实例方法，锁实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步类方法，锁类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步代码块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁类对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">            <span class="comment">// 锁实例对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>().test();  <span class="comment">//调用test方法的线程必须能和这个new的SynchronizedTest对象的对象头的Mark Word中的线程id或指针对应</span></span><br><span class="line">        SynchronizedTest.test1();   <span class="comment">//调用test1方法的线程必须能和SynchronizedTest类对象的对象头的Mark Word中的线程id或指针对应</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：多线程概念详解</li>
        <li>Post author：Lisj</li>
        <li>Create time：2022-10-04 14:03:19</li>
        <li>
            Post link：https://lisj98.github.io/2022/10/04/多线程概念详解/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/">#多线程概念</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/09/24/Runnable%E5%92%8CCallable%E8%AF%A6%E8%A7%A3/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Runnable和Callable详解</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Lisj</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">1. 进程和线程的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E5%8F%AB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-text">2. 什么叫线程安全？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-text">3. 线程的几种状态？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Java%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8E%EF%BC%8C%E8%B0%83%E7%94%A8start-%E5%92%8Crun-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">4. Java创建多线程后，调用start()和run()方法的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%AF%B9Future%E5%92%8CFutureTask%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-text">5. 对Future和FutureTask的理解？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-text">6. 怎么解决共享资源竞争，实现线程安全？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-synchronized%EF%BC%8Cvolatile%E5%92%8CCAS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">7. synchronized，volatile和CAS的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E7%94%A8volatile%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E7%94%A8atomic%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-text">8. 用volatile修饰的变量和用atomic修饰的变量有什么不同？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E4%BD%BF%E7%94%A8volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-text">9. 使用volatile关键字的场景？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">10. synchronized和Lock的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E5%AF%B9wait-%EF%BC%8Cnotify-%EF%BC%8C%E5%92%8CnotifyAll-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-text">11. 对wait()，notify()，和notifyAll()的理解？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-wait-%E5%92%8Csleep-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">12. wait()和sleep()的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-%E5%AF%B9yield-%EF%BC%8Cjoin-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-text">13. 对yield()，join()的理解？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-Java%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="nav-text">14. Java中什么是竞态条件？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-text">15. 定时线程的使用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">16. 线程同步常见方法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">17. 如何停止一个线程？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-interrupt-%EF%BC%8Cinterrupted-%EF%BC%8CisInterrupted-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">18. interrupt()，interrupted()，isInterrupted()方法的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="nav-text">19. 线程池的优点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%89%EF%BC%9F"><span class="nav-text">20. 实现多线程有哪些方式（线程的创建方式）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F"><span class="nav-text">21. 什么是乐观锁和悲观锁？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-%E4%BB%80%E4%B9%88%E5%8F%AB%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-text">22. 什么叫死锁？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="nav-text">23. 产生死锁的四个必要条件？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="nav-text">24. 导致死锁的原因？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-%E5%AE%88%E6%8A%A4%EF%BC%88%E5%90%8E%E5%8F%B0%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">25. 守护（后台）线程和非守护线程的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="nav-text">26. 什么是多线程的上下文切换？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-%E6%80%8E%E4%B9%88%E5%94%A4%E9%86%92%E4%B8%80%E4%B8%AA%E9%98%BB%E5%A1%9E%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">27. 怎么唤醒一个阻塞的线程？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADexecute-%E5%92%8Csubmit-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">28. 线程池中execute()和submit()方法的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-%E5%A6%82%E6%9E%9C%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E6%97%B6%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%9F%E5%88%97%E5%B7%B2%E6%BB%A1%EF%BC%8C%E8%BF%99%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">29. 如果提交任务时，线程池队列已满，这时会发生什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-text">30. 线程池的类型？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="nav-text">31. 线程池的几个重要参数？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">32. 线程池的阻塞队列有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">33. 线程池的拒绝策略有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%94%81%E7%9A%84%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">锁到底是什么？锁的又是什么？</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>




<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
