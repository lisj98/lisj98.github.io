<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BlogOfLisj</title>
  
  
  <link href="https://lisj98.github.io/atom.xml" rel="self"/>
  
  <link href="https://lisj98.github.io/"/>
  <updated>2022-09-19T15:05:13.900Z</updated>
  <id>https://lisj98.github.io/</id>
  
  <author>
    <name>Lisj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Executors源码解析</title>
    <link href="https://lisj98.github.io/2022/09/19/Executors%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://lisj98.github.io/2022/09/19/Executors%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-09-19T15:04:37.000Z</published>
    <updated>2022-09-19T15:05:13.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h1><p>Executors，执行器，用来管理Thread对象，它是一个创建<code>Executor，ExecutorService，ScheduledExecutorService，ThreadFactory</code>或者<code>Callable</code>对象的工厂类，或者说工具类，通常用它来创建线程池。</p><h1 id="2-几个典型方法"><a href="#2-几个典型方法" class="headerlink" title="2. 几个典型方法"></a>2. 几个典型方法</h1><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><p>创建一个定长大小的线程池。</p><p>使用无界任务队列，如果有新任务被添加入队，但是所有线程都在忙，那么任务就在队列中一直等待直到有线程空闲下来为止。如果某个线程运行过程中由于某些原因停止了，那么会有其他的线程接管它的任务，但是这个停止的线程的资源不会被回收，也不会创建新线程来代替它，也就是说线程池一旦创建完毕，里面的线程将永远是那几个，只有明确调用了<code>shutdown()</code>方法线程池才会关闭，线程资源才会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//nThreads：池中线程的数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                              <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                              <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="comment">//nThreads：池中线程的数量</span></span><br><span class="line"><span class="comment">//和a的区别就是该方法指定了一个自定义的线程工厂类，按照自定义的方式创建池中的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                              <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                              <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                              threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return的<code>ThreadPoolExecutor</code>中<code>corePoolSize=maximumPoolSize=nThreads</code>，所以是一个定长的线程池，因为是无界队列，所以任务队列用<code>LinkedBlockingQueue</code>。</p><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><p>创建一个仅包含单线程的线程池。</p><p>也是使用无界任务队列，但是和<code>newFixedThreadPool()</code>的不同之处就在于，倘若这个线程由于某些原因停止了，会创建一个新的线程来代替它并接管其任务。本线程池保证任务有序执行，并且同一时间也只能执行一个任务。</p><p>和<code>newFixedThreadPool(1)</code>不同，该方法返回的线程池不可配置，因为它返回的是一个<code>FinalizableDelegatedExecutorService</code>对象，具体原因见<a href="#unconfigurableExecutorService">unconfigurableExecutorService方法</a>和<a href="#FinalizableDelegatedExecutorService">关联FinalizableDelegatedExecutorService内部类代码</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">       (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                               <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">       (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                               <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                               threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><p>创建一个线程可定时执行的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> corePoolSize, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="newSingleThreadScheduledExecutor"><a href="#newSingleThreadScheduledExecutor" class="headerlink" title="newSingleThreadScheduledExecutor"></a>newSingleThreadScheduledExecutor</h2><p>创建一个仅包含可定时执行的单线程的线程池。</p><p>任务使用无界队列，倘若这个线程由于某些原因停止了，会创建一个新的线程来代替它并接管其任务。本线程池保证任务有序执行，并且同一时间也只能执行一个任务。</p><p>和<code>newScheduledThreadPool(1)</code>不同，该方法返回的线程池不可配置，因为它返回的是一个<code>DelegatedScheduledExecutorService</code>对象，具体原因见</p><p><a href="#unconfigurableExecutorService">unconfigurableExecutorService方法</a>和<a href="#DelegatedScheduledExecutorService">关联DelegatedScheduledExecutorService内部类代码</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedScheduledExecutorService</span></span><br><span class="line">       (<span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedScheduledExecutorService</span></span><br><span class="line">       (<span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>, threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><p>创建一个长度可变的线程池。</p><p>线程池会按需创建线程，有新任务到来时，空闲的线程会被重新分配任务，如果没有线程空闲，则会创建一个新线程并添加到池中。空闲时间超过60s的线程将被停止并从池中移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                              <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                              <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                              <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                              <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                              threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于长度可变，所以<code>maximumPoolSize=Integer.MAX_VALUE</code>，60s是写死的，线程池中线程永远够用，任务入队立马消费，因此用<code>SynchronousQueue</code>。</p><h2 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h2><p>创建一个任务窃取线程池。</p><p><code>ForkJoinPool</code>，顾名思义，分叉（fork）合并（join），将大任务分成多个小任务，各自执行后再合并结果。普通线程池中，多个线程共用一个任务队列，而<code>ForkJoinPool</code>中每一个线程都有一个自己的任务队列，当线程发现自己的队列中没任务时，就会到别的队列里取任务，也就是“窃取”。执行自己队列的任务是先执行队首任务，窃取任务时是先取队尾任务。本线程池不保证任务的执行顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">       (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">        ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">        <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="comment">//parallelism：并行度，也就是同一个任务可以拆分给多少个线程来处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">       (parallelism,</span><br><span class="line">        ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">        <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unconfigurableExecutorService"><a href="#unconfigurableExecutorService" class="headerlink" title="unconfigurableExecutorService"></a>unconfigurableExecutorService</h2><p><a id="unconfigurableExecutorService"></a></p><p>返回一个限制<code>ExecutorService</code>对象，该方法对现有的<code>ExecutorService</code>进行包装，使其只暴露出<code>ExecutorService</code>接口本身的方法，不能调用不属于<code>ExecutorService</code>接口的方法，因此不能对其引用指向的对象，也就是线程池对象进行配置，如果我们需要创建不可配置的线程池，可以使用此方法。</p><p><a href="#DelegatedExecutorService">关联DelegatedExecutorService内部类代码</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">unconfigurableExecutorService</span><span class="params">(ExecutorService executor)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (executor == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedExecutorService</span>(executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//a</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">e</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">tpe</span> <span class="operator">=</span> (ThreadPoolExecutor) e;</span><br><span class="line">        tpe.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">        System.out.println(tpe.getCorePoolSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//b</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">e1</span> <span class="operator">=</span> Executors.unconfigurableExecutorService(e);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">tpe1</span> <span class="operator">=</span> (ThreadPoolExecutor) e1;</span><br><span class="line">        tpe1.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: java.util.concurrent.Executors$DelegatedExecutorService cannot be cast to java.util.concurrent.ThreadPoolExecutor</span><br><span class="line">at Solution.main(Solution.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure><p>上述代码中由于b处e1指向的<code>DelegatedExecutorService</code>对象只暴露了<code>ExecutorService</code>本身的方法，因此调用<code>ExecutorService</code>接口不具有的方法就会报错。</p><h2 id="unconfigurableScheduledExecutorService"><a href="#unconfigurableScheduledExecutorService" class="headerlink" title="unconfigurableScheduledExecutorService"></a>unconfigurableScheduledExecutorService</h2><p>返回一个限制<code>ScheduledExecutorService</code>对象，该方法对现有的<code>ScheduledExecutorService</code>进行包装，使其只暴露出<code>ScheduledExecutorService</code>接口及其父接口<code>ExecutorService</code>接口本身的方法，不能调用不属于这两个接口的方法，因此不能对其引用指向的对象，也就是线程池对象进行配置，如果我们需要创建不可配置的线程池，可以使用此方法。</p><p><a href="#DelegatedScheduledExecutorService">关联DelegatedScheduledExecutorService内部类代码</a>。</p><p>该方法主要是针对定时线程池的，而上面的<code>unconfigurableExecutorService</code>一般是针对非定时线程池的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">unconfigurableScheduledExecutorService</span><span class="params">(ScheduledExecutorService executor)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (executor == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedScheduledExecutorService</span>(executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="defaultThreadFactory"><a href="#defaultThreadFactory" class="headerlink" title="defaultThreadFactory"></a>defaultThreadFactory</h2><p>返回一个线程工厂。</p><p>通过该线程工厂创建的每个线程都在同一个线程组中，都是非守护线程，优先级设置为<code>Thread.NORM_PRIORITY</code>和线程组中允许的最大优先级中的较小者。线程名格式为<code>pool-N-thread-M</code>，N为工厂的序列号，M为线程的序列号。</p><p><a href="#DefaultThreadFactory">关联DefaultThreadFactory内部类解析</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title function_">defaultThreadFactory</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultThreadFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="privilegedThreadFactory"><a href="#privilegedThreadFactory" class="headerlink" title="privilegedThreadFactory"></a>privilegedThreadFactory</h2><p>返回一个线程工厂，通过该工厂创建的线程具有和方法调用线程同样的权限，在<code>defaultThreadFactory()</code>已有设置的基础上还具有相同的<code>AccessControlContext</code>和<code>contextClassLoader</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title function_">privilegedThreadFactory</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PrivilegedThreadFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="callable"><a href="#callable" class="headerlink" title="callable"></a>callable</h2><p><code>Runnable</code>任务的适配器，将<code>Runnable</code>型任务封装到<code>Callable</code>型任务中。</p><p><a href="#RunnableAdapter">关联RunnableAdapter内部类解析</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//只指定task，result为null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title function_">callable</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;Object&gt;(task, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="comment">//既指定task也指定result</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">callable</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title function_">callable</span><span class="params">(<span class="keyword">final</span> PrivilegedAction&lt;?&gt; action)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Object&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> action.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="comment">//d</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title function_">callable</span><span class="params">(<span class="keyword">final</span> PrivilegedExceptionAction&lt;?&gt; action)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Object&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="keyword">return</span> action.run(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="x2F-x2F-TODO-privilegedCallable、privilegedCallableUsingCurrentClassLoader"><a href="#x2F-x2F-TODO-privilegedCallable、privilegedCallableUsingCurrentClassLoader" class="headerlink" title="&#x2F;&#x2F;TODO privilegedCallable、privilegedCallableUsingCurrentClassLoader"></a>&#x2F;&#x2F;TODO privilegedCallable、privilegedCallableUsingCurrentClassLoader</h2><h1 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3. 内部类"></a>3. 内部类</h1><h2 id="RunnableAdapter"><a href="#RunnableAdapter" class="headerlink" title="RunnableAdapter"></a>RunnableAdapter</h2><p>作用其实很简单，丢进来一个<code>Runnable</code>任务，进行适当封装后返回一个<code>Callable</code>任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">final</span> Runnable task;</span><br><span class="line"><span class="keyword">final</span> T result;</span><br><span class="line">RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line"><span class="built_in">this</span>.task = task;</span><br><span class="line"><span class="built_in">this</span>.result = result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">task.run();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="x2F-x2F-TODO-PrivilegedCallable、PrivilegedCallableUsingCurrentClassLoader"><a href="#x2F-x2F-TODO-PrivilegedCallable、PrivilegedCallableUsingCurrentClassLoader" class="headerlink" title="&#x2F;&#x2F;TODO PrivilegedCallable、PrivilegedCallableUsingCurrentClassLoader"></a>&#x2F;&#x2F;TODO PrivilegedCallable、PrivilegedCallableUsingCurrentClassLoader</h2><h2 id="DefaultThreadFactory"><a href="#DefaultThreadFactory" class="headerlink" title="DefaultThreadFactory"></a>DefaultThreadFactory</h2><p><a id="DefaultThreadFactory"></a></p><p>默认的线程工厂。</p><p>创建的线程仅设置线程名、线程组、是否守护线程以及优先级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">DefaultThreadFactory() &#123;</span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">        Thread.currentThread().getThreadGroup();</span><br><span class="line">namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">             poolNumber.getAndIncrement() +</span><br><span class="line">             <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                      namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                      <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">t.setDaemon(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PrivilegedThreadFactory"><a href="#PrivilegedThreadFactory" class="headerlink" title="PrivilegedThreadFactory"></a>PrivilegedThreadFactory</h2><p>在<code>DefaultThreadFactory</code>的基础上还会设置<code>AccessControlContext</code>和<code>ClassLoader</code>，这两个参数值和调用本方法的线程一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrivilegedThreadFactory</span> <span class="keyword">extends</span> <span class="title class_">DefaultThreadFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader ccl;</span><br><span class="line"></span><br><span class="line">PrivilegedThreadFactory() &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Calls to getContextClassLoader from this class</span></span><br><span class="line"><span class="comment">// never trigger a security check, but we check</span></span><br><span class="line"><span class="comment">// whether our callers have this permission anyways.</span></span><br><span class="line">sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fail fast</span></span><br><span class="line">sm.checkPermission(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;setContextClassLoader&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.acc = AccessController.getContext();</span><br><span class="line"><span class="built_in">this</span>.ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.newThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">Thread.currentThread().setContextClassLoader(ccl);</span><br><span class="line">r.run();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, acc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DelegatedExecutorService"><a href="#DelegatedExecutorService" class="headerlink" title="DelegatedExecutorService"></a>DelegatedExecutorService</h2><p><a id="DelegatedExecutorService"></a></p><p>该类对现有的<code>ExecutorService</code>进行包装，使其只暴露出<code>ExecutorService</code>接口本身的方法，不能调用不属于<code>ExecutorService</code>接口的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e;</span><br><span class="line">DelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line">e = executor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">e.execute(command);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">e.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.shutdownNow();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.isShutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.isTerminated();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="keyword">return</span> e.awaitTermination(timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line"><span class="keyword">return</span> e.submit(task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.submit(task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.submit(task, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="keyword">return</span> e.invokeAll(tasks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                                     <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="keyword">return</span> e.invokeAll(tasks, timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line"><span class="keyword">return</span> e.invokeAny(tasks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                       <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line"><span class="keyword">return</span> e.invokeAny(tasks, timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FinalizableDelegatedExecutorService"><a href="#FinalizableDelegatedExecutorService" class="headerlink" title="FinalizableDelegatedExecutorService"></a>FinalizableDelegatedExecutorService</h2><p><a id="FinalizableDelegatedExecutorService"></a></p><p>本类相较于父类<code>DelegatedExecutorService</code>增加了一个<code>finalize()</code>方法，而JVM在进行垃圾回收的时候会调用<code>finalize()</code>方法，换言之，<code>FinalizableDelegatedExecutorService</code>的实例即使不手动调用<code>shutdown()</code>方法关闭线程池，JVM也会完成此任务，但是要注意，JVM不保证<code>finalize()</code>方法一定被调用，因此我们不应该依赖于它，而应手动调用<code>shutdown()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">DelegatedExecutorService</span> &#123;</span><br><span class="line">FinalizableDelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line"><span class="built_in">super</span>(executor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DelegatedScheduledExecutorService"><a href="#DelegatedScheduledExecutorService" class="headerlink" title="DelegatedScheduledExecutorService"></a>DelegatedScheduledExecutorService</h2><p><a id="DelegatedScheduledExecutorService"></a></p><p>本类相较于父类<code>DelegatedExecutorService</code>增加了定时相关的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DelegatedScheduledExecutorService</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">DelegatedExecutorService</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">ScheduledExecutorService</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService e;</span><br><span class="line">DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class="line"><span class="built_in">super</span>(executor);</span><br><span class="line">e = executor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="type">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line"><span class="keyword">return</span> e.schedule(command, delay, unit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="title function_">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="type">long</span> delay, TimeUnit unit)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.schedule(callable, delay, unit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> period, TimeUnit unit) &#123;</span><br><span class="line"><span class="keyword">return</span> e.scheduleAtFixedRate(command, initialDelay, period, unit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line"><span class="keyword">return</span> e.scheduleWithFixedDelay(command, initialDelay, delay, unit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-补充"><a href="#4-补充" class="headerlink" title="4. 补充"></a>4. 补充</h1><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ol><li>newFixedThreadPool</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//定长线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">e</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        ArrayList&lt;Future&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            list.add(e.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future f : list) &#123;</span><br><span class="line">            System.out.println(f.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机的</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="2"><li>newSingleThreadExecutor</li></ol><p>类比newFixedThreadPool</p><ol start="3"><li>newScheduledThreadPool</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//定时执行线程池</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">e</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">        e.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">3000</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Mon Sep <span class="number">19</span> <span class="number">20</span>:<span class="number">57</span>:<span class="number">43</span> CST <span class="number">2022</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Mon Sep <span class="number">19</span> <span class="number">20</span>:<span class="number">57</span>:<span class="number">48</span> CST <span class="number">2022</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Mon Sep <span class="number">19</span> <span class="number">20</span>:<span class="number">57</span>:<span class="number">53</span> CST <span class="number">2022</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Mon Sep <span class="number">19</span> <span class="number">20</span>:<span class="number">57</span>:<span class="number">58</span> CST <span class="number">2022</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Mon Sep <span class="number">19</span> <span class="number">20</span>:<span class="number">58</span>:<span class="number">03</span> CST <span class="number">2022</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Mon Sep <span class="number">19</span> <span class="number">20</span>:<span class="number">58</span>:08 CST <span class="number">2022</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Mon Sep <span class="number">19</span> <span class="number">20</span>:<span class="number">58</span>:<span class="number">13</span> CST <span class="number">2022</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="4"><li>newSingleThreadScheduledExecutor</li></ol><p>类比newScheduledThreadPool</p><ol start="5"><li>newCachedThreadPool</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//长度可变线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">e</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            e.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span></span><br></pre></td></tr></table></figure><p>而加上一个sleep后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//长度可变线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">e</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            e.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="6"><li>newWorkStealingPool</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//任务窃取线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">e</span> <span class="operator">=</span> Executors.newWorkStealingPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        LinkedBlockingDeque&lt;Future&lt;String&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//CPU核数</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Runtime.getRuntime().availableProcessors()+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            Future&lt;String&gt; submit = e.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">            &#125;);</span><br><span class="line">            queue.offer(submit);</span><br><span class="line">        &#125;</span><br><span class="line">        e.shutdown();</span><br><span class="line"></span><br><span class="line">        queue.forEach(f-&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-前置知识&quot;&gt;&lt;a href=&quot;#1-前置知识&quot; class=&quot;headerlink&quot; title=&quot;1. 前置知识&quot;&gt;&lt;/a&gt;1. 前置知识&lt;/h1&gt;&lt;p&gt;Executors，执行器，用来管理Thread对象，它是一个创建&lt;code&gt;Executor，Exec</summary>
      
    
    
    
    <category term="多线程" scheme="https://lisj98.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Executors" scheme="https://lisj98.github.io/tags/Executors/"/>
    
  </entry>
  
  <entry>
    <title>Timer定时器类源码解析</title>
    <link href="https://lisj98.github.io/2022/09/15/Timer%E5%AE%9A%E6%97%B6%E5%99%A8%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://lisj98.github.io/2022/09/15/Timer%E5%AE%9A%E6%97%B6%E5%99%A8%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-09-15T13:50:58.000Z</published>
    <updated>2022-09-15T14:03:04.104Z</updated>
    
    <content type="html"><![CDATA[<p>Timer定时器流程总览：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Timer%E5%AE%9A%E6%97%B6%E5%99%A8/Timer%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.2j8ktwirkia0.webp" alt="Timer定时器流程图"></p><h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>定时器类。</p><p>线程安全，线程安全的原因就是类中凡涉及到任务队列的操作就对队列加锁，凡涉及到具体任务的操作就对具体任务加锁(synchronized)。</p><p>可定时单次执行，也可定时重复执行。</p><p>一个定时器(Timer)对应一个任务队列(TaskQueue)以及一个任务线程(TimerThread)。</p><p>一个任务队列(TaskQueue)中可包含多个任务(TimerTask)。</p><p>生产者-消费者模式。</p><h2 id="1-源码解析"><a href="#1-源码解析" class="headerlink" title="1. 源码解析"></a>1. 源码解析</h2><h3 id="1-1-属性"><a href="#1-1-属性" class="headerlink" title="1.1. 属性"></a>1.1. 属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行任务的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TimerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerThread</span>(queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程编号，原子类，线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextSerialNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//垃圾回收线程在回收垃圾时会调用此方法回收线程资源，是一种默认机制，防止程序开发人员忘记调用cancel()方法而使得线程资源无法释放</span></span><br><span class="line"><span class="comment">//私有方法，由垃圾回收器调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">threadReaper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">thread.newTasksMayBeScheduled = <span class="literal">false</span>;</span><br><span class="line">queue.notify(); <span class="comment">// In case queue is empty.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-方法"><a href="#1-2-方法" class="headerlink" title="1.2. 方法"></a>1.2. 方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>构造方法中会初始化TimerThread对象，并启动线程，同时TimerThread对象的初始化又会引起TaskQueue的初始化</p><p>这样就初步创建了一个TaskQueue(其本质为长度为128的TimerTask[]数组)，并且启动了TimerThread线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个定时器，任务执行线程不能作为守护线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(<span class="string">&quot;Timer-&quot;</span> + serialNumber());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建一个定时器，并指定任务执行线程的名称，任务执行线程不能作为守护线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">(String name)</span> &#123;</span><br><span class="line">thread.setName(name);</span><br><span class="line">thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建一个定时器，任务执行线程能作为守护线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">(<span class="type">boolean</span> isDaemon)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(<span class="string">&quot;Timer-&quot;</span> + serialNumber(), isDaemon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.创建一个定时器，并指定任务执行线程的名称，任务执行线程能作为守护线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">(String name, <span class="type">boolean</span> isDaemon)</span> &#123;</span><br><span class="line">thread.setName(name);</span><br><span class="line">thread.setDaemon(isDaemon);</span><br><span class="line">thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="schedule方法"><a href="#schedule方法" class="headerlink" title="schedule方法"></a>schedule方法</h4><p>下列方法为“固定延迟(fixed-delay)”类任务，即重复任务每次执行的间隔时间都是固定的，不管任务是否被推迟或提前，反正就隔那么长时间。它不关心执行时间，只关心是否和前一个任务间隔了指定时间。适用于短期需要定时任务的场景，或者不关注绝对时间的场景。</p><p>举个例子，A(10:00)，B(11:00)，C(12:00)，D(13:00)，每个任务完成需要10min，间隔时间1h执行，而A由于某些原因到12:30才执行完，那么B会推迟到13:30执行，C会推迟到14:30执行，D会推迟到15:30执行，也就是说它更关注间隔时间，真正执行时间是上一次任务结束时间+时间间隔。</p><p>a. 指定任务与执行时间，用于单次执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, Date time)</span> &#123;</span><br><span class="line">sched(task, time.getTime(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. 指定任务、首次执行时间、重复执行间隔时间，用于间隔一段时间重复执行任务。若period为0则是单次任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, Date firstTime, <span class="type">long</span> period)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Non-positive period.&quot;</span>);</span><br><span class="line">sched(task, firstTime.getTime(), -period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. 从当前时间开始延迟一段时间后执行，用于单次执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, <span class="type">long</span> delay)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Negative delay.&quot;</span>);</span><br><span class="line">sched(task, System.currentTimeMillis()+delay, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d. 从当前时间开始延迟一段时间后，按间隔时间重复执行。若period为0则是单次任务，和c情况一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, <span class="type">long</span> delay, <span class="type">long</span> period)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Negative delay.&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Non-positive period.&quot;</span>);</span><br><span class="line">sched(task, System.currentTimeMillis()+delay, -period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="scheduleAtFixedRate方法"><a href="#scheduleAtFixedRate方法" class="headerlink" title="scheduleAtFixedRate方法"></a>scheduleAtFixedRate方法</h4><p>下列方法为“固定速率(fixed-rate)”类任务，即若某个任务延迟了，那么后面的任务将迅速赶上，也就是连续执行，在追上任务自己的指定执行时间之前不会再有间隔。它不关心间隔时间，只关心自己的执行时间。适用于长期需要定时任务的场景，或者关注绝对时间的场景。</p><p>举个例子，A(10:00)，B(11:00)，C(12:00)，D(13:00)，每个任务完成需要10min，间隔时间1h执行，而A由于某些原因到12:30才执行完，那么B、C将立即执行，然后再等到13:00执行D，也就是说它更关注执行时间，严格按照预期时间来。</p><p>a. 指定任务、首次执行时间、重复执行间隔时间，用于间隔一段时间重复执行任务。若period为0则是单次任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleAtFixedRate</span><span class="params">(TimerTask task, Date firstTime,</span></span><br><span class="line"><span class="params">                                <span class="type">long</span> period)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Non-positive period.&quot;</span>);</span><br><span class="line">sched(task, firstTime.getTime(), period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. 从当前时间开始延迟一段时间后，按间隔时间重复执行。若period为0则是单次任务，和a情况一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleAtFixedRate</span><span class="params">(TimerTask task, <span class="type">long</span> delay, <span class="type">long</span> period)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Negative delay.&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Non-positive period.&quot;</span>);</span><br><span class="line">sched(task, System.currentTimeMillis()+delay, period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sched方法"><a href="#sched方法" class="headerlink" title="sched方法"></a>sched方法<a id="sched"></a></h4><p>设定好任务各项参数后，将其添加到任务队列中，并通知线程来消费任务</p><p>注意，<code>schedule()</code>方法传到本方法中的period是个负数，<code>scheduleAtFixedRate()</code>方法传到本方法中的period是个正数，为什么要这样处理呢，要结合TimerThread的<a href="#mainLoop">mainLoop方法</a>来分析：</p><p>①<code>schedule()</code>方法传进来的period是个负数，那么<code>TimerThread.mainLoop()</code>方法中<code>task.period&lt;0 ? currentTime - task.period : executionTime + task.period);</code>就会执行<code>currentTime - task.period</code>部分，也就是“当前时间+间隔时间”，这和<code>schedule()</code>方法的理念一致；</p><p>②<code>scheduleAtFixedRate()</code>方法传进来的period是个正数，那么<code>TimerThread.mainLoop()</code>方法中<code>task.period&lt;0 ? currentTime - task.period : executionTime + task.period);</code>就会执行<code>executionTime + task.period</code>部分，也就是“预期执行时间+间隔时间”，这和scheduleAtFixedRate()方法的理念一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sched</span><span class="params">(TimerTask task, <span class="type">long</span> time, <span class="type">long</span> period)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal execution time.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</span><br><span class="line">period &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先锁队列再锁具体任务</span></span><br><span class="line"><span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Timer already cancelled.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">            <span class="comment">//VIRGIN：初始任务，还没设定执行时间</span></span><br><span class="line"><span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">    <span class="string">&quot;Task already scheduled or cancelled&quot;</span>);</span><br><span class="line"><span class="comment">//设置任务的执行时间，间隔时间，同时将任务的状态设置为SCHEDULED，表示已就绪</span></span><br><span class="line">            task.nextExecutionTime = time;</span><br><span class="line">task.period = period;</span><br><span class="line">task.state = TimerTask.SCHEDULED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将任务添加到任务队列中</span></span><br><span class="line">queue.add(task);</span><br><span class="line"><span class="keyword">if</span> (queue.getMin() == task)</span><br><span class="line">            <span class="comment">//对应着TimerThread.mainLoop()的queue.wait()，即这边添加任务成功，那边线程就可以开始消费任务了</span></span><br><span class="line">queue.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cancel方法"><a href="#cancel方法" class="headerlink" title="cancel方法"></a>cancel方法</h4><p>终止本定时器，并移除任务队列中的所有任务，正在执行的任务不受影响。本方法可以被多次调用，多次调用没影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">thread.newTasksMayBeScheduled = <span class="literal">false</span>;</span><br><span class="line">queue.clear();</span><br><span class="line">        <span class="comment">//这里调用notify()方法的作用是，当队列已经为空的时候，TimerThread.mainLoop()那里还在wait，这里清空队列之后newTasksMayBeScheduled为false，那边的循环就进去不了，然后直接break了，线程资源也得以释放</span></span><br><span class="line">queue.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="purge方法"><a href="#purge方法" class="headerlink" title="purge方法"></a>purge方法</h4><p>移除任务队列中所有已取消的任务并返回已取消任务总数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">purge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (queue.get(i).state == TimerTask.CANCELLED) &#123;</span><br><span class="line">queue.quickRemove(i);</span><br><span class="line">result++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//维护二叉堆</span></span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">queue.heapify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="serialNumber方法"><a href="#serialNumber方法" class="headerlink" title="serialNumber方法"></a>serialNumber方法</h4><p>计算线程编号值。</p><p>私有方法，由构造函数调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">serialNumber</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nextSerialNumber.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TimerThread"><a href="#TimerThread" class="headerlink" title="TimerThread"></a>TimerThread</h1><p>定时器的任务执行线程类，执行任务的载体。</p><h2 id="1-源码解析-1"><a href="#1-源码解析-1" class="headerlink" title="1. 源码解析"></a>1. 源码解析</h2><h3 id="1-1-属性-1"><a href="#1-1-属性-1" class="headerlink" title="1.1. 属性"></a>1.1. 属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为false表示没有对定时器Timer的引用了，这时就可以终止定时器了</span></span><br><span class="line"><span class="comment">//为true并且任务队列中已无任务时，该标志位会被置为false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">newTasksMayBeScheduled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务执行线程绑定的任务队列</span></span><br><span class="line"><span class="keyword">private</span> TaskQueue queue;</span><br></pre></td></tr></table></figure><h3 id="1-2-方法-1"><a href="#1-2-方法-1" class="headerlink" title="1.2. 方法"></a>1.2. 方法</h3><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅绑定任务队列</span></span><br><span class="line">TimerThread(TaskQueue queue) &#123;</span><br><span class="line"><span class="built_in">this</span>.queue = queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和普通线程一样，调用start()方法后会进到这个run()方法里来，Timer的构造函数里会调用start()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mainLoop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Someone killed this Thread, behave as if Timer cancelled</span></span><br><span class="line"><span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">newTasksMayBeScheduled = <span class="literal">false</span>;</span><br><span class="line">queue.clear();  <span class="comment">// Eliminate obsolete references</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mainLoop方法"><a href="#mainLoop方法" class="headerlink" title="mainLoop方法"></a>mainLoop方法<a id="mainLoop"></a></h4><p>私有方法，由run()方法调用。</p><p>真正的定时器循环实现逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mainLoop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//死循环，除非主动退出，否则无法退出</span></span><br><span class="line">    <span class="comment">//这里就是“定时”的核心所在，只有一个线程在不断操作任务队列</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimerTask task;</span><br><span class="line"><span class="type">boolean</span> taskFired;</span><br><span class="line"><span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line"><span class="comment">//等待任务队列非空</span></span><br><span class="line"><span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span><br><span class="line">                    <span class="comment">//任务队列中没有任务，则等待Timer.sched()方法添加任务，若添加成功，则会调用queue.notify()</span></span><br><span class="line">queue.wait();</span><br><span class="line"><span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> currentTime, executionTime;</span><br><span class="line">                <span class="comment">//获取队列中第一个任务</span></span><br><span class="line">task = queue.getMin();</span><br><span class="line"><span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line"><span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class="line">queue.removeMin();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">currentTime = System.currentTimeMillis();<span class="comment">//当前时间</span></span><br><span class="line">executionTime = task.nextExecutionTime;<span class="comment">//这个时候任务还没有开始执行，所以这个executionTime指的是任务即将开始执行的时间，或者说预期时间，不要被next迷惑了</span></span><br><span class="line">                    <span class="comment">//任务预期执行时间在当前时间之前，即前面有个任务超时了，导致后面的任务无法在指定时间执行</span></span><br><span class="line"><span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class="line"><span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123;<span class="comment">//单次任务</span></span><br><span class="line">queue.removeMin();</span><br><span class="line">task.state = TimerTask.EXECUTED;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//重复任务，这里的rescheduleMin()方法会重新计算nextExecutionTime(下一次执行时间)，然后进行fixDown操作，这个时候做的事情就是计算当前任务下一次应该什么时候执行，在堆中应该处于什么位置，也就是堆化操作。因为上一次循环已经堆化好了，拿到的task一定是应该最先执行的，所以不用关心当前任务的顺序是否正确</span></span><br><span class="line">queue.rescheduleMin(<span class="comment">//这里的+-逻辑可见Timer.sched()方法处的分析</span></span><br><span class="line">    task.period&lt;<span class="number">0</span> ? currentTime   - task.period</span><br><span class="line">    : executionTime + task.period);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">//任务预期执行时间在当前时间之后，也就是正常情况，等时间到重新进入循环执行第一个任务即可，因为进了本if语句就绝对不会进下一个if语句</span></span><br><span class="line"><span class="keyword">if</span> (!taskFired)</span><br><span class="line">queue.wait(executionTime - currentTime);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//任务预期执行时间在当前时间之前，立即执行任务</span></span><br><span class="line">            <span class="comment">//进入这个if语句之前，当前任务的nextExecutionTime，也就是真正的下一次执行时间已经通过queue.rescheduleMin()方法计算好了，而且堆也通过该方法维护好了，堆中的该任务已经代表下一次的任务了，所以这个时候应该执行task，而不是queue[1]，task可能已经不在queue[1]这个位置了</span></span><br><span class="line"><span class="keyword">if</span> (taskFired)</span><br><span class="line">task.run();</span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本方法的逻辑是，你那边通过sched()方法add了一大堆task到queue里，而add方法会fixUp维护堆，也就是堆的根节点一定是最小的，至于兄弟节点的顺序我不关心，我这里会处理；我这边线程开始执行，先拿到第一个task，也就是根节点，一定是最小的，一开始还没到执行时间，也就是会进入<code>if (!taskFired)</code>这个判断语句，然后等待一段时间，时间到继续执行，而进入了<code>if (!taskFired)</code>就不会进<code>if (taskFired)</code>，所以重新进入while循环，而这时<code>executionTime&lt;=currentTime</code>，所以<code>queue.rescheduleMin()</code>计算第一个任务的下一次执行时间，并fixDown重构堆结构，然后执行第一个task；好，执行完，再一次进入循环，这个时候的堆已经经过上一次循环的<code>queue.rescheduleMin()</code>重构好了，也就是第一个任务一定是时间最近的那个，所以再次循环上述操作，就这样实现定时循环。</p><h1 id="TaskQueue"><a href="#TaskQueue" class="headerlink" title="TaskQueue"></a>TaskQueue</h1><p>定时器的任务队列，是一个优先级队列，按执行时间(nextExecutionTime)排序。</p><p>队列本质是一个二叉堆(最小堆)，而二叉堆或者树只是一个逻辑结构，在Java中要么用数组实现，要么用链表实现，这里的TaskQueue是用数组实现的。</p><p>最小堆的特点：①完全二叉树；②父节点的值小于子节点的值。</p><p>由于最小堆是完全二叉树的特性，每个节点的下标值一定是连续的，因此为了方便，根节点从1开始计数，从0开始也不利于取模，所以任务队列中的任务也是从queue[1]开始的，queue[0]不存值。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Timer%E5%AE%9A%E6%97%B6%E5%99%A8/%E6%9C%80%E5%B0%8F%E5%A0%86%E7%A4%BA%E4%BE%8B.66i29sutfh40.webp" alt="最小堆示例"></p><h2 id="1-源码解析-2"><a href="#1-源码解析-2" class="headerlink" title="1. 源码解析"></a>1. 源码解析</h2><h3 id="1-1-属性-2"><a href="#1-1-属性-2" class="headerlink" title="1.1. 属性"></a>1.1. 属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">private</span> TimerTask[] queue = <span class="keyword">new</span> <span class="title class_">TimerTask</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="1-2-方法-2"><a href="#1-2-方法-2" class="headerlink" title="1.2. 方法"></a>1.2. 方法</h3><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><p>无构造方法，调用默认构造方法并创建一个长度为128的TimerTask[]数组。</p><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>增加一个任务到任务队列中。</p><p>默认方法，由<code>Timer.sched()</code>方法调用，每调用一个<code>schedule()</code>或<code>scheduleAtFixedRate()</code>方法就有一个任务添加到任务队列中。</p><p>堆添加元素，①只能尾插，②然后逐层向上父子节点比较；</p><p>本方法是步骤①，<code>fixUp()</code>方法是步骤②。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(TimerTask task)</span> &#123;</span><br><span class="line"><span class="comment">//队列中实际长度超过数组长度则两倍扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size + <span class="number">1</span> == queue.length)</span><br><span class="line">queue = Arrays.copyOf(queue, <span class="number">2</span>*queue.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务从queue[1]开始，size不断++</span></span><br><span class="line">queue[++size] = task;</span><br><span class="line">fixUp(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fixUp方法"><a href="#fixUp方法" class="headerlink" title="fixUp方法"></a>fixUp方法</h4><p>用于在添加任务到TimerTask数组中后，维护数组中任务的顺序(上浮)。</p><p>私有方法，由<code>TaskQueue.add()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixUp</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">//从数组最末端，也就是堆的最后一个叶子节点开始</span></span><br><span class="line"><span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//右移两位即除2，也就是j是k的父节点</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> k &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//父节点nextExecutionTime&gt;子节点nextExecutionTime则交换</span></span><br><span class="line">        <span class="comment">//因为最小堆并不需要维护整棵树的顺序，所以只关心本节点所在子树，逐层父子节点比较就可以了</span></span><br><span class="line"><span class="type">TimerTask</span> <span class="variable">tmp</span> <span class="operator">=</span> queue[j];</span><br><span class="line">queue[j] = queue[k];</span><br><span class="line">queue[k] = tmp;</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="removeMin方法"><a href="#removeMin方法" class="headerlink" title="removeMin方法"></a>removeMin方法</h4><p>移除任务队列中第一个任务。</p><p>默认方法，由<code>TimerThread.mainLoop()</code>调用。</p><p>堆删除元素，①只能删除根节点，删除根节点后，将最后一个叶子节点作为根节点，②然后跟子结点中较小的值进行比较(因为是最小堆)，就这样逐层向下比较；</p><p>本方法是步骤①，<code>fixDown()</code>方法是步骤②。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把任务队列中最后一个任务赋值给queue[1]，然后把最后一个任务置空，size--，并通过fixDown()方法维护堆</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeMin</span><span class="params">()</span> &#123;</span><br><span class="line">queue[<span class="number">1</span>] = queue[size];</span><br><span class="line">queue[size--] = <span class="literal">null</span>;</span><br><span class="line">fixDown(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="quickRemove方法"><a href="#quickRemove方法" class="headerlink" title="quickRemove方法"></a>quickRemove方法</h4><p>将指定位置的元素置空，即移除指定位置的任务。</p><p>默认方法，由<code>Timer.purge()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">quickRemove</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">assert</span> i &lt;= size;</span><br><span class="line"></span><br><span class="line">queue[i] = queue[size];</span><br><span class="line">queue[size--] = <span class="literal">null</span>;  <span class="comment">// Drop extra ref to prevent memory leak</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rescheduleMin方法"><a href="#rescheduleMin方法" class="headerlink" title="rescheduleMin方法"></a>rescheduleMin方法</h4><p>重新计算第一个任务的nextExecutionTime，并在有必要的情况下对数组重新最小堆化。</p><p>默认方法，由<code>TimerThread.mainLoop()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">rescheduleMin</span><span class="params">(<span class="type">long</span> newTime)</span> &#123;</span><br><span class="line">queue[<span class="number">1</span>].nextExecutionTime = newTime;</span><br><span class="line">fixDown(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fixDown方法"><a href="#fixDown方法" class="headerlink" title="fixDown方法"></a>fixDown方法</h4><p>用于在删除任务后，维护数组中任务的顺序(下沉)。</p><p>私有方法，由<code>TaskQueue.removeMin()</code>、<code>TaskQueue.rescheduleMin()</code>和<code>TaskQueue.heapify()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixDown</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">while</span> ((j = k &lt;&lt; <span class="number">1</span>) &lt;= size &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//找子节点中的较小值</span></span><br><span class="line"><span class="keyword">if</span> (j &lt; size &amp;&amp;</span><br><span class="line">        queue[j].nextExecutionTime &gt; queue[j+<span class="number">1</span>].nextExecutionTime)</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span> (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//交换父子节点</span></span><br><span class="line"><span class="type">TimerTask</span> <span class="variable">tmp</span> <span class="operator">=</span> queue[j];</span><br><span class="line">queue[j] = queue[k];</span><br><span class="line">queue[k] = tmp;</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="heapify方法"><a href="#heapify方法" class="headerlink" title="heapify方法"></a>heapify方法</h4><p>在删除CANCELED的任务后对数组重新最小堆化。</p><p>默认方法，由<code>Timer.purge()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">fixDown(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>返回任务队列中具体某个任务。</p><p>默认方法，由<code>Timer.purge()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TimerTask <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> queue[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getMin方法"><a href="#getMin方法" class="headerlink" title="getMin方法"></a>getMin方法</h4><p>返回任务队列中第一个任务。</p><p>默认方法，由<code>TimerThread.mainLoop()</code>和<code>Timer.sched()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TimerTask <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> queue[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="clear方法"><a href="#clear方法" class="headerlink" title="clear方法"></a>clear方法</h4><p>清空任务队列。</p><p>默认方法，由<code>Timer.cancel()</code>方法或<code>TimerThread.run()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// Null out task references to prevent memory leak</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=size; i++)</span><br><span class="line">queue[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isEmpty方法"><a href="#isEmpty方法" class="headerlink" title="isEmpty方法"></a>isEmpty方法</h4><p>判断任务队列中任务数量是否为空。</p><p>由<code>TimerThread.mainLoop()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h4><p>返回任务队列中的任务数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h1><p>定时器任务类，表示一个具体的任务。</p><p>是个抽象类，实现了Runnable接口。</p><h2 id="1-源码解析-3"><a href="#1-源码解析-3" class="headerlink" title="1. 源码解析"></a>1. 源码解析</h2><h3 id="1-1-属性-3"><a href="#1-1-属性-3" class="headerlink" title="1.1. 属性"></a>1.1. 属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来给定时任务TimerTask对象加锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时任务的状态</span></span><br><span class="line"><span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> VIRGIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始状态，还没有设定执行时间</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VIRGIN</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已设定执行时间，等待执行</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SCHEDULED</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正在执行中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXECUTED</span>    <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已取消</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>   <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重复任务的周期(以毫秒为单位)</span></span><br><span class="line"><span class="type">long</span> <span class="variable">period</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务下一次执行的时间(System.currentTimeMillis格式)</span></span><br><span class="line"><span class="type">long</span> nextExecutionTime;</span><br></pre></td></tr></table></figure><h3 id="1-2-方法-3"><a href="#1-2-方法-3" class="headerlink" title="1.2. 方法"></a>1.2. 方法</h3><h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造，什么都不干</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">TimerTask</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run方法-1"><a href="#run方法-1" class="headerlink" title="run方法"></a>run方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象方法，什么都不干</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h4 id="cancel方法-1"><a href="#cancel方法-1" class="headerlink" title="cancel方法"></a>cancel方法</h4><p>取消任务。</p><ul><li>如果是仅执行一次的任务并且还没有开始执行，或者连定时执行时间都没有设定，直接取消；</li><li>如果是重复执行的任务，在调用本方法后任务将不再执行；</li><li>如果任务正在执行，则等其执行完后便不再执行。</li></ul><p>本方法可以执行多次，后续执行不会影响第一次执行的效果。</p><p>返回true的情况：①仅执行一次的任务并设定了定时执行时间，只要它还没开始执行就返回true；②重复执行的任务调用本方法后都返回true。</p><p>返回false的情况：①仅执行一次的任务已经开始执行了(即在执行的过程中调用此方法)；②任务还没有设定执行时间；③任务已经被取消了。</p><p>一句话总结：已初始化还没开始执行的(SCHEDULED)就返回true；未初始化(VIRGIN)、已经开始执行(EXECUTED)、已取消的(CANCELLED)就返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> (state == SCHEDULED);</span><br><span class="line">state = CANCELLED;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="scheduledExecutionTime方法"><a href="#scheduledExecutionTime方法" class="headerlink" title="scheduledExecutionTime方法"></a>scheduledExecutionTime方法</h4><p>返回任务最近一次执行的时间(<code>Date.getTime()</code>格式)。</p><p>如果任务正在执行，则返回其开始执行的时间；</p><p>如果任务未开始执行，则返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">scheduledExecutionTime</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line"><span class="keyword">return</span> (period &lt; <span class="number">0</span> ? nextExecutionTime + period</span><br><span class="line">        : nextExecutionTime - period);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTimer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">MyTimerTask</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTimerTask</span>(<span class="string">&quot;Task&quot;</span> + i);</span><br><span class="line">            timer.schedule(tt, <span class="number">5000</span>, <span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTimerTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    MyTimerTask(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + name + <span class="string">&quot; startDate:&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + name + <span class="string">&quot; endDate:&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">name:Task0 startDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">00</span>:<span class="number">54</span> CST <span class="number">2022</span></span><br><span class="line">name:Task0 endDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">00</span>:<span class="number">57</span> CST <span class="number">2022</span></span><br><span class="line">name:Task1 startDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">00</span>:<span class="number">57</span> CST <span class="number">2022</span></span><br><span class="line">name:Task1 endDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">00</span> CST <span class="number">2022</span></span><br><span class="line">name:Task2 startDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">00</span> CST <span class="number">2022</span></span><br><span class="line">name:Task2 endDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">03</span> CST <span class="number">2022</span></span><br><span class="line">name:Task0 startDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">04</span> CST <span class="number">2022</span></span><br><span class="line">name:Task0 endDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">07</span> CST <span class="number">2022</span></span><br><span class="line">name:Task1 startDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">07</span> CST <span class="number">2022</span></span><br><span class="line">name:Task1 endDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">10</span> CST <span class="number">2022</span></span><br><span class="line">name:Task2 startDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">10</span> CST <span class="number">2022</span></span><br><span class="line">name:Task2 endDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">13</span> CST <span class="number">2022</span></span><br><span class="line">name:Task0 startDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">14</span> CST <span class="number">2022</span></span><br><span class="line">name:Task0 endDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">17</span> CST <span class="number">2022</span></span><br><span class="line">name:Task1 startDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">17</span> CST <span class="number">2022</span></span><br><span class="line">name:Task1 endDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">20</span> CST <span class="number">2022</span></span><br><span class="line">name:Task2 startDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">20</span> CST <span class="number">2022</span></span><br><span class="line">name:Task2 endDate:Thu Sep <span class="number">15</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">23</span> CST <span class="number">2022</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Timer定时器流程总览：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Timer%E5%AE%9A%E6%97%</summary>
      
    
    
    
    <category term="多线程" scheme="https://lisj98.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Timer定时器类" scheme="https://lisj98.github.io/tags/Timer%E5%AE%9A%E6%97%B6%E5%99%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Thread类源码解析</title>
    <link href="https://lisj98.github.io/2022/09/13/Thread%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://lisj98.github.io/2022/09/13/Thread%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-09-13T09:01:43.000Z</published>
    <updated>2022-09-16T03:11:43.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h1><p>进程是操作系统运行的最小单位，进程拥有自己独立的地址空间。多任务操作系统可以通过周期性的将CPU从一个进程切换到另一个进程来实现同时运行多个进程(程序)，尽管这会让各个进程看起来总是歇歇停停，与此同时，这种操作系统也会将进程隔离开，因此它们彼此之间不会互相干涉。而Java所使用的并发操作系统不同，这种并发系统的进程会共享诸如内存和I&#x2F;O这些资源，由此引入了线程机制，更加细化了资源的分配，编写多线程程序的困难就在于协调资源调度，保证同一时间只能有一个线程访问资源，操作资源应该更为准确些。</p><p>线程是并行执行的，一个线程就是在进程中的一个单一的顺序控制流，单个进程可以拥有多个并发线程，其底层机制是切分CPU时间，在使用线程时，CPU将轮流给每个线程分配其占用时间，每个线程都觉得自己一直在占用CPU，事实上CPU时间是划分成了片段分配给了所有的线程交替执行。</p><p>Java中的线程机制是抢占式的，这表示调度机制会周期性的中断线程，将上下文切换到另一个线程，从而为每一个线程都提供时间片，这样每个线程都会分配到合理的时间去处理它的任务。还有一种协作多线程，线程可能会自动的放弃CPU的控制权(不同于抢占式的任务执行完或CPU时间片用完才放弃控制权)，这就要求程序开发人员手动的在程序中插入某种类型的让步语句(如yield)。</p><p>线程调度机制是非确定性的，或者说并发线程的执行顺序是不确定的。</p><p>Runnable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程驱动任务，定义线程用Thread，定义任务用Runnable或Callable，两者之间的区别就是Callable有返回值，Runnable无返回值。<code>run()</code>方法就是任务具体要做的事情，因此只有实现了<code>run()</code>方法，这个线程驱动的任务才是有意义的。可以这样说，将任务绑定给线程，任务相当于货物，线程相当于运输车辆，线程独有变量相当于自己车辆的信息(如货箱大小，车辆参数等)，线程间共享变量相当于所有车辆间共用的信息(如微信群分享的路线规划)，在一些资料中只称线程，另一些资料中只称任务，其实应该分开理解，不能混为一谈。</p><p>Java中使用线程来执行异步任务。</p><p>Thread类继承了Runnable接口。</p><h1 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h1><h2 id="2-1-属性"><a href="#2-1-属性" class="headerlink" title="2.1. 属性"></a>2.1. 属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程优先级</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否为守护线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">daemon</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Runnable任务</span></span><br><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程对应的线程组</span></span><br><span class="line"><span class="keyword">private</span> ThreadGroup group;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上下文类加载器</span></span><br><span class="line"><span class="keyword">private</span> ClassLoader contextClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承的父线程的访问控制上下文</span></span><br><span class="line"><span class="keyword">private</span> AccessControlContext inheritedAccessControlContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认线程名后的编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> threadInitNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程本地变量</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承的父线程的本地变量</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程栈大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> stackSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程ID</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> tid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程顺序号，其实就是线程ID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> threadSeqNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程状态，0表示&quot;NEW&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">threadStatus</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义未捕获异常处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认未捕获异常处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br></pre></td></tr></table></figure><h2 id="2-2-公共-x2F-常见方法"><a href="#2-2-公共-x2F-常见方法" class="headerlink" title="2.2. 公共&#x2F;常见方法"></a>2.2. 公共&#x2F;常见方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.无参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">()</span> &#123;</span><br><span class="line">init(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.接收Runnable任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.接收Runnable任务并指定线程名</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target, String name)</span> &#123;</span><br><span class="line">init(<span class="literal">null</span>, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.仅指定线程名</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">init(<span class="literal">null</span>, <span class="literal">null</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.指定线程组、接收Runnable任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, Runnable target)</span> &#123;</span><br><span class="line">init(group, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.线程组、Runnable任务、线程名</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name)</span> &#123;</span><br><span class="line">init(group, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.线程组、Runnable任务、线程名、栈大小(虚拟机为线程的栈分配的地址空间，取大取小依赖于平台，需要格外小心)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name,</span></span><br><span class="line"><span class="params">              <span class="type">long</span> stackSize)</span> &#123;</span><br><span class="line">init(group, target, name, stackSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.线程组、线程名</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, String name)</span> &#123;</span><br><span class="line">init(group, <span class="literal">null</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.非公共方法，很少使用</span></span><br><span class="line">Thread(Runnable target, AccessControlContext acc) &#123;</span><br><span class="line">init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>, acc, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="start方法"><a href="#start方法" class="headerlink" title="start方法"></a>start方法</h3><p>用于启动一个线程，只是将线程置于就绪状态，并不是真的让线程开始执行。</p><p>需要注意的一点是，start方法涉及到两个线程：主线程和即将启动的线程，调用start方法(<code>t.start()</code>)的是主线程，调用后启动的新线程如果获得了CPU时间片就会去执行它自己的<code>run()</code>方法。</p><p>不能多次start同一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将当前线程加入到其对应的线程组中，并将线程组中未启动线程数-1</span></span><br><span class="line">    <span class="comment">//在init方法中只是设置了线程组，并没有把该线程加入到线程组中</span></span><br><span class="line">group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">start0();<span class="comment">//本地方法</span></span><br><span class="line">started = <span class="literal">true</span>;<span class="comment">//标志位置为true，表示已就绪</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//没启动成功则将该线程从线程组里移除，并把未启动线程数+1</span></span><br><span class="line"><span class="keyword">if</span> (!started) &#123;</span><br><span class="line">group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line"><span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">  it will be passed up the call stack */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h3><p>用于指定具体的任务。</p><p>实际调用的是target，也就是Runnable任务的<code>run()</code>方法。如果传入了一个Runnable参数，那么就执行其<code>run()</code>方法，如果没有传入Runnable参数，那么就什么都不做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">target.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两方法的区别就是：</p><p>调用<code>start()</code>方法会执行一系列诸如线程状态检查、加入其对应的线程组、判断是否启动成功并维护线程组等动作，然后线程会被放到就绪队列，等待CPU调度，这意味着该线程并不会马上执行，<code>start()</code>方法体中会调用到具体任务的<code>run()</code>方法；</p><p>而单单调用<code>run()</code>方法的话只是普普通通地调用Runnable对象的一个方法，并没有经历<code>start()</code>方法所做的线程的准备工作，和普通对象调用普通方法一样。</p><h3 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h3><p>用于中断线程，但是仅仅是将线程的中断标志位设置为ture，线程是否真的中断需要线程自己时不时的判断这个中断标志位来决定。</p><p>具体地说，当一个线程调用<code>interrupt()</code>方法时：</p><ol><li>如果线程处于阻塞状态（<code>sleep()，wait()，join()</code>等），那么线程将立即退出阻塞状态，中断标志位复位为false，并抛出一个InterruptedException异常；</li><li>如果线程处于I&#x2F;O阻塞状态，那么中断标志位将置为true，并抛出一个ClosedByInterruptException异常(ClosedByInterruptException异常不是InterruptedException异常)；</li><li>如果线程处于NIO阻塞状态，那么中断标志位将置为true，并立即结束轮询操作；</li><li>如果线程处于正常状态，那么中断标志位将置为true。</li></ol><p>也就是说，线程检查到中断标志位为true时，就自行停止线程，处于阻塞状态的线程在检测到InterruptedException异常后，需要在catch中停止线程。</p><p>中断标志位的判断：中断线程时，当线程抛出了一个InterruptedException异常，或者调用了<code>interrupted()</code>方法时，中断标志位会被复位为false，其他时候都为true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">checkAccess();</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line"><span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line"><span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">interrupt0();</span><br><span class="line">b.interrupt(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isInterrupted方法"><a href="#isInterrupted方法" class="headerlink" title="isInterrupted方法"></a>isInterrupted方法</h3><p>判断线程是否已经被中断了，执行本方法不会改变线程的中断标志位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="interrupted方法"><a href="#interrupted方法" class="headerlink" title="interrupted方法"></a>interrupted方法</h3><p>判断当前线程是否被中断了，执行本方法会改变线程的中断标志位，什么意思呢，如果线程之前调用<code>interrupt()</code>方法中断了，那么它的中断标志位是true，第一次调用<code>interrupted()</code>方法返回true，同时会将中断标志位置为false，之后再调用<code>interrupted()</code>方法就会返回false了，除非中间又进行了什么其他操作使线程中断标志位变为true了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interrupt方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中断t线程</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;t线程调用interrupt()后调用isInterrupted()方法:&quot;</span>+t.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;t线程再次调用isInterrupted()方法:&quot;</span>+t.isInterrupted());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中断main线程</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程调用interrupt()后调用interrupted()方法:&quot;</span>+Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程再次调用interrupted()方法:&quot;</span>+Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程第三次调用interrupted()方法:&quot;</span>+Thread.interrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t线程调用interrupt()后调用isInterrupted()方法:truetrue</span><br><span class="line">t线程再次调用isInterrupted()方法:<span class="literal">false</span></span><br><span class="line">main线程调用interrupt()后调用interrupted()方法:<span class="literal">true</span></span><br><span class="line">main线程再次调用interrupted()方法:<span class="literal">false</span></span><br><span class="line">main线程第三次调用interrupted()方法:<span class="literal">false</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at Solution$<span class="number">1.</span>run(Solution.java:<span class="number">10</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure><h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>插队。</p><p>调用join方法的线程具有最高优先级，其他线程必须等待该线程执行完或等待一定时间后才能继续执行，适用于某些线程需要其他线程的运行结果才能继续执行的情景。</p><p>比如在main方法中调用了<code>t.join()</code>无参方法，那么main线程必须先等待t线程执行完毕再执行自己的部分，如果调用的是<code>t.join(mills)</code>方法，那么t线程执行mills时间，然后阻塞，main线程等待mills时间后执行自己的部分。</p><p>要注意的是<code>join()</code>方法中是调用的<code>wait()</code>方法来阻塞自己的，这就意味着线程阻塞时会释放资源锁，并且要想唤醒这类线程，必须另外调用<code>notify()</code>或<code>notifyAll()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.无参方法，其他线程必须等待本调用线程执行完毕</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.带有毫秒的方法，本调用线程执行多少毫秒后其他线程才能执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line"><span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">wait(delay);</span><br><span class="line">now = System.currentTimeMillis() - base;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.带有毫秒和纳秒的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">    <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">millis++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">join(millis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><p>用<code>join()</code>方法之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t线程开始执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t线程结束执行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main线程开始执行&quot;</span>);</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程结束执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main线程开始执行</span><br><span class="line">t线程开始执行</span><br><span class="line">main线程结束执行</span><br><span class="line">t线程结束执行</span><br></pre></td></tr></table></figure><p>用<code>join()</code>方法之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t线程开始执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t线程结束执行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程开始执行&quot;</span>);</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程结束执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t线程开始执行</span><br><span class="line">t线程结束执行</span><br><span class="line">main线程开始执行</span><br><span class="line">main线程结束执行</span><br></pre></td></tr></table></figure><p>用<code>join(mills)</code>方法之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t线程开始执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t线程结束执行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        t.join(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程开始执行&quot;</span>);</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程结束执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t线程开始执行</span><br><span class="line">main线程开始执行</span><br><span class="line">t线程结束执行</span><br><span class="line">main线程结束执行</span><br></pre></td></tr></table></figure><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><p>使线程休眠一定时间，不会释放资源锁，也就是本线程休眠了其他有资源冲突的线程也不能执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带毫秒参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带毫秒和纳秒参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">    <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">millis++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(millis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>让步。</p><p>让出CPU的控制权，只是建议，具体让不让需要看线程调度机制的脸色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取上下文类加载器</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> ClassLoader <span class="title function_">getContextClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (contextClassLoader == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">ClassLoader.checkClassLoaderPermission(contextClassLoader,</span><br><span class="line">                                       Reflection.getCallerClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> contextClassLoader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程的id</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程的线程名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程的优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程执行过程中的堆栈信息，</span></span><br><span class="line"><span class="keyword">public</span> StackTraceElement[] getStackTrace() &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread()) &#123;</span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">security.checkPermission(</span><br><span class="line">    SecurityConstants.GET_STACK_TRACE_PERMISSION);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line"><span class="keyword">return</span> EMPTY_STACK_TRACE;</span><br><span class="line">&#125;</span><br><span class="line">StackTraceElement[][] stackTraceArray = dumpThreads(<span class="keyword">new</span> <span class="title class_">Thread</span>[] &#123;<span class="built_in">this</span>&#125;);</span><br><span class="line">StackTraceElement[] stackTrace = stackTraceArray[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (stackTrace == <span class="literal">null</span>) &#123;</span><br><span class="line">stackTrace = EMPTY_STACK_TRACE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stackTrace;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">Exception</span>()).getStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程状态</span></span><br><span class="line"><span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程对应的线程组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ThreadGroup <span class="title function_">getThreadGroup</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> group;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程自定义的异常处理器</span></span><br><span class="line"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title function_">getUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> uncaughtExceptionHandler != <span class="literal">null</span> ?</span><br><span class="line">       uncaughtExceptionHandler : group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置自定义的上下文类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContextClassLoader</span><span class="params">(ClassLoader cl)</span> &#123;</span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">sm.checkPermission(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;setContextClassLoader&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">contextClassLoader = cl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置守护线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span> &#123;</span><br><span class="line">checkAccess();</span><br><span class="line"><span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">&#125;</span><br><span class="line">daemon = on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置线程名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">checkAccess();</span><br><span class="line"><span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">setNativeName(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置线程优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span> &#123;</span><br><span class="line">ThreadGroup g;</span><br><span class="line">checkAccess();</span><br><span class="line"><span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((g = getThreadGroup()) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">newPriority = g.getMaxPriority();</span><br><span class="line">&#125;</span><br><span class="line">setPriority0(priority = newPriority);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置自定义异常处理器(实现UncaughtExceptionHandler接口)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> &#123;</span><br><span class="line">checkAccess();</span><br><span class="line">uncaughtExceptionHandler = eh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isDaemon方法"><a href="#isDaemon方法" class="headerlink" title="isDaemon方法"></a>isDaemon方法</h3><p>判断线程是否是守护线程(后台线程)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isDaemon</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> daemon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="checkAccess方法"><a href="#checkAccess方法" class="headerlink" title="checkAccess方法"></a>checkAccess方法</h3><p>判断当前线程是否允许被修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkAccess</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">security.checkAccess(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h3><p>线程不能被clone，没意义，直接抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CloneNotSupportedException</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="destory、stop、suspend、resume方法在JDK1-8中已被废弃"><a href="#destory、stop、suspend、resume方法在JDK1-8中已被废弃" class="headerlink" title="destory、stop、suspend、resume方法在JDK1.8中已被废弃"></a>destory、stop、suspend、resume方法在JDK1.8中已被废弃</h3><h2 id="2-3-静态方法"><a href="#2-3-静态方法" class="headerlink" title="2.3. 静态方法"></a>2.3. 静态方法</h2><h3 id="currentThread方法"><a href="#currentThread方法" class="headerlink" title="currentThread方法"></a>currentThread方法</h3><p>本地方法，返回实际执行本方法的线程，或者说本方法的实际承载线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>要注意它是一个静态方法，这也就意味着它是所有对象间共享的，所以任一时刻只能有一个特定值。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">MyThread() &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.run();</span><br><span class="line">t.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>run()</code>方法是直接执行的自定义的<code>run()</code>方法，并且没有启动线程，因此<code>t.run()</code>的实际承载者还是main线程；</p><p>start方法启动了t线程，所以调用<code>t.start()</code>之后再进入到<code>run()</code>方法中时的实际承载者是t线程；</p><p>而最后的输出语句的实际承载者是main线程。</p><p>运行结果(由于线程执行顺序不确定，因此输出顺序也会不确定)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">main</span><br><span class="line">main</span><br><span class="line">Thread-<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="activeCount方法"><a href="#activeCount方法" class="headerlink" title="activeCount方法"></a>activeCount方法</h3><p>返回线程组及其子组中的活跃线程数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">activeCount</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentThread().getThreadGroup().activeCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dumpStack方法"><a href="#dumpStack方法" class="headerlink" title="dumpStack方法"></a>dumpStack方法</h3><p>将当前线程的堆栈跟踪信息打印到标准错误流，仅用于调试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dumpStack</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Stack trace&quot;</span>).printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enumerate方法"><a href="#enumerate方法" class="headerlink" title="enumerate方法"></a>enumerate方法</h3><p>将当前线程的线程组及其子组中的所有活跃线程复制到一个新的Thread数组中。若新数组的长度小于原数组的长度，那么会有一部分的线程会被丢弃，所以要谨慎控制长度。推荐仅使用本方法进行调试或监控。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">enumerate</span><span class="params">(Thread tarray[])</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentThread().getThreadGroup().enumerate(tarray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getAllStackTraces方法"><a href="#getAllStackTraces方法" class="headerlink" title="getAllStackTraces方法"></a>getAllStackTraces方法</h3><p>获取线程执行过程中的堆栈信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Thread, StackTraceElement[]&gt; getAllStackTraces() &#123;</span><br><span class="line"><span class="comment">// check for getStackTrace permission</span></span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">security.checkPermission(</span><br><span class="line">    SecurityConstants.GET_STACK_TRACE_PERMISSION);</span><br><span class="line">security.checkPermission(</span><br><span class="line">    SecurityConstants.MODIFY_THREADGROUP_PERMISSION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get a snapshot of the list of all threads</span></span><br><span class="line">Thread[] threads = getThreads();</span><br><span class="line">StackTraceElement[][] traces = dumpThreads(threads);</span><br><span class="line">Map&lt;Thread, StackTraceElement[]&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(threads.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">StackTraceElement[] stackTrace = traces[i];</span><br><span class="line"><span class="keyword">if</span> (stackTrace != <span class="literal">null</span>) &#123;</span><br><span class="line">m.put(threads[i], stackTrace);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// else terminated so we don&#x27;t put it in the map</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Thread, StackTraceElement[]&gt; as = Thread.getAllStackTraces();</span><br><span class="line"><span class="keyword">for</span> (Thread t : as.keySet()) &#123;</span><br><span class="line">StackTraceElement[] s = as.get(t);</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement stackTraceElement : s) &#123;</span><br><span class="line">System.out.println(t.getName()+<span class="string">&quot;：&quot;</span>+stackTraceElement);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Monitor Ctrl-Break：java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">Monitor Ctrl-Break：java.net.SocketInputStream.socketRead(SocketInputStream.java:<span class="number">116</span>)</span><br><span class="line">Monitor Ctrl-Break：java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">171</span>)</span><br><span class="line">Monitor Ctrl-Break：java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">141</span>)</span><br><span class="line">Monitor Ctrl-Break：sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:<span class="number">284</span>)</span><br><span class="line">Monitor Ctrl-Break：sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:<span class="number">326</span>)</span><br><span class="line">Monitor Ctrl-Break：sun.nio.cs.StreamDecoder.read(StreamDecoder.java:<span class="number">178</span>)</span><br><span class="line">Monitor Ctrl-Break：java.io.InputStreamReader.read(InputStreamReader.java:<span class="number">184</span>)</span><br><span class="line">Monitor Ctrl-Break：java.io.BufferedReader.fill(BufferedReader.java:<span class="number">161</span>)</span><br><span class="line">Monitor Ctrl-Break：java.io.BufferedReader.readLine(BufferedReader.java:<span class="number">324</span>)</span><br><span class="line">Monitor Ctrl-Break：java.io.BufferedReader.readLine(BufferedReader.java:<span class="number">389</span>)</span><br><span class="line">Monitor Ctrl-Break：com.intellij.rt.execution.application.AppMainV2$<span class="number">1.</span>run(AppMainV2.java:<span class="number">49</span>)</span><br><span class="line">Finalizer：java.lang.Object.wait(Native Method)</span><br><span class="line">Finalizer：java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">144</span>)</span><br><span class="line">Finalizer：java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">165</span>)</span><br><span class="line">Finalizer：java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:<span class="number">216</span>)</span><br><span class="line">Reference Handler：java.lang.Object.wait(Native Method)</span><br><span class="line">Reference Handler：java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">Reference Handler：java.lang.ref.Reference.tryHandlePending(Reference.java:<span class="number">191</span>)</span><br><span class="line">Reference Handler：java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class="number">153</span>)</span><br><span class="line">main：java.lang.Thread.dumpThreads(Native Method)</span><br><span class="line">main：java.lang.Thread.getAllStackTraces(Thread.java:<span class="number">1610</span>)</span><br><span class="line">main：MyThread.main(MyThread.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure><h3 id="getDefaultUncaughtExceptionHandler方法"><a href="#getDefaultUncaughtExceptionHandler方法" class="headerlink" title="getDefaultUncaughtExceptionHandler方法"></a>getDefaultUncaughtExceptionHandler方法</h3><p>获取默认异常处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> UncaughtExceptionHandler <span class="title function_">getDefaultUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> defaultUncaughtExceptionHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="setDefaultUncaughtExceptionHandler方法"><a href="#setDefaultUncaughtExceptionHandler方法" class="headerlink" title="setDefaultUncaughtExceptionHandler方法"></a>setDefaultUncaughtExceptionHandler方法</h3><p>设置自定义异常处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> &#123;</span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">sm.checkPermission(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;setDefaultUncaughtExceptionHandler&quot;</span>)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defaultUncaughtExceptionHandler = eh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nextThreadID方法"><a href="#nextThreadID方法" class="headerlink" title="nextThreadID方法"></a>nextThreadID方法</h3><p>返回计数器的下一个线程ID值。</p><p>在init()方法中被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextThreadID</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ++threadSeqNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nextThreadNum方法"><a href="#nextThreadNum方法" class="headerlink" title="nextThreadNum方法"></a>nextThreadNum方法</h3><p>返回默认的线程名编号，默认线程名是Thread-xxx的类型，该方法返回的就是后面的编号部分。</p><p>在构造方法中被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">nextThreadNum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-非静态私有-x2F-本地方法"><a href="#2-4-非静态私有-x2F-本地方法" class="headerlink" title="2.4. 非静态私有&#x2F;本地方法"></a>2.4. 非静态私有&#x2F;本地方法</h2><h3 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h3><p>初始化线程，由构造函数调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                  <span class="type">long</span> stackSize)</span> &#123;</span><br><span class="line">init(g, target, name, stackSize, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                  <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                  <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line"><span class="comment">//线程名不能为空，要么自己指定，要么使用默认的Thread-xxx的形式</span></span><br><span class="line"><span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父引用，指向当前线程的创建者，比如在main方法里创建了一个线程A，那么线程A的父线程就是main线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line"><span class="comment">//安全管理器</span></span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//下面这两句都是获取父线程的线程组。若自定义了安全管理器就通过安全管理器；若没有自定义安全管理器就直接赋值</span></span><br><span class="line"><span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">g = security.getThreadGroup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">g = parent.getThreadGroup();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查线程组的访问权限</span></span><br><span class="line">g.checkAccess();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加线程组中未启动线程的计数</span></span><br><span class="line">g.addUnstarted();</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.group = g;<span class="comment">//初始化当前线程的线程组(并入父线程的线程组)</span></span><br><span class="line"><span class="built_in">this</span>.daemon = parent.isDaemon();<span class="comment">//是否是守护线程</span></span><br><span class="line"><span class="built_in">this</span>.priority = parent.getPriority();<span class="comment">//优先级</span></span><br><span class="line"><span class="comment">//上下文类加载器</span></span><br><span class="line"><span class="keyword">if</span> (security == <span class="literal">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line"><span class="built_in">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line"><span class="comment">//继承的访问控制上下文</span></span><br><span class="line"><span class="built_in">this</span>.inheritedAccessControlContext =</span><br><span class="line">    acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line"><span class="built_in">this</span>.target = target;<span class="comment">//Runnable任务</span></span><br><span class="line">setPriority(priority);</span><br><span class="line"><span class="comment">//判断是否要继承父线程的本地变量副本</span></span><br><span class="line"><span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line"><span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">    ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"><span class="built_in">this</span>.stackSize = stackSize;<span class="comment">//栈大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置线程ID</span></span><br><span class="line">tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="interrupt0方法"><a href="#interrupt0方法" class="headerlink" title="interrupt0方法"></a>interrupt0方法</h3><p>中断线程的具体操作方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="isInterrupted方法-1"><a href="#isInterrupted方法-1" class="headerlink" title="isInterrupted方法"></a>isInterrupted方法</h3><p>判断线程是否已经被中断了，中断标志位是否被改变取决于ClearInterrupted的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br></pre></td></tr></table></figure><h3 id="start0方法"><a href="#start0方法" class="headerlink" title="start0方法"></a>start0方法</h3><p>线程实际启动方法。</p><p>由<code>start()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="setPriority0方法"><a href="#setPriority0方法" class="headerlink" title="setPriority0方法"></a>setPriority0方法</h3><p>设置优先级。</p><p>由<code>setPriority()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setPriority0</span><span class="params">(<span class="type">int</span> newPriority)</span>;</span><br></pre></td></tr></table></figure><h3 id="setNativeName方法"><a href="#setNativeName方法" class="headerlink" title="setNativeName方法"></a>setNativeName方法</h3><p>设置线程名。</p><p>由<code>setName()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setNativeName</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure><h3 id="dumpThreads方法"><a href="#dumpThreads方法" class="headerlink" title="dumpThreads方法"></a>dumpThreads方法</h3><p>用于打印线程堆栈跟踪信息。</p><p>由<code>getStackTrace()</code>和<code>getAllStackTraces()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> StackTraceElement[][] dumpThreads(Thread[] threads);</span><br></pre></td></tr></table></figure><h3 id="exit方法"><a href="#exit方法" class="headerlink" title="exit方法"></a>exit方法</h3><p>JVM调用此方法清空线程信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (group != <span class="literal">null</span>) &#123;</span><br><span class="line">group.threadTerminated(<span class="built_in">this</span>);</span><br><span class="line">group = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">target = <span class="literal">null</span>;</span><br><span class="line">threadLocals = <span class="literal">null</span>;</span><br><span class="line">inheritableThreadLocals = <span class="literal">null</span>;</span><br><span class="line">inheritedAccessControlContext = <span class="literal">null</span>;</span><br><span class="line">blocker = <span class="literal">null</span>;</span><br><span class="line">uncaughtExceptionHandler = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getThreads方法"><a href="#getThreads方法" class="headerlink" title="getThreads方法"></a>getThreads方法</h3><p>返回一个包含所有线程的线程数组。</p><p>由<code>getAllStackTraces()</code>方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> Thread[] getThreads();</span><br></pre></td></tr></table></figure><h3 id="isAlive方法"><a href="#isAlive方法" class="headerlink" title="isAlive方法"></a>isAlive方法</h3><p>判断线程是否仍然活跃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="dispatchUncaughtException方法"><a href="#dispatchUncaughtException方法" class="headerlink" title="dispatchUncaughtException方法"></a>dispatchUncaughtException方法</h3><p>JVM使用此方法将未捕获异常分派给异常处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchUncaughtException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">getUncaughtExceptionHandler().uncaughtException(<span class="built_in">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-内部类-x2F-接口"><a href="#2-5-内部类-x2F-接口" class="headerlink" title="2.5. 内部类&#x2F;接口"></a>2.5. 内部类&#x2F;接口</h2><h3 id="UncaughtExceptionHandler接口"><a href="#UncaughtExceptionHandler接口" class="headerlink" title="UncaughtExceptionHandler接口"></a>UncaughtExceptionHandler接口</h3><p>当线程因未捕获的异常而中断时，JVM会用<code>getUncaughtExceptionHandler()</code>方法来查找线程自定义或默认的UncaughtExceptionHandler异常处理器，然后使用处理器中的<code>uncaughtException()</code>方法来处理未捕获异常。</p><p>如果线程没有自定义UncaughtExceptionHandler异常处理器，那会就会使用其所在的线程组中的异常处理器；如果其所在线程组也没有自定义的异常处理器，则会使用<code>getDefaultUncaughtExceptionHandler()</code>方法来找到默认的异常处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UncaughtExceptionHandler</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="State枚举类"><a href="#State枚举类" class="headerlink" title="State枚举类"></a>State枚举类</h3><p>线程状态枚举类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="comment">//新建</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//就绪</span></span><br><span class="line">RUNNABLE,</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待阻塞(无时间限制)</span></span><br><span class="line">    <span class="comment">//wait()、join()、LockSupport.park等造成。wait()需要另一线程调用notify()或notifyAll()唤醒；join()需要等待线程执行特定时间</span></span><br><span class="line">WAITING,</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待阻塞(特定时间)</span></span><br><span class="line">    <span class="comment">//sleep()、wait(time)、join(time)、LockSupport.parkNanos、LockSupport.parkUntil造成</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line"><span class="comment">//终止</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-补充"><a href="#3-补充" class="headerlink" title="3. 补充"></a>3. 补充</h1><h2 id="3-1-创建并运行线程"><a href="#3-1-创建并运行线程" class="headerlink" title="3.1. 创建并运行线程"></a>3.1. 创建并运行线程</h2><p>代码示例：</p><p>1.使用Runnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread:&quot;</span>+i--);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.继承Thread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread:&quot;</span>+i--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上运行结果都是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread:<span class="number">5</span></span><br><span class="line">Thread:<span class="number">4</span></span><br><span class="line">Thread:<span class="number">3</span></span><br><span class="line">Thread:<span class="number">2</span></span><br><span class="line">Thread:<span class="number">1</span></span><br></pre></td></tr></table></figure><p>3.使用Callable和Future</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Thread.call()&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Callable返回值:&quot;</span>+ft.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Callable返回值:Thread.call()</span><br></pre></td></tr></table></figure><p>4.还有一种用线程池创建的方式，具体见线程池文档。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-前置知识&quot;&gt;&lt;a href=&quot;#1-前置知识&quot; class=&quot;headerlink&quot; title=&quot;1. 前置知识&quot;&gt;&lt;/a&gt;1. 前置知识&lt;/h1&gt;&lt;p&gt;进程是操作系统运行的最小单位，进程拥有自己独立的地址空间。多任务操作系统可以通过周期性的将CPU从一个进</summary>
      
    
    
    
    <category term="多线程" scheme="https://lisj98.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Thread类" scheme="https://lisj98.github.io/tags/Thread%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统下配置jdk及环境变量</title>
    <link href="https://lisj98.github.io/2022/09/09/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AEjdk%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://lisj98.github.io/2022/09/09/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AEjdk%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2022-09-09T05:47:24.000Z</published>
    <updated>2022-09-09T05:53:14.036Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 系统通常会自带 openjdk，我们需要先卸载掉 openjdk，然后安装自己的 jdk。</p><h1 id="1、卸载系统中的-openjdk"><a href="#1、卸载系统中的-openjdk" class="headerlink" title="1、卸载系统中的 openjdk"></a>1、卸载系统中的 openjdk</h1><p>首先查询 java 环境,可以看到系统自带的 openjdk 版本；</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/java-version%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6openjdk%E7%89%88%E6%9C%AC.4n1pe8ggihk0.webp" alt="java-version查看系统自带openjdk版本"></p><p>接着查询系统中的 java 相关文件，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84java%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.o7f7ykfxfdc.webp" alt="查询系统中的java相关文件"></p><p>下面的部分需要全部删除，其余的可以不用管；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64</span><br><span class="line">java-1.7.0-openjdk-headless-1.7.0.191-2.6.15.5.el7.x86_64</span><br><span class="line">java-1.7.0-openjdk-1.7.0.191-2.6.15.5.el7.x86_64</span><br><span class="line">java-1.8.0-openjdk-headless-1.8.0.181-7.b13.el7.x86_64</span><br></pre></td></tr></table></figure><p>以此类推，完整的删除命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64</span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.191-2.6.15.5.el7.x86_64</span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-1.7.0.191-2.6.15.5.el7.x86_64</span><br><span class="line">rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.181-7.b13.el7.x86_64</span><br></pre></td></tr></table></figure><p>检查是否全部删除完毕，同样，使用 java -version 命令，如果提示未找到文件，则说明删除成功，注意需要在 root 权限下才可删除。</p><h1 id="2、安装新版-jdk，这里所使用的是-rpm-安装的方式"><a href="#2、安装新版-jdk，这里所使用的是-rpm-安装的方式" class="headerlink" title="2、安装新版 jdk，这里所使用的是 rpm 安装的方式"></a>2、安装新版 jdk，这里所使用的是 rpm 安装的方式</h1><p>如何将 Windows 系统下下载的 jdk 上传到 Linux 系统，详情见<a href="http://lisj98.github.io/2022/09/09/%E5%B0%86Windows%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8%E5%88%B0Linux%E4%B8%AD/">将Windows中的文件移动到Linux中</a><br>使用如下命令直接安装（注意 jdk 的路径）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh jdk-8u261-linux-x64.rpm</span><br></pre></td></tr></table></figure><p>测试 java -version，可以看到安装成功。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/%E6%B5%8B%E8%AF%95java-version.5uce28inmz00.webp" alt="测试java-version"></p><h1 id="3、配置环境变量，和-Windows-系统类似"><a href="#3、配置环境变量，和-Windows-系统类似" class="headerlink" title="3、配置环境变量，和 Windows 系统类似"></a>3、配置环境变量，和 Windows 系统类似</h1><p>可见 jdk 在用户目录下的 java 目录中；</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/jdk%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95.5zk5t9kqtx00.webp" alt="jdk默认安装目录"></p><p>在<code>/etc/profile</code>的最后添加如下代码（建议复制粘贴，路径自己设置，手写有可能导致 PATH 路径出错，进而导致系统打不开，在登录界面无限循环，出现此问题可以参照<a class="link"   href="https://blog.csdn.net/dairy_J/article/details/108319472" >解决进入 Linux 系统时在登录页面无限循环 或者 常见命令不可用的问题<i class="fas fa-external-link-alt"></i></a>)；</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/%E4%BF%AE%E6%94%B9profile%E6%96%87%E4%BB%B6.2vzm8olt4ea0.webp" alt="修改profile文件"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_261-amd64</span><br><span class="line">CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/lib</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JAVA_HOME</span>/jre/bin</span><br><span class="line"><span class="built_in">export</span> PATH CLASSPATH JAVA_HOME</span><br></pre></td></tr></table></figure><p>CLASSPATH 和 PATH 和 Windows 系统下的配置一样，注意不同的一点是最后需要导出配置才能生效。<br>让新增的环境变量生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>配置完毕。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux 系统通常会自带 openjdk，我们需要先卸载掉 openjdk，然后安装自己的 jdk。&lt;/p&gt;
&lt;h1 id=&quot;1、卸载系统中的-openjdk&quot;&gt;&lt;a href=&quot;#1、卸载系统中的-openjdk&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="Linux" scheme="https://lisj98.github.io/categories/Linux/"/>
    
    
    <category term="Linux配置" scheme="https://lisj98.github.io/tags/Linux%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>将Windows中的文件移动到Linux中</title>
    <link href="https://lisj98.github.io/2022/09/09/%E5%B0%86Windows%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8%E5%88%B0Linux%E4%B8%AD/"/>
    <id>https://lisj98.github.io/2022/09/09/%E5%B0%86Windows%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8%E5%88%B0Linux%E4%B8%AD/</id>
    <published>2022-09-09T05:31:17.000Z</published>
    <updated>2022-09-09T05:41:52.960Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Linux 时，可能没有配置网络，或者因为操作命令过于繁琐，因此为图方便，我们可以先在 Windows 系统下下载好文件，然后再移动到 Linux 系统中，方便你我他。</p><h1 id="1、使用命令"><a href="#1、使用命令" class="headerlink" title="1、使用命令"></a>1、使用命令</h1><h2 id="1-1、首先需要使用到-Xshell-工具，可以在-Windows-界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的；"><a href="#1-1、首先需要使用到-Xshell-工具，可以在-Windows-界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的；" class="headerlink" title="1.1、首先需要使用到 Xshell 工具，可以在 Windows 界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的；"></a>1.1、首先需要使用到 Xshell 工具，可以在 Windows 界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的；</h2><h3 id="1-1-1、可以到官网下载，官网地址为：https-xshell-en-softonic-com"><a href="#1-1-1、可以到官网下载，官网地址为：https-xshell-en-softonic-com" class="headerlink" title="1.1.1、可以到官网下载，官网地址为：https://xshell.en.softonic.com/"></a>1.1.1、可以到官网下载，官网地址为：<a class="link"   href="https://xshell.en.softonic.com/" >https://xshell.en.softonic.com/<i class="fas fa-external-link-alt"></i></a></h3><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/Xshell%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80.1mvnfolb4pj4.webp" alt="Xshell官网下载地址"></p><h3 id="1-1-2、或者直接在360软件管家中一键下载。"><a href="#1-1-2、或者直接在360软件管家中一键下载。" class="headerlink" title="1.1.2、或者直接在360软件管家中一键下载。"></a>1.1.2、或者直接在360软件管家中一键下载。</h3><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/Xshell360%E8%BD%AF%E4%BB%B6%E7%AE%A1%E5%AE%B6%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80.j7mladerlyw.webp" alt="Xshell360软件管家下载地址"></p><h2 id="1-2、安装好之后连接-Linux-系统；"><a href="#1-2、安装好之后连接-Linux-系统；" class="headerlink" title="1.2、安装好之后连接 Linux 系统；"></a>1.2、安装好之后连接 Linux 系统；</h2><p>打开软件后点击新建连接：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/Xshell%E6%96%B0%E5%BB%BA%E8%BF%9E%E6%8E%A5.pckwo234zv4.webp" alt="Xshell新建连接"></p><p>会弹出如下窗口：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/Xshell%E6%96%B0%E5%BB%BA%E4%BC%9A%E8%AF%9D.20zmkbeot740.webp" alt="Xshell新建会话"></p><p>其中名称和主机为我们的虚拟机的 IP 地址，当然名称看你喜欢随意取，主机当然还是 IP 地址。<br>IP 地址可通过命令<code>ip addr</code>或者<code>ifconfig</code>，前者系统自带，后者如果你当初安装虚拟机时选择的是最小化安装（就是Minimum…的哪个)，那你可能需要通过<code>yum install net-tools.x86_64</code>这个命令来安装<code>net-tools</code>这个命令包，其中就包含了<code>ifconfig、netstat</code>等吧啦吧啦一系列命令。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/ipaddr.5qk46wahgo00.webp" alt="ipaddr"></p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/ifconfig.57l910peqq0.webp" alt="ifconfig"></p><p>将 Xshell 中的名称、主机补全之后点击连接测试，会要求输入用户名和密码，此处的用户名和密码即为虚拟机中 Linux 系统的登录名和密码，用户名和密码输入正确后便建立了连接。</p><h2 id="1-3、通过命令-sz-和-rz-进行下载和上传。"><a href="#1-3、通过命令-sz-和-rz-进行下载和上传。" class="headerlink" title="1.3、通过命令 sz 和 rz 进行下载和上传。"></a>1.3、通过命令 sz 和 rz 进行下载和上传。</h2><p>查看是否安装了上传与下载程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa |grep  sz</span><br><span class="line">rpm -qa |grep  rz</span><br></pre></td></tr></table></figure><p>如果没有安装，可以使用如下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -install sz</span><br><span class="line">yum -install rz</span><br></pre></td></tr></table></figure><p>直接使用命令 rz，Xshell 会弹出选择文件窗口，此时直接上传想要上传的文件即可；</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/Xshell%E5%BC%B9%E5%87%BA%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6%E7%AA%97%E5%8F%A3.gz6kg6pxdko.webp" alt="Xshell弹出选择文件窗口"></p><p>上传成功之后，会储存在 Linux 系统的主目录中，此时可根据需要进行移动或复制（<code>cp、mv</code>等等，说实话比较麻烦)。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/Linux%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%9B%AE%E5%BD%95.xegilckvjao.webp" alt="Linux系统主目录"></p><h1 id="2、使用xftp"><a href="#2、使用xftp" class="headerlink" title="2、使用xftp"></a>2、使用xftp</h1><p>Xshell 中带有 Xftp 工具，下载完成后即可使用，连接过程与 Xshell 连接过程一样。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/Xftp%E5%B7%A5%E5%85%B7.36w3fjta1g00.webp" alt="Xftp工具"></p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/Xftp%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.1t6lz8epsd0g.webp" alt="Xftp使用示例"></p><p>使用时直接移动到指定文件夹即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 Linux 时，可能没有配置网络，或者因为操作命令过于繁琐，因此为图方便，我们可以先在 Windows 系统下下载好文件，然后再移动到 Linux 系统中，方便你我他。&lt;/p&gt;
&lt;h1 id=&quot;1、使用命令&quot;&gt;&lt;a href=&quot;#1、使用命令&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Linux" scheme="https://lisj98.github.io/categories/Linux/"/>
    
    
    <category term="Linux配置" scheme="https://lisj98.github.io/tags/Linux%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络配置（NAT模式）</title>
    <link href="https://lisj98.github.io/2022/09/09/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%EF%BC%88NAT%E6%A8%A1%E5%BC%8F%EF%BC%89/"/>
    <id>https://lisj98.github.io/2022/09/09/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%EF%BC%88NAT%E6%A8%A1%E5%BC%8F%EF%BC%89/</id>
    <published>2022-09-09T05:24:15.000Z</published>
    <updated>2022-09-09T05:33:35.056Z</updated>
    
    <content type="html"><![CDATA[<p>本篇着重记录 NAT 模式的配置过程，大多数人用的应该是 NAT 模式和桥接模式（NAT 模式、桥接模式、主机模式的区别自己百度，我有兴趣了再补），我之前也是用的桥接模式，但是有一次出现了 Xshell 连接不上 Linux 的问题，然而两边又都 ping 的通，该开放的端口也开放了，该关的防火墙也关了，最后我发现 Linux ping Windows 的速度特别慢，我觉得可能是网络延迟的问题，然后我把网络配置改成了 NAT 模式就好了，话说桥接模式有网络延迟的问题吗<code>(￣_￣|||)</code>，可能有吧，之后再深究。<br>上图：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE.6pmmdz4art40.webp" alt="虚拟机设置"></p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/%E5%85%B7%E4%BD%93%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE.2pylpodsa7u0.webp" alt="具体网络设置"></p><h1 id="1、在虚拟机-gt-设置里找到网络适配器，选择NAT-模式"><a href="#1、在虚拟机-gt-设置里找到网络适配器，选择NAT-模式" class="headerlink" title="1、在虚拟机--&gt;设置里找到网络适配器，选择NAT 模式"></a>1、在<code>虚拟机--&gt;设置</code>里找到<code>网络适配器</code>，选择<code>NAT 模式</code></h1><h1 id="2、在编辑-gt-虚拟网络编辑器里操作"><a href="#2、在编辑-gt-虚拟网络编辑器里操作" class="headerlink" title="2、在编辑--&gt;虚拟网络编辑器里操作"></a>2、在<code>编辑--&gt;虚拟网络编辑器</code>里操作</h1><h2 id="2-1、找到你的-NAT-模式对应的那个虚拟网卡"><a href="#2-1、找到你的-NAT-模式对应的那个虚拟网卡" class="headerlink" title="2.1、找到你的 NAT 模式对应的那个虚拟网卡"></a>2.1、找到你的 NAT 模式对应的那个虚拟网卡</h2><h2 id="2-2、进入NAT设置"><a href="#2-2、进入NAT设置" class="headerlink" title="2.2、进入NAT设置"></a>2.2、进入<code>NAT设置</code></h2><h2 id="2-3、记住你的子网IP、子网掩码、网关IP"><a href="#2-3、记住你的子网IP、子网掩码、网关IP" class="headerlink" title="2.3、记住你的子网IP、子网掩码、网关IP"></a>2.3、记住你的<code>子网IP、子网掩码、网关IP</code></h2><h1 id="3、操作具体的网络配置文件"><a href="#3、操作具体的网络配置文件" class="headerlink" title="3、操作具体的网络配置文件"></a>3、操作具体的网络配置文件</h1><p>Linux 中关于网络的配置文件是这个<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code>；</p><h2 id="3-1、进入这个文件，添加上图所示的一些配置"><a href="#3-1、进入这个文件，添加上图所示的一些配置" class="headerlink" title="3.1、进入这个文件，添加上图所示的一些配置"></a>3.1、进入这个文件，添加上图所示的一些配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这些不用改</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=<span class="built_in">yes</span></span><br><span class="line">IPV6_AUTOCONF=<span class="built_in">yes</span></span><br><span class="line">IPV6_DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=18a44390-52f3-4367-bf30-ee8c3cd510d2</span><br><span class="line">DEVICE=ens33</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这些要改</span></span><br><span class="line">ONBOOT=<span class="built_in">yes</span><span class="comment"># 开启自动启用网络连接</span></span><br><span class="line">BOOTPROTO=static<span class="comment"># 启用静态IP地址</span></span><br><span class="line">HWADDR=xx:xx:xx:xx:xx:xx<span class="comment"># MAC地址，命令ip link show查看</span></span><br><span class="line">IPADDR=192.168.14.5<span class="comment"># IP地址，前三个数字要和你的NAT模式的那个网卡（即上图中的Vmnet8）的子网IP地址一样，最后一个数字随便填，只要不超过255就行</span></span><br><span class="line">NETMASK=255.255.255.0<span class="comment"># 子网掩码，和Vmnet8的一样</span></span><br><span class="line">GATEWAY=192.168.14.2<span class="comment"># 网关，和Vmnet8的一样</span></span><br><span class="line">DNS1=114.114.114.114<span class="comment"># DNS地址1</span></span><br><span class="line">DNS2=8.8.8.8<span class="comment"># DNS地址2，为什么要在这里配置DNS地址呢，其实应该在另一个地方配置，即/etc/resolv.conf这个文件里，但是由于主机重启或者网络重启的时候这个文件经常被自动重置，导致主机连不上网，所以干脆直接写在这里了，在这里的话每次重启都会把这两个DNS地址自动拼接到resolv.conf那个文件中</span></span><br></pre></td></tr></table></figure><h2 id="3-2、修改网卡名"><a href="#3-2、修改网卡名" class="headerlink" title="3.2、修改网卡名"></a>3.2、修改网卡名</h2><p>CentOS 6 默认的网卡名是<code>eth0</code>往上走，CentOS 7 默认的网卡名是<code>ens33</code>往上走，为什么要修改网卡名呢，因为自动化运维的时候需要所有的服务器网卡名称统一，当然如果你是自己玩，那么就不用修改网卡名了，下面的步骤也不用执行了；</p><h3 id="3-2-1、重命名网卡名称"><a href="#3-2-1、重命名网卡名称" class="headerlink" title="3.2.1、重命名网卡名称"></a>3.2.1、重命名网卡名称</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入/etc/sysconfig/network-scripts/目录</span></span><br><span class="line"><span class="built_in">cd</span> /etc/sysconfig/network-scripts/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改名称</span></span><br><span class="line"><span class="built_in">mv</span> ifcfg-ens33 ifcfg-eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改ifcfg-etho文件内容</span></span><br><span class="line">vi ifcfg-eth0</span><br><span class="line"></span><br><span class="line"><span class="comment">#在文件中修改如下两处</span></span><br><span class="line">NAME=eth0</span><br><span class="line">DEVICE=eth0</span><br></pre></td></tr></table></figure><h3 id="3-2-2、修改并重新生成grub配置（Linux的启动引导配置）"><a href="#3-2-2、修改并重新生成grub配置（Linux的启动引导配置）" class="headerlink" title="3.2.2、修改并重新生成grub配置（Linux的启动引导配置）"></a>3.2.2、修改并重新生成grub配置（Linux的启动引导配置）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改/etc/sysconfig/grub文件的内容</span></span><br><span class="line">vi /etc/sysconfig/grub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在GRUB_CMDLINE_LINUX的值中添加如下内容</span></span><br><span class="line">net.ifnames=0 biosdevname=0<span class="comment"># 表示按照eth0网卡启动网络配置</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/%E4%BF%AE%E6%94%B9grub%E9%85%8D%E7%BD%AE.5ile0gyx7ik0.webp" alt="修改grub配置"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新生成配置并更新内核参数</span></span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><h3 id="3-2-3、添加udev规则修改网卡逻辑名称"><a href="#3-2-3、添加udev规则修改网卡逻辑名称" class="headerlink" title="3.2.3、添加udev规则修改网卡逻辑名称"></a>3.2.3、添加udev规则修改网卡逻辑名称</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入/etc/udev/rules.d目录</span></span><br><span class="line"><span class="built_in">cd</span> /etc/udev/rules.d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动生成70-persistent-net.rules</span></span><br><span class="line">vi 70-persistent-net.rules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line">SUBSYSTEM==<span class="string">&quot;net&quot;</span>,ACTION==<span class="string">&quot;add&quot;</span>,DRIVERS==<span class="string">&quot;?*&quot;</span>,ATTR&#123;address&#125;==<span class="string">&quot;自己的MAC地址&quot;</span>,ATTR&#123;<span class="built_in">type</span>&#125;==<span class="string">&quot;1&quot;</span>,KERNEL==<span class="string">&quot;eth*&quot;</span>,NAME=<span class="string">&quot;eth0&quot;</span></span><br></pre></td></tr></table></figure><h1 id="4、关闭防火墙"><a href="#4、关闭防火墙" class="headerlink" title="4、关闭防火墙"></a>4、关闭防火墙</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service <span class="comment"># 停止防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment"># 禁止防火墙开机启动</span></span><br><span class="line">systemctl mask firewalld.service <span class="comment"># 注销防火墙</span></span><br></pre></td></tr></table></figure><h1 id="5、关闭SELINUX"><a href="#5、关闭SELINUX" class="headerlink" title="5、关闭SELINUX"></a>5、关闭SELINUX</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改/etc/selinux/config文件，将SELINUX=enforcing改成SELINUX=disabled</span></span><br><span class="line">vi /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看selinux状态</span></span><br><span class="line">sestatus</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/Linux/%E5%85%B3%E9%97%ADSELINUX.134xrecv5cps.webp" alt="关闭SELINUX"></p><p>重启网络服务<code>service network restart</code>；</p><p>重启系统<code>reboot</code>；</p><p>然后 <code>ping或者crul</code> 一下百度等等，再在 Windows 系统上 ping 一下 Linux 主机，能 ping 通，能下载，就代表网络已经配置完成了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇着重记录 NAT 模式的配置过程，大多数人用的应该是 NAT 模式和桥接模式（NAT 模式、桥接模式、主机模式的区别自己百度，我有兴趣了再补），我之前也是用的桥接模式，但是有一次出现了 Xshell 连接不上 Linux 的问题，然而两边又都 ping 的通，该开放的端</summary>
      
    
    
    
    <category term="Linux" scheme="https://lisj98.github.io/categories/Linux/"/>
    
    
    <category term="Linux配置" scheme="https://lisj98.github.io/tags/Linux%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>MyBatisGenerator使用</title>
    <link href="https://lisj98.github.io/2022/09/08/MyBatisGenerator%E4%BD%BF%E7%94%A8/"/>
    <id>https://lisj98.github.io/2022/09/08/MyBatisGenerator%E4%BD%BF%E7%94%A8/</id>
    <published>2022-09-08T15:29:19.000Z</published>
    <updated>2022-09-08T15:49:35.051Z</updated>
    
    <content type="html"><![CDATA[<p>MyBaits Generator 三部曲：<br>1、<a href="https://lisj98.github.io/2022/09/08/MyBatisGenerator%E7%AE%80%E4%BB%8B/">MyBatis Generator 简介</a><br>2、<a href="https://lisj98.github.io/2022/09/08/MyBatisGenerator%E4%BD%BF%E7%94%A8/">MyBatis Generator 使用</a><br>3、MyBatis Generator 扩展 <a class="link"   href="http://mybatis.org/generator/reference/intro.html" >官方文档<i class="fas fa-external-link-alt"></i></a></p><h1 id="1、快速开始"><a href="#1、快速开始" class="headerlink" title="1、快速开始"></a>1、快速开始</h1><p>要快速启动和运行 MyBatis 生成器（MBG），需要遵循以下步骤（此处为命令行方式生成，还可使用 Maven 插件或 Java 代码生成，见下方 <a href="#2">2、运行 MBG</a>）：<br>1、创建并编写一个配置文件<br>2、将文件保存在一些方便的位置(如 \temp\generatorConfig.xml)<br>3、在命令行中使用如下命令运行MBG：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar mybatis-generator-core-x.x.x.jar -configfile \temp\generatorConfig.xml -overwrite</span><br></pre></td></tr></table></figure><p>这将告诉 MBG 使用自定义的配置文件运行。它还会告诉 MBG 用相同的名称覆盖任何现有的 Java 文件。如果您想保存任何现有文件，那么可以省略 <code>-overwrite</code> 参数。如果有冲突，MBG 将以唯一的名称保存新生成的文件(例如 MyClass.java.1)。</p><p>如此便生成了所需的代码。</p><p>根据配置的不同，MBG 生成的代码也会不同，这是通过在配置元素上指定 <code>targetRuntime</code> 属性（generatorConfig.xml 中）来控制的。</p><p>targetRuntime 属性有以下四种选择：</p><ul><li><p><code>MyBatis3DynamicSql</code>（默认值）</p><ul><li>生成 Java 代码</li><li>不生成 XML 文件，只生成注解</li><li>生成的实体类对象是扁平的——没有单独的主键对象（即只有一个 Record 类）</li><li>生成的代码依赖于 MyBatis 动态 SQL 库</li><li>生成的代码相对较少</li><li>生成的代码在查询条件构造方面具有极大的灵活性</li></ul><p>  配置示例：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;dsql&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3DynamicSql&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;org.hsqldb.jdbcDriver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:hsqldb:mem:aname&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;example.model&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;example.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;FooTable&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>MyBatis3Kotlin</code>（省略，见官网）</p></li><li><p><code>MyBatis3</code>（MBG 1.3.6版本之前大多使用该属性）</p><ul><li>生成 Java 代码</li><li>生成 MyBatis3 兼容的 XML 配置文件或者不带配置文件的注解（即既能生成 XML 文件，又能生成注解，通过 &lt;javaClientGenerator type&#x3D;”xxx”&#x2F;&gt; 指定）</li><li>生成的实体类对象可能具有单独的主键对象或者带有 BLOB 字段的单独对象（即有一个 Record 类、一个主键类、一个 Record With BLOBs 类，最后会合并为一个实体类展现）</li><li>生成的代码没有外部依赖项</li><li>生成的代码量非常大</li><li>生成的代码查询条件构造能力有限，很难扩展</li></ul><p>  配置示例：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;simple&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;org.hsqldb.jdbcDriver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:hsqldb:mem:aname&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--生成的实体类位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;example.model&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--生成的 Mapper.xml 映射文件位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;example.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--生成的 Mapper 接口位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;example.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;FooTable&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>MyBatis3Simple</code>（MyBatis3 简化版）</p><ul><li>生成Java代码</li><li>生成 MyBatis3 兼容的 XML 配置文件或者不带配置文件的注解（即既能生成 XML 文件，又能生成注解）</li><li>生成的实体类对象是扁平的——没有单独的主键对象（即只有一个 Record 类）</li><li>生成的代码没有外部依赖项</li><li>生成的代码相对较少</li><li>不生成“by example”或“selective”方法，即生成的代码不包括用于动态查询构造的方法，很难扩展</li></ul><p>  配置示例：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;simple&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;org.hsqldb.jdbcDriver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:hsqldb:mem:aname&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;example.model&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;ANNOTATEDMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;example.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;FooTable&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a id="2"></a></p><h1 id="2、运行-MBG"><a href="#2、运行-MBG" class="headerlink" title="2、运行 MBG"></a>2、运行 MBG</h1><p>运行 MBG 有①<code>命令行</code>、②<code>Ant</code>、③<code>Maven 插件</code>、④<code>Java 代码</code>、⑤<code>Eclipse</code> 五种方式，这里只介绍 Maven 插件和 Java 代码的方式。</p><h2 id="2-1、Maven-插件方式"><a href="#2-1、Maven-插件方式" class="headerlink" title="2.1、Maven 插件方式"></a>2.1、Maven 插件方式</h2><p>直接将 MBG 插件配置到 pom.xml 中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line">     <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       ...</span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>false<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tableNames</span>&gt;</span>fb_player,fb_score<span class="tag">&lt;/<span class="name">tableNames</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">contexts</span>&gt;</span>mbg1,mbg2<span class="tag">&lt;/<span class="name">contexts</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>需要注意的是</code>：由于是直接使用插件，而 generatorConfig.xml 中需要指定 jdbcDriver 的值，而 jdbcDriver 的值又需要 mysql-connector-java 这个依赖包，因此不能将依赖包放在插件的外面，而是要将这个依赖包加到插件中来，这样插件启动的时候才能找到 jdbc 驱动。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/MBG-Maven%E6%96%B9%E5%BC%8F%E5%8F%82%E6%95%B0.1c6y9ycmtyu8.webp" alt="MBG-Maven方式参数"></p><p>可选参数如下：</p><table><thead><tr><th align="left">参数名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">configurationFile</td><td align="left">MBG 配置文件的位置，默认值为 ${basedir}&#x2F;src&#x2F;main&#x2F;resources&#x2F;generatorConfig.xml</td></tr><tr><td align="left">contexts</td><td align="left">和 tableNames 使用方法一致</td></tr><tr><td align="left">jdbcDriver</td><td align="left">数据库驱动</td></tr><tr><td align="left">jdbcPassword</td><td align="left">数据库密码</td></tr><tr><td align="left">jdbcURL</td><td align="left">数据库地址</td></tr><tr><td align="left">jdbcUserId</td><td align="left">数据库用户名</td></tr><tr><td align="left">outputDirectory</td><td align="left">MBG 生成的新文件被放置的目录，当 targetProject 被指定为“MAVEN”（大小写敏感）时用到，默认值为 ${project.build.directory}&#x2F;generated-sources&#x2F;mybatis-generator</td></tr><tr><td align="left">overwrite</td><td align="left">默认值为 false。①如果为真，那么如果现有的 Java 文件与生成的文件具有相同的名称，现有的 Java 文件将被覆盖；②如果没有指定或者为假，并且已经存在与生成的文件同名的 Java 文件，那么 MBG 将新生成唯一的名称，与旧文件写入同一目录；③MBG 总是会合并和覆盖旧 XML 文件</td></tr><tr><td align="left">sqlScript</td><td align="left">生成代码之前要运行的 SQL 脚本文件的位置，值可以指定为文件系统中的一个位置，如果前缀为“classpath”，则可以指定构建类路径上的一个位置。①如果为null，则不运行任何脚本；②如果不为空，则还必须提供 jdbcDriver、jdbcURL等</td></tr><tr><td align="left">tableNames</td><td align="left">指定哪些表需要生成代码（注意需要和 generatorConfig.xml 中 table 标签指定的表名一致，即必须要在该文件中找到这个表名，找不到或者名字错误均不生成代码），不指定则为 generatorConfig.xml 中所有 table 标签指定的表生成代码</td></tr><tr><td align="left">verbose</td><td align="left">如果为真，则 MBG 将把进度消息写入构建日志</td></tr><tr><td align="left">includeCompileDependencies</td><td align="left">如果为真，那么范围为”compile”， “provided”和”system”的依赖项将被添加到生成器的类路径中</td></tr><tr><td align="left">includeAllDependencies</td><td align="left">如果为真，那么任何作用域的依赖项都将添加到生成器的类路径中</td></tr></tbody></table><p><code>targetProject 属性备注</code>：<br>当使用 Maven 运行时，生成器对配置的 targetProject 属性的解释是不同的。如果设置为特殊值”MAVEN”(区分大小写)，则 targetProject 将被设置为插件的输出目录（outputDirectory），如果该目录不存在，则会创建该目录。如果没有设置为”MAVEN”，那么 targetProject 将被 MBG 解释为常规目录，它必须被设置为一个已经存在的目录。</p><p><code>使用方法</code>：<br>首先在 <code>generator.properties</code> 中配置好数据库连接信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClass=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.connectionURL=jdbc:mysql://localhost:3306/mbg?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">jdbc.userId=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><p>编写好 <code>generatorConfig.xml</code> 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;generator.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;mbg1&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;$&#123;jdbc.connectionURL&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;$&#123;jdbc.userId&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;nullCatalogMeansCurrent&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成的实体类位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.lsj.model&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成的 Mapper.xml 映射文件位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.lsj.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成的 Mapper 接口位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.lsj.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;fb_score&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;mbg2&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;$&#123;jdbc.connectionURL&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;$&#123;jdbc.userId&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;nullCatalogMeansCurrent&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成的实体类位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.lsj.model&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成的 Mapper.xml 映射文件位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.lsj.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成的 Mapper 接口位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.lsj.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;fb_player&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后运行插件生成结果：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/MBG%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95.wdxfiurxmkg.webp" alt="MBG生成目录"></p><p>插件：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/MBG%E6%8F%92%E4%BB%B6.1bh4x8qubcl.webp" alt="MBG插件"></p><h2 id="2-2、Java-代码方式"><a href="#2-2、Java-代码方式" class="headerlink" title="2.2、Java 代码方式"></a>2.2、Java 代码方式</h2><p>编写一个 MBG 启动类，指定配置文件即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MBG</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> XMLParserException, IOException, InvalidConfigurationException, SQLException, InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; warnings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">overwrite</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> MBG.class.getResourceAsStream(<span class="string">&quot;/generatorConfig.xml&quot;</span>);</span><br><span class="line">        <span class="type">ConfigurationParser</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationParser</span>(warnings);</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> cp.parseConfiguration(is);</span><br><span class="line">        <span class="type">DefaultShellCallback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShellCallback</span>(overwrite);</span><br><span class="line">        <span class="type">MyBatisGenerator</span> <span class="variable">myBatisGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBatisGenerator</span>(config, callback, warnings);</span><br><span class="line">        myBatisGenerator.generate(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>同样需要注意的是</code>：这次要将 mysql-connector-java 这个依赖包放在外面，因为此时没有直接使用到 MBG 插件。</p><p>这样的话，实体类、Mapper 接口、Mapper 映射文件就都自动生成了，接下来就是配置 mybatis.mapper-locations 和 @MapperScan 来扫描接口和映射文件了，这一部分和不使用 MBG 的步骤一致，不再赘述。</p><h1 id="3、生成代码过程详解"><a href="#3、生成代码过程详解" class="headerlink" title="3、生成代码过程详解"></a>3、生成代码过程详解</h1><p>MBG 根据 targetRuntime 属性的配置生成不同的对象。具体有 MyBatis3DynamicSql（推荐）、MyBatis3 或 MyBatis3Simple（传统）这三种。</p><h2 id="3-1、使用-MyBatis-Dynamic-SQL-生成对象"><a href="#3-1、使用-MyBatis-Dynamic-SQL-生成对象" class="headerlink" title="3.1、使用 MyBatis Dynamic SQL 生成对象"></a>3.1、使用 MyBatis Dynamic SQL 生成对象</h2><p>即使用 MyBatis3DynamicSql。<br>这种情况下，对于每一个表，MBG 生成三个类：</p><ul><li>一个 <code>Record 类</code>代表数据库表的一行记录（即我们通常意义上的实体类）</li><li>一个 <code>Support 类</code>包括表和所有列的定义（主要用于 Mapper 接口中拼接 where 子句）</li><li>一个 <code>Mapper 接口</code>带有所有通用 SQL 方法</li></ul><p>关于生成的代码，还有几点要说明：</p><ul><li><code>没有 XML 文件生成</code></li><li><code>没有单独的&quot;Example&quot;类生成</code></li><li><code>没有单独的处理“BLOB”字段的方法</code></li><li><code>生成的实体类总是采用“flat”模式，即只生成一个 Record 类，不含主键类和 Record With BLOB 类</code></li></ul><h3 id="3-1-1、Support-类的形式"><a href="#3-1-1、Support-类的形式" class="headerlink" title="3.1.1、Support 类的形式"></a>3.1.1、Support 类的形式</h3><p>每一个表都有一个”Support”类，这个类包括表和所有列的定义。这些定义通常用于 Mapper 中某些 SQL 语句的输入——最常<code>用于 where 子句的输入</code>。<br>示例：有一个“TABLE_CODE”表，模式为”MYSCHEMA”，其中有”ID”和“DESCRIPTION”两个字段，那么，最后生成的 support 类将是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lsj.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.JDBCType;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Generated;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.dynamic.sql.AliasableSqlTable;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.dynamic.sql.SqlColumn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Mybatis3dynamicsqlDynamicSqlSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.194+08:00&quot;, comments=&quot;Source Table: mybatis3dynamicsql&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Mybatis3dynamicsql</span> <span class="variable">mybatis3dynamicsql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mybatis3dynamicsql</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.194+08:00&quot;, comments=&quot;Source field: mybatis3dynamicsql.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SqlColumn&lt;Integer&gt; id = mybatis3dynamicsql.id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.194+08:00&quot;, comments=&quot;Source field: mybatis3dynamicsql.description&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SqlColumn&lt;String&gt; description = mybatis3dynamicsql.description;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.194+08:00&quot;, comments=&quot;Source Table: mybatis3dynamicsql&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Mybatis3dynamicsql</span> <span class="keyword">extends</span> <span class="title class_">AliasableSqlTable</span>&lt;Mybatis3dynamicsql&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> SqlColumn&lt;Integer&gt; id = column(<span class="string">&quot;id&quot;</span>, JDBCType.INTEGER);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> SqlColumn&lt;String&gt; description = column(<span class="string">&quot;description&quot;</span>, JDBCType.VARCHAR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Mybatis3dynamicsql</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="string">&quot;mybatis3dynamicsql&quot;</span>, Mybatis3dynamicsql::<span class="keyword">new</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper 接口是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lsj.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.lsj.mapper.Mybatis3dynamicsqlDynamicSqlSupport.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mybatis.dynamic.sql.SqlBuilder.isEqualTo;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mybatis3dynamicsqlMapper</span> <span class="keyword">extends</span> <span class="title class_">CommonCountMapper</span>, CommonDeleteMapper, CommonInsertMapper&lt;Mybatis3dynamicsql&gt;, CommonUpdateMapper &#123;</span><br><span class="line">    <span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.203+08:00&quot;, comments=&quot;Source Table: mybatis3dynamicsql&quot;)</span></span><br><span class="line">    BasicColumn[] selectList = BasicColumn.columnList(id, description);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.195+08:00&quot;, comments=&quot;Source Table: mybatis3dynamicsql&quot;)</span></span><br><span class="line">    <span class="meta">@SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)</span></span><br><span class="line">    <span class="meta">@Results(id=&quot;Mybatis3dynamicsqlResult&quot;, value = &#123;</span></span><br><span class="line"><span class="meta">        @Result(column=&quot;id&quot;, property=&quot;id&quot;, jdbcType=JdbcType.INTEGER, id=true),</span></span><br><span class="line"><span class="meta">        @Result(column=&quot;description&quot;, property=&quot;description&quot;, jdbcType=JdbcType.VARCHAR)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    List&lt;Mybatis3dynamicsql&gt; <span class="title function_">selectMany</span><span class="params">(SelectStatementProvider selectStatement)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.198+08:00&quot;, comments=&quot;Source Table: mybatis3dynamicsql&quot;)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Integer id_)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> delete(c -&gt; </span><br><span class="line">            c.where(id, isEqualTo(id_))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目结构是这样的：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/Mybatis3dynamicsql%E7%A4%BA%E4%BE%8B.ypx2ar9wh80.webp" alt="Mybatis3dynamicsql示例"></p><p>这个”Support”类中的”id”和“description”就对应数据库表中的”id”和“description”，Mapper 接口中用到 where 子句时就可以先把这个类导进来，然后直接使用这两个属性了，就不用又重新定义对象，再通过对象调用属性了。</p><h3 id="3-1-2、Mapper-接口的使用"><a href="#3-1-2、Mapper-接口的使用" class="headerlink" title="3.1.2、Mapper 接口的使用"></a>3.1.2、Mapper 接口的使用</h3><p>使用 MyBatis3DynamicSQL 时<code>没有“by example”方法生成</code>，取而代之的是一些可以<code>用 lamda 表达式代替 where 子句</code>的方法。数据处理时可以直接用 lamda 表达式调用下列通用方法，也可以直接使用 Support 类提供的写好了的方法。<br>MBG 将创建下列通用方法：</p><ul><li>count</li><li>delete</li><li>select</li><li>selectDistinct</li><li>selectOne</li><li>update</li></ul><p>每个方法都能在调用时通过 lamda 表达式动态指定附加条件来取代 where 子句。<br>例如：通过 count 方法计算表中的记录数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">totalRows</span> <span class="operator">=</span> mapper.count(c -&gt; c);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"> <span class="type">long</span> <span class="variable">totalRows</span> <span class="operator">=</span> mapper.count(CountDSLCompleter.allRows());</span><br></pre></td></tr></table></figure><p>select 语句示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TableCode&gt; allRecords = mapper.select(c -&gt; c);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">List&lt;TableCode&gt; allRecords = mapper.select(SelectDSLCompleter.allRows());</span><br></pre></td></tr></table></figure><p>当然也可以将 where 子句加进来，但是要使用到上一节提到的”Support”类和“SqlBuilder”类，然后就可以编写任意复杂的 where 子句和 order by 子句。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.198+08:00&quot;, comments=&quot;Source Table: mybatis3dynamicsql&quot;)</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Integer id_)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> delete(c -&gt; </span><br><span class="line">        c.where(id, isEqualTo(id_))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update 语句示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lsj.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.lsj.mapper.Mybatis3dynamicsqlDynamicSqlSupport.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mybatis.dynamic.sql.SqlBuilder.isEqualTo;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mybatis3dynamicsqlMapper</span> <span class="keyword">extends</span> <span class="title class_">CommonCountMapper</span>, CommonDeleteMapper, CommonInsertMapper&lt;Mybatis3dynamicsql&gt;, CommonUpdateMapper &#123;</span><br><span class="line">    <span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.205+08:00&quot;, comments=&quot;Source Table: mybatis3dynamicsql&quot;)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(UpdateDSLCompleter completer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MyBatis3Utils.update(<span class="built_in">this</span>::update, mybatis3dynamicsql, completer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.206+08:00&quot;, comments=&quot;Source Table: mybatis3dynamicsql&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> UpdateDSL&lt;UpdateModel&gt; <span class="title function_">updateAllColumns</span><span class="params">(Mybatis3dynamicsql row, UpdateDSL&lt;UpdateModel&gt; dsl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dsl.set(id).equalTo(row::getId)</span><br><span class="line">                .set(description).equalTo(row::getDescription);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.206+08:00&quot;, comments=&quot;Source Table: mybatis3dynamicsql&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> UpdateDSL&lt;UpdateModel&gt; <span class="title function_">updateSelectiveColumns</span><span class="params">(Mybatis3dynamicsql row, UpdateDSL&lt;UpdateModel&gt; dsl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dsl.set(id).equalToWhenPresent(row::getId)</span><br><span class="line">                .set(description).equalToWhenPresent(row::getDescription);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.207+08:00&quot;, comments=&quot;Source Table: mybatis3dynamicsql&quot;)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(Mybatis3dynamicsql row)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> update(c -&gt;</span><br><span class="line">            c.set(description).equalTo(row::getDescription)</span><br><span class="line">            .where(id, isEqualTo(row::getId))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Generated(value=&quot;org.mybatis.generator.api.MyBatisGenerator&quot;, date=&quot;2022-07-31T15:55:56.207+08:00&quot;, comments=&quot;Source Table: mybatis3dynamicsql&quot;)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">updateByPrimaryKeySelective</span><span class="params">(Mybatis3dynamicsql row)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> update(c -&gt;</span><br><span class="line">            c.set(description).equalToWhenPresent(row::getDescription)</span><br><span class="line">            .where(id, isEqualTo(row::getId))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-5、新插件"><a href="#3-1-5、新插件" class="headerlink" title="3.1.5、新插件"></a>3.1.5、新插件</h3><p>因为“*ByExample”方法已经被移除了，因此通过 XML 文件中的 &lt;table&gt; 元素中的属性（如 &lt;enableInsert&gt;，&lt;enableSelectByExample&gt; 等）来控制生成的方法已经没有意义了，这时候可以使用 MBG 提供的新插件来控制：</p><ul><li><code>org.mybatis.generator.plugins.dsql.DisableDeletePlugin</code>：不生成删除方法</li><li><code>org.mybatis.generator.plugins.dsql.DisableInsertPlugin</code>：不生成插入方法</li><li><code>org.mybatis.generator.plugins.dsql.DisableUpdatePlugin</code>：不生成更新方法</li><li><code>org.mybatis.generator.plugins.dsql.ReadOnlyPlugin</code>：：不生成所有删除、插入、更新方法</li></ul><h2 id="3-2、使用传统方式生成对象"><a href="#3-2、使用传统方式生成对象" class="headerlink" title="3.2、使用传统方式生成对象"></a>3.2、使用传统方式生成对象</h2><p>即使用 MyBatis3 或 MyBatis3Simple。<br>这种情况下，对于每一个表，MBG 生成三个对象：</p><ul><li>一个 <code>实体类</code></li><li>一个 <code>Mapper.xml</code></li><li>一个 <code>Mapper 接口</code></li><li>一个 <code>Example 类</code></li></ul><h3 id="3-2-1、实体类"><a href="#3-2-1、实体类" class="headerlink" title="3.2.1、实体类"></a>3.2.1、实体类</h3><p>根据 &lt;context&gt; 元素中子元素 <code>&lt;defaultModelType&gt;</code> 的值或者 &lt;table&gt; 元素中子元素 <code>&lt;modelType&gt;</code> 值的不同，MBG 会生成不同的类。</p><h4 id="3-2-1-1、主键类"><a href="#3-2-1-1、主键类" class="headerlink" title="3.2.1.1、主键类"></a>3.2.1.1、主键类</h4><p>该类将包含表主键每个字段的属性。</p><h4 id="3-2-1-2、Record-类"><a href="#3-2-1-2、Record-类" class="headerlink" title="3.2.1.2、Record 类"></a>3.2.1.2、Record 类</h4><p>该类将包含表中非 BLOB 字段和非主键字段的属性。如果有主键类的话将扩展主键类。</p><h4 id="3-2-1-3、Record-With-BLOBs-类"><a href="#3-2-1-3、Record-With-BLOBs-类" class="headerlink" title="3.2.1.3、Record With BLOBs 类"></a>3.2.1.3、Record With BLOBs 类</h4><p>该类将包含表中每个 BLOB 字段的属性。如果有 Record 类，它将扩展 Record 类；如果只有主键类，它将扩展主键类。<br>上述三种类通常会一层一层扩展，最后合并为一个实体类，例如：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/Model%E7%B1%BB%E7%A4%BA%E4%BE%8B.48jndgopqhs0.webp" alt="Model类示例"></p><h4 id="3-2-1-4、Example-类"><a href="#3-2-1-4、Example-类" class="headerlink" title="3.2.1.4、Example 类"></a>3.2.1.4、Example 类</h4><p>该类<code>用于为以下方法构造动态 where 子句</code>：</p><ul><li>selectByExample</li><li>selectByExampleWithBLOBs</li><li>deleteByExample</li><li>countByExample</li><li>updateByExample</li></ul><p>该类不会扩展任何其他实体类。如果启用了任何<code>“*ByExample”方法</code>，就会生成这个类。<br>例如：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/Example%E7%B1%BB%E7%A4%BA%E4%BE%8B.20isf489iwn4.webp" alt="Example类示例"></p><p>具体使用见<a href="#3.2.4">3.2.4</a></p><h3 id="3-2-2、Mapper-映射文件"><a href="#3-2-2、Mapper-映射文件" class="headerlink" title="3.2.2、Mapper 映射文件"></a>3.2.2、Mapper 映射文件</h3><p>MBG 将为每个指定的表生成一个不同的 SQL Map 文件。SQL Map 的名称空间是表的名称(如果存在模式和目录，则由模式和目录限定)。MBG 不会将 SQL Map 条目添加到 MyBatis 配置文件中——必须手动完成这一操作（MyBatis.mapper-locations）。注意：每个新生成的 Mapper 文件都将覆盖旧文件。</p><h4 id="3-2-2-1、Result-Map"><a href="#3-2-2-1、Result-Map" class="headerlink" title="3.2.2.1、Result Map"></a>3.2.2.1、Result Map</h4><p>此元素用于指定表字段类型和生成类的属性类型的映射规则。<br>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.lsj.model.FbPlayer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;nationality&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;nationality&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;club&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;club&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2-2、带-BLOB-字段的-Result-Map"><a href="#3-2-2-2、带-BLOB-字段的-Result-Map" class="headerlink" title="3.2.2.2、带 BLOB 字段的 Result Map"></a>3.2.2.2、带 BLOB 字段的 Result Map</h4><p>添加 BLOB 字段类型的映射规则。</p><h4 id="3-2-2-3、where-子句"><a href="#3-2-2-3、where-子句" class="headerlink" title="3.2.2.3、where 子句"></a>3.2.2.3、where 子句</h4><p>此元素包含一个可重用的 where 子句，由“by example”方法使用。where 子句中将不包含任何 BLOB 字段。如果启用了任何“by example”语句，就会生成此元素。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/where%E5%AD%90%E5%8F%A5.4kajvmapoe00.webp" alt="where子句"></p><h4 id="3-2-2-4、Select-By-Primary-Key、Select-by-Example、Select-by-Example-With-BLOBs、Insert、Insert-Selective、Update-By-Primary-Key、Update-By-Primary-Key-With-BLOBs、Update-By-Primary-Key-Selective、Delete-By-Primary-Key、Delete-By-Example、Count-By-Example、Update-By-Example、Update-By-Example-With-BLOBs、Update-By-Example-Selective"><a href="#3-2-2-4、Select-By-Primary-Key、Select-by-Example、Select-by-Example-With-BLOBs、Insert、Insert-Selective、Update-By-Primary-Key、Update-By-Primary-Key-With-BLOBs、Update-By-Primary-Key-Selective、Delete-By-Primary-Key、Delete-By-Example、Count-By-Example、Update-By-Example、Update-By-Example-With-BLOBs、Update-By-Example-Selective" class="headerlink" title="3.2.2.4、Select By Primary Key、Select by Example、Select by Example With BLOBs、Insert、Insert Selective、Update By Primary Key、Update By Primary Key With BLOBs、Update By Primary Key Selective、Delete By Primary Key、Delete By Example、Count By Example、Update By Example、Update By Example With BLOBs、Update By Example Selective"></a>3.2.2.4、Select By Primary Key、Select by Example、Select by Example With BLOBs、Insert、Insert Selective、Update By Primary Key、Update By Primary Key With BLOBs、Update By Primary Key Selective、Delete By Primary Key、Delete By Example、Count By Example、Update By Example、Update By Example With BLOBs、Update By Example Selective</h4><p>看名字就知道，条件 CRUD 方法。</p><h3 id="3-2-3、Mapper-接口"><a href="#3-2-3、Mapper-接口" class="headerlink" title="3.2.3、Mapper 接口"></a>3.2.3、Mapper 接口</h3><p>Mapper 接口将生成如下方法：</p><ul><li>countByExample</li><li>deleteByPrimaryKey</li><li>deleteByExample</li><li>insert</li><li>insertSelective</li><li>selectByPrimaryKey</li><li>selectByExample</li><li>selectByExampleWithBLOBs</li><li>updateByPrimaryKey</li><li>updateByPrimaryKeySelective</li><li>updateByExample</li><li>updateByExampleSelective</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">MyTableMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(MyTableMapper.class);</span><br><span class="line">    List&lt;MyTable&gt; allRecords = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="3.2.4"></a></p><h3 id="3-2-4、Example-类的使用"><a href="#3-2-4、Example-类的使用" class="headerlink" title="3.2.4、Example 类的使用"></a>3.2.4、Example 类的使用</h3><p>Example 类指定如何构建动态 where 子句，表中的每个非 BLOB 列都可以有选择地包含在 where 子句中。<br>Example 类包含一个名为 Criteria 的静态内部类，该类保存了将在 where 子句中组合在一起的条件列表。使用不同的 Criteria 类集可以生成几乎无限种 where 子句类型。<br><code>具体来说就是构建 where 子句时需要调用 GeneratedCriteria 内部类中的 addxxx 方法，而每调用一次都会将之后 where 子句中要用到的 condition 和 value 加入到 criteria 对象列表中，最后解析 xml 文件时就可以获取到对应的 condition 和 value 了，也就完成了 where 子句的构建。</code></p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/where%E5%AD%90%E5%8F%A5%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B.75cow4ht7z80.webp" alt="where子句构造过程"></p><p>Criteria 对象可以使用 <code>createCriteria</code> 方法或 Example 类中的 <code>or</code> 方法创建。当使用 createCriteria 方法创建第一个 Criteria 对象时，它会被自动添加到 Criteria 对象列表中——这使得编写一个简单的 where 子句或组合多个子句变得很容易。当使用 or 方法时，Criteria 对象将被添加到所有实例列表中。<br>建议使用 or 方法来创建 Criteria 对象，这种方法可以使代码更具可读性。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/Example%E7%B1%BB%E7%BB%93%E6%9E%84.6fruthlk3jg0.webp" alt="Example类结构"></p><h4 id="3-2-4-1、简单查询"><a href="#3-2-4-1、简单查询" class="headerlink" title="3.2.4.1、简单查询"></a>3.2.4.1、简单查询</h4><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TestTableExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestTableExample</span>();</span><br><span class="line">example.createCriteria().andField1EqualTo(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">TestTableExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestTableExample</span>();</span><br><span class="line">example.or().andField1EqualTo(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这两种方法创建的 where 子句等同于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> field1 <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="3-2-4-2、复杂查询"><a href="#3-2-4-2、复杂查询" class="headerlink" title="3.2.4.2、复杂查询"></a>3.2.4.2、复杂查询</h4><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TestTableExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestTableExample</span>();</span><br><span class="line"></span><br><span class="line">  example.or()</span><br><span class="line">    .andField1EqualTo(<span class="number">5</span>)</span><br><span class="line">    .andField2IsNull();</span><br><span class="line"></span><br><span class="line">  example.or()</span><br><span class="line">    .andField3NotEqualTo(<span class="number">9</span>)</span><br><span class="line">    .andField4IsNotNull();</span><br><span class="line"></span><br><span class="line">  List&lt;Integer&gt; field5Values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">  field5Values.add(<span class="number">8</span>);</span><br><span class="line">  field5Values.add(<span class="number">11</span>);</span><br><span class="line">  field5Values.add(<span class="number">14</span>);</span><br><span class="line">  field5Values.add(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">  example.or()</span><br><span class="line">    .andField5In(field5Values);</span><br><span class="line"></span><br><span class="line">  example.or()</span><br><span class="line">    .andField6Between(<span class="number">3</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure><p>这种方法创建的 where 子句等同于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> (field1 <span class="operator">=</span> <span class="number">5</span> <span class="keyword">and</span> field2 <span class="keyword">is</span> <span class="keyword">null</span>)</span><br><span class="line">   <span class="keyword">or</span> (field3 <span class="operator">&lt;&gt;</span> <span class="number">9</span> <span class="keyword">and</span> field4 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>)</span><br><span class="line">   <span class="keyword">or</span> (field5 <span class="keyword">in</span> (<span class="number">8</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">22</span>))</span><br><span class="line">   <span class="keyword">or</span> (field6 <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h4 id="3-2-4-3、差异查询"><a href="#3-2-4-3、差异查询" class="headerlink" title="3.2.4.3、差异查询"></a>3.2.4.3、差异查询</h4><p>可以通过调用 Example 类的 setDistinct(true) 方法强制查询为 DISTINCT。</p><h4 id="3-2-4-4、Criteria-类"><a href="#3-2-4-4、Criteria-类" class="headerlink" title="3.2.4.4、Criteria 类"></a>3.2.4.4、Criteria 类</h4><p>Criteria 内部类包含针对每个字段的 andXXX 方法：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/Criteria%E7%B1%BB.mask8qxiuyo.webp" alt="Criteria类"></p><p>标准SQL谓词包括：</p><ul><li>IS NULL</li><li>IS NOT NULL</li><li>&#x3D; (equal)</li><li>&lt;&gt; (not equal)</li><li>&gt; (greater than)</li><li>&gt;&#x3D; (greater than or equal) </li><li>&lt; (less than)</li><li>&lt;&#x3D; (less than or equal)</li><li>LIKE</li><li>NOT LIKE</li><li>BETWEEN</li><li>NOT BETWEEN</li><li>IN</li><li>NOT IN</li></ul><h3 id="3-2-5、扩展-Example-类"><a href="#3-2-5、扩展-Example-类" class="headerlink" title="3.2.5、扩展 Example 类"></a>3.2.5、扩展 Example 类</h3><p>可以通过编写插件或者继承<code>org.mybatis.generator.plugins.CaseInsensitiveLikePlugin</code>类来扩展 Example 类。<br>MBG 生成的 SQL 片段支持四种类型的 SQL 谓词。对于每种 SQL 谓词类型，在 GeneratedCriteria 内部类中都有一个对应的方法，可用于将谓词添加到动态 where 子句中。</p><h4 id="3-2-5-1、Simple-String-Substitution（简单字符串替换）"><a href="#3-2-5-1、Simple-String-Substitution（简单字符串替换）" class="headerlink" title="3.2.5.1、Simple String Substitution（简单字符串替换）"></a>3.2.5.1、Simple String Substitution（简单字符串替换）</h4><p>当不需要将参数对象中的属性替换到 where 子句中时，使用该类型的谓词。<br>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIRST_NAME <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line">LAST_NAME <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>这种谓词对应的 GeneratedCriteria 类方法是<code>addCriterion(String anyString)</code>。<br>使用场景：假设你想使用 SOUNDEX 函数来执行“sounds like”的名称搜索。在MySQL中，谓词应该是这样的:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOUNDEX(FIRST_NAME) <span class="operator">=</span> SOUNDEX(<span class="string">&#x27;frod&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这个谓词太复杂，不能使用任何其他方法，因此必须通过简单字符串替换将它插入到 where 子句中。</p><p>①自定义方法，将对应谓词加入到 Criterion 对象列表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Criteria <span class="title function_">andFirstNameSoundsLike</span><span class="params">(String value)</span> &#123;</span><br><span class="line">  <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;SOUNDEX(FIRST_NAME) = SOUNDEX(&#x27;&quot;</span>);</span><br><span class="line">  sb.append(value);</span><br><span class="line">  sb.append(<span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  addCriterion(sb.toString());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CustomerExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerExample</span>();</span><br><span class="line"><span class="type">Criteria</span> <span class="variable">criteria</span> <span class="operator">=</span> example.createCriteria();</span><br><span class="line">criteria.andFirstNameSoundsLike(<span class="string">&quot;frod&quot;</span>);</span><br><span class="line"><span class="type">List</span> <span class="variable">results</span> <span class="operator">=</span> selectByExample(example);</span><br></pre></td></tr></table></figure><h4 id="3-2-5-2、Single-Parameter-Predicates（单一参数谓词）"><a href="#3-2-5-2、Single-Parameter-Predicates（单一参数谓词）" class="headerlink" title="3.2.5.2、Single Parameter Predicates（单一参数谓词）"></a>3.2.5.2、Single Parameter Predicates（单一参数谓词）</h4><p>当参数对象中有一个属性要代入 where 子句时，使用该谓词类型。<br>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIRST_NAME <span class="operator">=</span> ?</span><br><span class="line">LAST_NAME <span class="operator">&lt;&gt;</span> ?</span><br></pre></td></tr></table></figure><p>这种谓词对应的 Criteria 类方法是 <code>addCriterion(String anyString, Object anyObject, String propertyName)</code>。<br>使用场景：假设你想对某些列执行不区分大小写的搜索。在MySQL中，谓词看起来像这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">upper</span>(FIRST_NAME) <span class="keyword">like</span> ?</span><br></pre></td></tr></table></figure><p>此谓词符合单个参数谓词的功能——一个字符串值后跟一个参数。</p><p>①自定义方法，将对应谓词加入到 Criterion 对象列表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ExtendedCriteria <span class="title function_">andFirstNameLikeInsensitive</span><span class="params">(String value)</span> &#123;</span><br><span class="line">  addCriterion(<span class="string">&quot;upper(FIRST_NAME) like&quot;</span>,</span><br><span class="line">    value.toUpperCase(), <span class="string">&quot;firstName&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExtendedExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExtendedExample</span>();</span><br><span class="line"><span class="type">ExtendedCriteria</span> <span class="variable">criteria</span> <span class="operator">=</span> (ExtendedCriteria) example.createCriteria();</span><br><span class="line">criteria.andFirstNameLikeInsensitive(<span class="string">&quot;fred%&quot;</span>);</span><br><span class="line"><span class="type">List</span> <span class="variable">results</span> <span class="operator">=</span> selectByExample(example);</span><br></pre></td></tr></table></figure><h4 id="3-2-5-3、List-Predicates（列表谓词）"><a href="#3-2-5-3、List-Predicates（列表谓词）" class="headerlink" title="3.2.5.3、List Predicates（列表谓词）"></a>3.2.5.3、List Predicates（列表谓词）</h4><p>列表谓词用于将长度可变的列表作为参数添加到 where 子句中。<br>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIRST_NAME <span class="keyword">IN</span> (?, ?, ?)</span><br><span class="line">LAST_NAME <span class="keyword">NOT</span> <span class="keyword">IN</span> (?, ?, ?, ?)</span><br></pre></td></tr></table></figure><p>这种谓词对应的 Criteria 类方法是 <code>addCriterion(String anyString, List listOfObjects, String propertyName)</code>。</p><h4 id="3-2-5-3、Between-Predicates（区间谓词）"><a href="#3-2-5-3、Between-Predicates（区间谓词）" class="headerlink" title="3.2.5.3、Between Predicates（区间谓词）"></a>3.2.5.3、Between Predicates（区间谓词）</h4><p>区间谓词用于以特定格式向 where 子句添加两个参数。<br>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIRST_NAME <span class="keyword">BETWEEN</span> ? <span class="keyword">AND</span> ?</span><br><span class="line">LAST_NAME <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> ? <span class="keyword">AND</span> ?</span><br></pre></td></tr></table></figure><p>这种谓词对应的 Criteria 类方法是 <code>addCriterion(String anyString, Object object1, Object object2, String propertyName)</code>。</p><p>基本上 GeneratedCriteria 内部类或者其子类中都有相应谓词的对应方法，直接调用就行。没有的方法就需要自定义扩展。</p><h1 id="4、XML-配置参考"><a href="#4、XML-配置参考" class="headerlink" title="4、XML 配置参考"></a>4、XML 配置参考</h1><p>一个完整的 generatorConfig.xml 文件长这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;COM.ibm.db2.jdbc.app.DB2Driver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:db2:TEST&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">userId</span>=<span class="string">&quot;db2admin&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">password</span>=<span class="string">&quot;db2admin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaTypeResolver</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;test.model&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;\MBGTestProject\src&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;test.xml&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;\MBGTestProject\src&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;test.dao&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;\MBGTestProject\src&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">schema</span>=<span class="string">&quot;DB2ADMIN&quot;</span> <span class="attr">tableName</span>=<span class="string">&quot;ALLTYPES&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Customer&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useActualColumnNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">sqlStatement</span>=<span class="string">&quot;DB2&quot;</span> <span class="attr">identity</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">columnOverride</span> <span class="attr">column</span>=<span class="string">&quot;DATE_FIELD&quot;</span> <span class="attr">property</span>=<span class="string">&quot;startDate&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ignoreColumn</span> <span class="attr">column</span>=<span class="string">&quot;FRED&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">columnOverride</span> <span class="attr">column</span>=<span class="string">&quot;LONG_VARCHAR_FIELD&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>元素详解</code>：</p><h2 id="4-1、-lt-generatorConfiguration-gt"><a href="#4-1、-lt-generatorConfiguration-gt" class="headerlink" title="4.1、&lt;generatorConfiguration&gt;"></a>4.1、&lt;generatorConfiguration&gt;</h2><p>作用：配置文件顶层元素。<br>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-2、-lt-classPathEntry-gt"><a href="#4-2、-lt-classPathEntry-gt" class="headerlink" title="4.2、&lt;classPathEntry&gt;"></a>4.2、&lt;classPathEntry&gt;</h2><p>作用：用于将额外需要的依赖包加入到类路径中。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">location</td><td align="left">Y</td><td align="left">添加的依赖包的完全限定名</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-3、-lt-context-gt"><a href="#4-3、-lt-context-gt" class="headerlink" title="4.3、&lt;context&gt;"></a>4.3、&lt;context&gt;</h2><p>作用：用于指定根据数据库表生成实体类对象的环境，不可或缺。可以有多个。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">Y</td><td align="left">唯一标识该上下文</td></tr><tr><td align="left"><a id="defaultModelType"></a>defaultModelType</td><td align="left">N</td><td align="left">此属性用于为生成的模型类型设置默认值（只在 MyBatis3 下该属性才有效），该属性支持以下值：①condition（默认值）；②flat，该模型只生成一个 Record 类；③hierarchical，该模型生成一个 Record 类、一个主键类、一个 Record With BLOB 类（最后还是合并为一个类展现）</td></tr><tr><td align="left">targetRuntime</td><td align="left">N</td><td align="left">指定生成代码的运行时环境，有四种取值：①MyBatis3DynamicSql；②MyBatis3Kotlin；③MyBatis3；④MyBatis3Simple</td></tr><tr><td align="left">introspectedColumnImpl</td><td align="left">N</td><td align="left">用于扩展 MBG 的功能，必须继承<code>org.mybatis.generator.api.IntrospectedColumn</code></td></tr></tbody></table><p>子元素有：</p><ul><li>&lt;property&gt; (0..N)</li><li>&lt;plugin&gt; (0..N)</li><li>&lt;commentGenerator&gt; (0 or 1)</li><li>&lt;connectionFactory&gt; (either connectionFactory or jdbcConnection is Required)</li><li>&lt;jdbcConnection&gt; (either connectionFactory or jdbcConnection is Required)</li><li>&lt;javaTypeResolver&gt; (0 or 1)</li><li>&lt;javaModelGenerator&gt; (1 Required)</li><li>&lt;sqlMapGenerator&gt; (0 or 1)</li><li>&lt;javaClientGenerator&gt; (0 or 1)</li><li>&lt;table&gt; (1..N)</li></ul><p>子元素&lt;property&gt;中还可用如下属性：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">autoDelimitKeywords</td><td align="left">N</td><td align="left">自动给 SQL 关键字添加分隔符，如表名为 table A，中间有空格，那么执行 SQL 语句会报错，该属性会加上一个单引号’table A’</td></tr><tr><td align="left">beginningDelimiter</td><td align="left">N</td><td align="left">配置前置分隔符，默认值为”</td></tr><tr><td align="left">endingDelimiter</td><td align="left">N</td><td align="left">配置后置分隔符，默认值为”</td></tr><tr><td align="left">javaFileEncoding</td><td align="left">N</td><td align="left">指定处理 Java 文件时使用的编码</td></tr><tr><td align="left">javaFormatter</td><td align="left">N</td><td align="left">指定用来格式化 Java 程序的类，必须是全限定名，该类必须实现<code>org.mybatis.generator.api.javaformatter</code>，并且必须有一个默认无参构造函数。默认的Java格式化程序是<code>org.mybatis.generator.api.dom.defaultjavaformatter</code></td></tr><tr><td align="left">xmlFormatter</td><td align="left">N</td><td align="left">指定用来格式化 xml 文件的类，该类必须实现<code>org. mybatis.generator.api.xmlformatter</code>，并且必须有一个默认无参构造函数。默认的XML格式化程序是<code>org.mybatis.generator.api.dom.defaultxmlformatter</code></td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoDelimitKeywords&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beginningDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;endingDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javaFileEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javaFormatter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xmlFormatter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-4、-lt-columnOverride-gt"><a href="#4-4、-lt-columnOverride-gt" class="headerlink" title="4.4、&lt;columnOverride&gt;"></a>4.4、&lt;columnOverride&gt;</h2><p>作用：修改数据库中某些列对应的实体类属性值。如列名为 Java 关键字时就需要修改对应的实体类的属性值。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">Y</td><td align="left">列名</td></tr><tr><td align="left">property</td><td align="left">N</td><td align="left">修改后的实体类对象属性名</td></tr><tr><td align="left">javaType</td><td align="left">N</td><td align="left">类属性的 Java 数据类型，需要是全限定名</td></tr><tr><td align="left">jdbcType</td><td align="left">N</td><td align="left">列的 JDBC 类型(INTEGER, DECIMAL, NUMERIC, VARCHAR等)</td></tr><tr><td align="left">typeHandler</td><td align="left">N</td><td align="left">用于指定用户自定义的类型处理程序。这应该是实现 MyBatis 的 TypeHandler 接口的类的完全限定名。如果未指定，或者为空，那么 MyBatis 将使用默认类型。重要提示：MBG 不验证此类型处理程序是否存在或是否有效，MBG 只是将该值插入生成的 Mapper 配置文件中的适当位置</td></tr><tr><td align="left">delimitedColumnName</td><td align="left">N</td><td align="left">指定生成的映射文件中是否需要将对应的列用分隔符（默认为”）来明确标示出来，如列名为 column A，中间有空格，那么执行 SQL 语句会报错，该属性会加上一个双引号”column A”</td></tr><tr><td align="left">isGeneratedAlways</td><td align="left">N</td><td align="left">指定该列在数据库中是否为 GENERATED ALWAYS 列。如果列是 GENERATED ALWAYS，那么 MBG 将不会在插入或更新语句中引用该列</td></tr></tbody></table><p>子元素&lt;property&gt;中属性：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">forceJavaTypeIntoMapping</td><td align="left">N</td><td align="left">当为 true 时，该属性将把 JavaType 添加到元素中</td></tr><tr><td align="left">trimStrings</td><td align="left">N</td><td align="left">若数据库返回的字段中有空白部分，此属性可以对其进行特别填充</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--结果应为实体类的name属性被命名为name1, club被用&quot;&quot;明确标示出来，在插入或更新语句中没有nationality字段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;fb_player&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columnOverride</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">columnOverride</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columnOverride</span> <span class="attr">column</span>=<span class="string">&quot;club&quot;</span> <span class="attr">delimitedColumnName</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">columnOverride</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columnOverride</span> <span class="attr">column</span>=<span class="string">&quot;nationality&quot;</span> <span class="attr">isGeneratedAlways</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">columnOverride</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/columnOverride%E4%BD%BF%E7%94%A82.64o6v50qxvs0.webp" alt="columnOverride使用2"></p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/columnOverride%E4%BD%BF%E7%94%A8.15l29rknbzek.webp" alt="columnOverride使用"></p><h2 id="4-5、-lt-ignoreColumnsByRegex-gt"><a href="#4-5、-lt-ignoreColumnsByRegex-gt" class="headerlink" title="4.5、&lt;ignoreColumnsByRegex&gt;"></a>4.5、&lt;ignoreColumnsByRegex&gt;</h2><p>作用：通过正则表达式指定哪些列不需要包含在生成的 SQL 语句中。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">pattern</td><td align="left">Y</td><td align="left">正则表达式，指定匹配规则</td></tr></tbody></table><p>子元素&lt;except&gt;中属性：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">Y</td><td align="left">列名</td></tr><tr><td align="left">delimitedColumnName</td><td align="left">N</td><td align="left">①如果为 true，匹配列时会区分大小写；②如果为 false，匹配列时不区分大小写</td></tr></tbody></table><p>示例：</p><p>表结构：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/ignorecolumns%E8%A1%A8%E7%BB%93%E6%9E%84.3qybu4lr5xy0.webp" alt="ignorecolumns表结构"></p><p>generatorConfig.xml 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;ignorecolumns&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ignoreColumnsByRegex</span> <span class="attr">pattern</span>=<span class="string">&quot;column.*&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">except</span> <span class="attr">column</span>=<span class="string">&quot;column2&quot;</span> <span class="attr">delimitedColumnName</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">except</span> <span class="attr">column</span>=<span class="string">&quot;column3&quot;</span> <span class="attr">delimitedColumnName</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ignoreColumnsByRegex</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后结果中只会包含 column2 和 column3 列。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/ignoreColumnsByRegex%E7%A4%BA%E4%BE%8B.2n56o1oktwe0.webp" alt="ignoreColumnsByRegex示例"></p><h2 id="4-6、-lt-ignoreColumn-gt"><a href="#4-6、-lt-ignoreColumn-gt" class="headerlink" title="4.6、&lt;ignoreColumn&gt;"></a>4.6、&lt;ignoreColumn&gt;</h2><p>作用：直接通过列名指定哪些列不需要包含在生成的 SQL 语句中。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">Y</td><td align="left">列名</td></tr><tr><td align="left">delimitedColumnName</td><td align="left">N</td><td align="left">①如果为 true，匹配列时会区分大小写；②如果为 false，匹配列时不区分大小写</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;ignorecolumns&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ignoreColumn</span> <span class="attr">column</span>=<span class="string">&quot;column2&quot;</span> <span class="attr">delimitedColumnName</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后结果中只会包含 column1 和 column3 列。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/ignoreColumn%E7%A4%BA%E4%BE%8B.34w0pi7ovsg0.webp" alt="ignoreColumn示例"></p><h2 id="4-7、-lt-columnRenamingRule-gt"><a href="#4-7、-lt-columnRenamingRule-gt" class="headerlink" title="4.7、&lt;columnRenamingRule&gt;"></a>4.7、&lt;columnRenamingRule&gt;</h2><p>作用：类属性重命名规则，根据列生成类属性时先修改列名称（并不是真的把数据库里的列名改了）。适用于表中的列都有公用前缀的时候，为简化代码，生成的类属性可以消除这些前缀。根据 &lt;table&gt; 属性 useActualColumnNames 的取值不同有不同的表现。通过<code>java.util.regex.Matcher.replaceAll</code>方法实现。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">searchString</td><td align="left">Y</td><td align="left">这是一个正则表达式，它定义了要替换的字符串</td></tr><tr><td align="left">replaceString</td><td align="left">N</td><td align="left">用于替换的字符串，未指定则用空字符串替换</td></tr></tbody></table><p>示例：<br>表结构为：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/columnrenamingrule%E8%A1%A8%E7%BB%93%E6%9E%84.57pi39cx70w0.webp" alt="columnrenamingrule表结构"></p><p>generatorConfig.xml 文件定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;columnrenamingrule&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useActualColumnNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columnRenamingRule</span> <span class="attr">searchString</span>=<span class="string">&quot;^CUST_&quot;</span> <span class="attr">replaceString</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 useActualColumnNames 属性为 true 时，结果为：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/columnrenamingrule%E4%BD%BF%E7%94%A81.kcs9zu8gdfk.webp" alt="columnrenamingrule使用1"></p><p>当 useActualColumnNames 属性为 false 时，结果为：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/columnrenamingrule%E4%BD%BF%E7%94%A82.khvymbx1co.webp" alt="columnrenamingrule使用2"></p><h2 id="4-8、-lt-domainObjectRenamingRule-gt"><a href="#4-8、-lt-domainObjectRenamingRule-gt" class="headerlink" title="4.8、&lt;domainObjectRenamingRule&gt;"></a>4.8、&lt;domainObjectRenamingRule&gt;</h2><p>作用：类重命名规则，根据表名生成类时先修改表名（并不是真的把数据库的表名改了）。适用于多张表有公用前缀的时候，为简化代码，生成的类可以消除这些前缀。通过<code>java.util.regex.Matcher.replaceAll</code>方法实现。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">searchString</td><td align="left">Y</td><td align="left">这是一个正则表达式，它定义了要替换的字符串</td></tr><tr><td align="left">replaceString</td><td align="left">N</td><td align="left">用于替换的字符串，未指定则用空字符串替换</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;sys_user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">domainObjectRenamingRule</span> <span class="attr">searchString</span>=<span class="string">&quot;^Sys&quot;</span> <span class="attr">replaceString</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当表名为 sys_user 时，默认生成的实体类名为 SysUser；当设置了 domainObjectRenamingRule 规则并定义了替换规则时，生成的实体类名为 User：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/domainObjectRenamingRule%E4%BD%BF%E7%94%A8.3mydh9boh2g0.webp" alt="domainObjectRenamingRule使用"></p><h2 id="4-9、-lt-commentGenerator-gt"><a href="#4-9、-lt-commentGenerator-gt" class="headerlink" title="4.9、&lt;commentGenerator&gt;"></a>4.9、&lt;commentGenerator&gt;</h2><p>作用：commentGenerator，顾名思义，为注释生成器，即用来自定义注释。默认实现为<code>org.mybatis.generator.internal.DefaultCommentGenerator</code>。可以用来为字段添加注解，如用到 Swagger 时添加 @ApiModelProperty。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">N</td><td align="left">自定义的注释生成器的类型，必须实现<code>org.mybatis.generator.api.CommentGenerator</code>接口，并且要有一个公共的默认构造函数</td></tr></tbody></table><p>子元素&lt;property&gt;中属性：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">suppressAllComments</td><td align="left">N</td><td align="left">此属性用于指定 MBG 是否将在生成的代码中包含任何注释。该属性支持以下值：①为 true 时任何生成的元素都不会添加注释；②为 false 或不指定时，所有生成的元素都会添加注释。默认值为 false</td></tr><tr><td align="left">suppressDate</td><td align="left">N</td><td align="left">此属性用于指定 MBG 是否将在生成的注释中包含生成时间戳。该属性支持以下值：①为 true 时生成的注释中不会添加时间戳；②为 false 或不指定时，所有生成的注释将包括生成元素时的时间戳。默认值为 false</td></tr><tr><td align="left">addRemarkComments</td><td align="left">N</td><td align="left">此属性用于指定 MBG 是否将在生成的注释中包括数据库中表和列的备注。该属性支持以下值：①为 true 时，表和列的备注将被添加到生成的注释中；②为 false 或未指定时，所有生成的注释在生成元素时将不包括表和列的备注。默认值为 false。如果 suppressAllComments 选项为 true，则该选项将被忽略</td></tr><tr><td align="left">dateFormat</td><td align="left">N</td><td align="left">在将日期写入生成的注释时使用的日期格式字符串。这个字符串将被用来构造一个<code>java.text.SimpleDateFormat</code>对象，该对象的任何有效格式字符串都可以在这里指定。默认情况下，日期字符串将来自<code>java.util.Date</code>上的 toString() 方法。如果 suppressAllComments 选项或者 suppressDate 选项为 true，该选项将被忽略</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyCommentGenerator继承了DefaultCommentGenerator类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">commentGenerator</span> <span class="attr">type</span>=<span class="string">&quot;MyCommentGenerator&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addRemarkComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-10、-lt-connectionFactory-gt"><a href="#4-10、-lt-connectionFactory-gt" class="headerlink" title="4.10、&lt;connectionFactory&gt;"></a>4.10、&lt;connectionFactory&gt;</h2><p>作用：用于指定一个连接工厂来维持数据库连接。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">N</td><td align="left">用来指定连接工厂的类型。自定义类型必须实现接口<code>org.mybatis.generator.api.connectionfactory</code>，并且必须有一个公共默认构造函数</td></tr></tbody></table><p>子元素&lt;property&gt;中属性：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">driverClass</td><td align="left">N</td><td align="left">数据库驱动</td></tr><tr><td align="left">connectionURL</td><td align="left">N</td><td align="left">数据库地址</td></tr><tr><td align="left">userId</td><td align="left">N</td><td align="left">数据库用户名</td></tr><tr><td align="left">password</td><td align="left">N</td><td align="left">数据库密码</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">connectionFactory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionURL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mbg?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">connectionFactory</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-11、-lt-jdbcConnection-gt"><a href="#4-11、-lt-jdbcConnection-gt" class="headerlink" title="4.11、&lt;jdbcConnection&gt;"></a>4.11、&lt;jdbcConnection&gt;</h2><p>作用：指定数据库连接方式。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">driverClass</td><td align="left">Y</td><td align="left">数据库驱动</td></tr><tr><td align="left">connectionURL</td><td align="left">Y</td><td align="left">数据库地址</td></tr><tr><td align="left">userId</td><td align="left">N</td><td align="left">数据库用户名</td></tr><tr><td align="left">password</td><td align="left">N</td><td align="left">数据库密码</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">connectionURL</span>=<span class="string">&quot;$&#123;jdbc.connectionURL&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">userId</span>=<span class="string">&quot;$&#123;jdbc.userId&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">password</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：&lt;connectionFactory&gt; 和 &lt;jdbcConnection&gt; 只能有一个。</p><h2 id="4-12、-lt-generatedKey-gt"><a href="#4-12、-lt-generatedKey-gt" class="headerlink" title="4.12、&lt;generatedKey&gt;"></a>4.12、&lt;generatedKey&gt;</h2><p>作用：用于为数据库表中自动生成 id 的字段指定属性（identity 字段或者 sequences 序列）。如果该元素被指定，那么在 &lt;insert&gt; 元素中将包含一个 &lt;selectKey&gt; 子元素。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">Y</td><td align="left">列名</td></tr><tr><td align="left">sqlStatement</td><td align="left">Y</td><td align="left">语句类型。取值有：Cloudscape、DB2、DB2_MF、Derby、HSQLDB、Informix、MySql、SqlServer、SYBASE、JDBC</td></tr><tr><td align="left">identity</td><td align="left">N</td><td align="left">①如果为 true，则该列被标记为 identity 列，&lt;selectKey&gt; 元素将放置在 &lt;insert&gt; 元素之后；②如果为 false，则 &lt;selectKey&gt; 元素将放置在 &lt;insert&gt; 元素之前（通常用于 sequences 序列）。默认值为 false</td></tr><tr><td align="left">type</td><td align="left">N</td><td align="left">如果指定了，那么这个值将被添加到 &lt;selectKey&gt; 中。值为”pre”或”post”。如果为该属性指定了值，则生成的 &lt;selectKey&gt; 元素将始终放在 &lt;insert&gt; 元素之前</td></tr></tbody></table><p><code>备注：&lt;selectKey&gt; 用来获取自增 id 值，自增 id 由数据库管理，而有时插入等操作需要用到这个 id 值，这时 &lt;selectKey&gt; 就起作用了。</code><br>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;fb_player&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">sqlStatement</span>=<span class="string">&quot;MySql&quot;</span> <span class="attr">identity</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;post&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/generatedKey%E7%A4%BA%E4%BE%8B.6mc2kbgcvo40.webp" alt="generatedKey示例"></p><h2 id="4-13、-lt-javaClientGenerator-gt"><a href="#4-13、-lt-javaClientGenerator-gt" class="headerlink" title="4.13、&lt;javaClientGenerator&gt;"></a>4.13、&lt;javaClientGenerator&gt;</h2><p>作用：用于配置 Mapper 接口信息。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">Y</td><td align="left">Mapper 使用类型，决定是 XML 形式还是注解形式。①targetRuntime 为MyBatis3DynamicSql 和 MyBatis3Kotlin 时可忽略；②为 MyBatis3 时有 ANNOTATEDMAPPER、MIXEDMAPPER 和 XMLMAPPER 三种取值；③为 MyBatis3Simple 时有 ANNOTATEDMAPPER 和 XMLMAPPER 两种取值</td></tr><tr><td align="left">targetPackage</td><td align="left">Y</td><td align="left">指定 Mapper 接口所在包</td></tr><tr><td align="left">targetProject</td><td align="left">N</td><td align="left">指定 Mapper 接口所在项目路径</td></tr></tbody></table><p>子元素&lt;property&gt;中属性：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dynamicSqlSupportPackage</td><td align="left">N</td><td align="left">指定 MyBatis 动态 SQL Support 类的所在包</td></tr><tr><td align="left">enableSubPackages</td><td align="left">N</td><td align="left">指定是否根据表目录和模式来为接口生成包</td></tr><tr><td align="left">rootInterface</td><td align="left">N</td><td align="left">为所有生成的 Mapper 接口指定一个父接口</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.lsj.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-14、-lt-javaModelGenerator-gt"><a href="#4-14、-lt-javaModelGenerator-gt" class="headerlink" title="4.14、&lt;javaModelGenerator&gt;"></a>4.14、&lt;javaModelGenerator&gt;</h2><p>作用：用于配置实体类信息。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">targetPackage</td><td align="left">Y</td><td align="left">指定实体类所在包</td></tr><tr><td align="left">targetProject</td><td align="left">N</td><td align="left">指定实体类所在项目路径</td></tr></tbody></table><p>子元素&lt;property&gt;中属性：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">constructorBased</td><td align="left">N</td><td align="left">指定是否为类生成构造函数。若该属性被指定，则对象将通过构造函数构建，而不通过 setter 方法。如果”immutable”属性设置为”true”，则该属性将被忽略(并强制为”true”)</td></tr><tr><td align="left">enableSubPackages</td><td align="left">N</td><td align="left">指定是否根据表目录和模式来为实体类生成包</td></tr><tr><td align="left">exampleTargetPackage</td><td align="left">N</td><td align="left">用于为生成的 Example 类指定不同的包。如果没有指定，Example 类将与实体类在同一个包中生成。注意：这个属性在基于 MyBatis 动态 SQL 的运行时被忽略</td></tr><tr><td align="left">exampleTargetProject</td><td align="left">N</td><td align="left">用于为生成的 Example 类指定不同的项目路径。如果没有指定，Example 类将与实体类在同一个项目路径中生成。注意：这个属性在基于 MyBatis 动态 SQL 的运行时被忽略</td></tr><tr><td align="left">immutable</td><td align="left">N</td><td align="left">用于选择 MBG 是否会生成不可变的实体类——这意味着类将没有“setter”方法，构造函数将接受类中每个字段的值。如果为真，这将强制使用参数化构造函数构建实体类，而不管“constructorBased”属性的值是多少</td></tr><tr><td align="left">rootClass</td><td align="left">N</td><td align="left">为所有生成的实体类指定一个父类</td></tr><tr><td align="left">trimStrings</td><td align="left">N</td><td align="left">若数据库返回的字段中有空白部分，此属性可以对其进行特别填充</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.lsj.model&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;immutable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-15、-lt-sqlMapGenerator-gt"><a href="#4-15、-lt-sqlMapGenerator-gt" class="headerlink" title="4.15、&lt;sqlMapGenerator&gt;"></a>4.15、&lt;sqlMapGenerator&gt;</h2><p>作用：用于配置 Mapper 映射文件信息。</p><p>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">targetPackage</td><td align="left">Y</td><td align="left">指定 Mapper 映射文件所在包</td></tr><tr><td align="left">targetProject</td><td align="left">N</td><td align="left">指定 Mapper 映射文件所在项目路径</td></tr></tbody></table><p>子元素&lt;property&gt;中属性：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">enableSubPackages</td><td align="left">N</td><td align="left">指定是否根据表目录和模式来为 Mapper 映射文生成包</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.lsj.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-16、-lt-javaTypeResolver-gt"><a href="#4-16、-lt-javaTypeResolver-gt" class="headerlink" title="4.16、&lt;javaTypeResolver&gt;"></a>4.16、&lt;javaTypeResolver&gt;</h2><p>作用：用于指定 JDBC 类型和 Java 类型的转换规则。</p><p>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">N</td><td align="left">指定用户自定义的 Java 类型解析器，必须实现<code>org.mybatis.generator.api.JavaTypeResolver</code>接口，并且必须有一个公共的默认构造函数</td></tr></tbody></table><p>子元素&lt;property&gt;中属性：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">forceBigDecimals</td><td align="left">N</td><td align="left">此属性用于指定 MBG 是否应该强制使用<code>java.math.BigDecimal</code>用于 DECIMAL 和 NUMERIC 字段，而不是在可能的情况下替换整型</td></tr><tr><td align="left">useJSR310Types</td><td align="left">N</td><td align="left">此属性用于指定 MBG 是否应该强制对 DATE、TIME和 TIMESTAMP 字段使用 JSR-310 数据类型，而不是使用<code>java.util.Date</code></td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">javaTypeResolver</span> <span class="attr">type</span>=<span class="string">&quot;com.lsj.config.MyTypeResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useJSR310Types&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-17、-lt-plugin-gt"><a href="#4-17、-lt-plugin-gt" class="headerlink" title="4.17、&lt;plugin&gt;"></a>4.17、&lt;plugin&gt;</h2><p>作用：用于定义一个插件来扩展或修改 MBG。</p><p>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">N</td><td align="left">自定义插件类的完全限定名。这个类必须实现<code>org.mybatis.generator.api.Plugin</code>接口，必须有一个公共默认构造函数。注意，扩展适配器类<code>org.mybatis.generator.api.PluginAdapter</code>要比实现整个接口容易得多</td></tr></tbody></table><h2 id="4-18、-lt-properties-gt"><a href="#4-18、-lt-properties-gt" class="headerlink" title="4.18、&lt;properties&gt;"></a>4.18、&lt;properties&gt;</h2><p>作用：用于指定外部配置文件。</p><p>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">resource</td><td align="left">Y</td><td align="left">外部配置文件的全限定名，当指定资源时，将在类路径中搜索属性文件</td></tr><tr><td align="left">url</td><td align="left">Y</td><td align="left">外部配置文件的地址</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;generator.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-19、-lt-property-gt"><a href="#4-19、-lt-property-gt" class="headerlink" title="4.19、&lt;property&gt;"></a>4.19、&lt;property&gt;</h2><p>作用：用作子元素，配置具体属性。<br>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">Y</td><td align="left">属性名（区分大小写）</td></tr><tr><td align="left">url</td><td align="left">Y</td><td align="left">属性值（不区分大小写）</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-20、-lt-table-gt"><a href="#4-20、-lt-table-gt" class="headerlink" title="4.20、&lt;table&gt;"></a>4.20、&lt;table&gt;</h2><p>作用：用于配置需要生成代码的数据库表信息。</p><p>属性列表：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">tableName</td><td align="left">Y</td><td align="left">表名</td></tr><tr><td align="left">schema</td><td align="left">N</td><td align="left">数据库模式</td></tr><tr><td align="left">catalog</td><td align="left">N</td><td align="left">数据库目录</td></tr><tr><td align="left">alias</td><td align="left">N</td><td align="left">为表和列起别名</td></tr><tr><td align="left">domainObjectName</td><td align="left">N</td><td align="left">指定生成的实体类名称</td></tr><tr><td align="left">mapperName</td><td align="left">N</td><td align="left">指定 Mapper 接口和映射文件名称</td></tr><tr><td align="left">sqlProviderName</td><td align="left">N</td><td align="left">SQL 提供程序类的名称</td></tr><tr><td align="left">enableInsert、enableSelectByPrimaryKey、enableSelectByExample、enableUpdateByPrimaryKey、enableDeleteByPrimaryKey、enableDeleteByExample、enableCountByExample、enableUpdateByExample、selectByPrimaryKeyQueryId、selectByExampleQueryId</td><td align="left">N</td><td align="left">指定是否需要生成这些方法</td></tr><tr><td align="left">modelType</td><td align="left">N</td><td align="left">指定如何生成类，是只生成一个主键类，还是需要生成 BLOB 类、 Record 类，取值有：①conditional；②flat；③hierarchical（参考<a href="#defaultModelType">defaultModelType</a>）</td></tr><tr><td align="left">escapeWildcards</td><td align="left">N</td><td align="left">表示在搜索列时，模式和表名中的 SQL 通配符(‘_’和’%’)是否应该转义。如果模式或表名包含一个 SQL 通配符(例如，如果表名是 MY_TABLE，一些驱动程序要求将下划线字符转义)，那么这是必需的</td></tr><tr><td align="left">delimitIdentifiers</td><td align="left">N</td><td align="left">指定是否需要在生成的 SQL 中为标识符（类似于 Java 关键字）添加分隔符</td></tr><tr><td align="left">delimitAllColumns</td><td align="left">N</td><td align="left">指定是否需要在生成的 SQL 中为所有列添加分隔符</td></tr></tbody></table><p>子元素有：</p><ul><li>&lt;property&gt; (0..N)</li><li>&lt;generatedKey&gt; (0 or 1)</li><li>&lt;domainObjectRenamingRule&gt; (0 or 1)</li><li>&lt;columnRenamingRule&gt; (0 or 1)</li><li>&lt;columnOverride&gt; (0..N)</li><li>&lt;ignoreColumn&gt; (0..N)</li></ul><p>子元素&lt;property&gt;中还有如下属性：</p><table><thead><tr><th align="left">属性名</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">constructorBased</td><td align="left">N</td><td align="left">指定是否为类生成构造函数。若该属性被指定，则对象将通过构造函数构建，而不通过 setter 方法。如果”immutable”属性设置为”true”，则该属性将被忽略(并强制为”true”)</td></tr><tr><td align="left">dynamicSqlSupportClassName</td><td align="left">N</td><td align="left">MyBatis 动态 SQL Support 类的名称</td></tr><tr><td align="left">dynamicSqlTableObjectName</td><td align="left">N</td><td align="left">MyBatis 动态 SQL Support 类中生成的内部类所使用的名称</td></tr><tr><td align="left">ignoreQualifiersAtRuntime</td><td align="left">N</td><td align="left">如果为 true，则 MBG 不会将模式或目录添加到生成的 SQL 中的表名前面。如果你在多个模式中有相同名称的表，这很有用——你可以使用 MBG 基于一个模式中的表生成对象，但不包括运行时的模式</td></tr><tr><td align="left">immutable</td><td align="left">N</td><td align="left">用于选择 MBG 是否会生成不可变的实体类——这意味着类将没有“setter”方法，构造函数将接受类中每个字段的值。如果为真，这将强制使用参数化构造函数构建实体类，而不管“constructorBased”属性的值是多少</td></tr><tr><td align="left">modelOnly</td><td align="left">N</td><td align="left">用于配置是否只生成实体类，不生成 Mapper 接口和映射文件</td></tr><tr><td align="left">rootClass</td><td align="left">N</td><td align="left">为所有生成的实体类指定一个父类</td></tr><tr><td align="left">rootInterface</td><td align="left">N</td><td align="left">为所有生成的 Mapper 接口指定一个父接口</td></tr><tr><td align="left">runtimeCatalog</td><td align="left">N</td><td align="left">如果为该属性指定一个值，那么 MBG 将使用该值作为生成的 SQL 中的目录，而不是原数据库目录。如果你希望针对一个目录生成代码，但又希望在运行时使用不同的目录，那么这很有用</td></tr><tr><td align="left">runtimeSchema</td><td align="left">N</td><td align="left">如果为该属性指定一个值，那么 MBG 将使用该值作为生成的 SQL 中的模式，而不是原数据库模式。如果你希望针对一个模式生成代码，但又希望在运行时使用不同的模式，那么这很有用</td></tr><tr><td align="left">runtimeTableName</td><td align="left">N</td><td align="left">如果为该属性指定一个值，那么 MBG 将使用该值作为生成的 SQL 中的表名，而不是原数据库表名</td></tr><tr><td align="left">selectAllOrderByClause</td><td align="left">N</td><td align="left">该属性值会追加到 selectAll 方法后的 SQL 中，直接与 order by 拼接后添加到 SQL 末尾</td></tr><tr><td align="left">trimStrings</td><td align="left">N</td><td align="left">若数据库返回的字段中有空白部分，此属性可以对其进行特别填充</td></tr><tr><td align="left">useActualColumnNames</td><td align="left">N</td><td align="left">指定是否用真实的列名而不加修改</td></tr><tr><td align="left">useColumnIndexes</td><td align="left">N</td><td align="left">如果为 true，MBG 生成 resultMap 时会使用列的索引，而不是结果中列名的顺序</td></tr><tr><td align="left">useCompoundPropertyNames</td><td align="left">N</td><td align="left">如果为 true，MBG 生成属性名的时候会将列名和列备注结合起来</td></tr></tbody></table><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;MYTABLE&quot;</span> <span class="attr">schema</span>=<span class="string">&quot;MYSCHEMA&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ignoreColumn</span> <span class="attr">column</span>=<span class="string">&quot;fred&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">columnOverride</span> <span class="attr">column</span>=<span class="string">&quot;BEG_DATE&quot;</span> <span class="attr">property</span>=<span class="string">&quot;startDate&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MyBaits Generator 三部曲：&lt;br&gt;1、&lt;a href=&quot;https://lisj98.github.io/2022/09/08/MyBatisGenerator%E7%AE%80%E4%BB%8B/&quot;&gt;MyBatis Generator 简介&lt;/a&gt;&lt;br</summary>
      
    
    
    
    <category term="MyBatisGenerator" scheme="https://lisj98.github.io/categories/MyBatisGenerator/"/>
    
    
    <category term="MyBatisGenerator" scheme="https://lisj98.github.io/tags/MyBatisGenerator/"/>
    
    <category term="MyBatis" scheme="https://lisj98.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatisGenerator简介</title>
    <link href="https://lisj98.github.io/2022/09/08/MyBatisGenerator%E7%AE%80%E4%BB%8B/"/>
    <id>https://lisj98.github.io/2022/09/08/MyBatisGenerator%E7%AE%80%E4%BB%8B/</id>
    <published>2022-09-08T15:20:29.000Z</published>
    <updated>2022-09-08T15:49:13.432Z</updated>
    
    <content type="html"><![CDATA[<p>MyBaits Generator 三部曲：<br>1、<a href="https://lisj98.github.io/2022/09/08/MyBatisGenerator%E7%AE%80%E4%BB%8B/">MyBatis Generator 简介</a><br>2、<a href="https://lisj98.github.io/2022/09/08/MyBatisGenerator%E4%BD%BF%E7%94%A8/">MyBatis Generator 使用</a><br>3、MyBatis Generator 扩展 <a class="link"   href="http://mybatis.org/generator/reference/intro.html" >官方文档<i class="fas fa-external-link-alt"></i></a></p><p>了解一个东西先要看它是什么，用来干什么，它的限制场景，使用它能达到什么效果，怎么用，怎么扩展。<br>官方网址：<a class="link"   href="http://mybatis.org/generator/index.html" >http://mybatis.org/generator/index.html<i class="fas fa-external-link-alt"></i></a></p><h1 id="1、MyBatis-Generator-是什么？"><a href="#1、MyBatis-Generator-是什么？" class="headerlink" title="1、MyBatis Generator 是什么？"></a>1、MyBatis Generator 是什么？</h1><p>答：是一个适配于 Mybatis 的<code>代码生成器</code>，简称 <code>MBG</code>，可以根据数据库表生成 ①实体类、②Mapper 接口、③Mapper 映射文件。</p><h1 id="2、MyBatis-Generator-用来干什么？它的限制场景？"><a href="#2、MyBatis-Generator-用来干什么？它的限制场景？" class="headerlink" title="2、MyBatis Generator 用来干什么？它的限制场景？"></a>2、MyBatis Generator 用来干什么？它的限制场景？</h1><p>答：用来自动生成大部分常见的 CRUD 操作，但无法生成一些复杂的 SQL 语句（如子查询、group、join 等无法通过 MBG 实现，用常规方法即可）。</p><p>根据配置的不同，MyBatis Generator 生成的匹配表结构的 Java 实体类包括：</p><ul><li><code>主键类</code>：根据表的主键进行匹配的类（如果有主键）</li><li><code>Record 类</code>：根据表的非主键字段进行匹配的类（BLOB 字段除外）</li><li><code>Record With BLOBs 类</code>：包含表的 BLOB 字段的类（如果有）</li><li><code>Example 类</code>：实现条件查询、更新、删除、插入等的类</li><li><code>Support 类</code>：用于 where 子句的输入</li></ul><p>MyBatis Generator 生成的 Mapper.xml 映射文件中的 CRUD 操作包括：</p><ul><li>插入</li><li>按主键更新</li><li>条件更新（使用动态 where 子句）</li><li>按主键删除</li><li>条件删除（使用动态 where 子句）</li><li>按主键查询</li><li>条件查询（使用动态 where 子句）</li><li>条件计数（count）</li></ul><p>如上所述，对于一些连接查询，一对一、一对多、存储过程等复杂的 SQL 语句，MyBatis Generator 不会自动生成，需要手动编写。</p><h1 id="3、它能达到什么效果？"><a href="#3、它能达到什么效果？" class="headerlink" title="3、它能达到什么效果？"></a>3、它能达到什么效果？</h1><p>答：自动生成代码。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/MyBatis/MBG%E8%BE%BE%E5%88%B0%E7%9A%84%E6%95%88%E6%9E%9C.59cogh8r2gc0.webp" alt="MBG达到的效果"></p><h1 id="4、怎么用？"><a href="#4、怎么用？" class="headerlink" title="4、怎么用？"></a>4、怎么用？</h1><p>见<a href="https://lisj98.github.io/2022/09/08/MyBatisGenerator%E4%BD%BF%E7%94%A8/">MyBatis Generator 使用</a>。</p><h1 id="5、怎么扩展？"><a href="#5、怎么扩展？" class="headerlink" title="5、怎么扩展？"></a>5、怎么扩展？</h1><p>见官方文档 <a class="link"   href="http://mybatis.org/generator/reference/intro.html" >http://mybatis.org/generator/reference/intro.html<i class="fas fa-external-link-alt"></i></a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MyBaits Generator 三部曲：&lt;br&gt;1、&lt;a href=&quot;https://lisj98.github.io/2022/09/08/MyBatisGenerator%E7%AE%80%E4%BB%8B/&quot;&gt;MyBatis Generator 简介&lt;/a&gt;&lt;br</summary>
      
    
    
    
    <category term="MyBatis" scheme="https://lisj98.github.io/categories/MyBatis/"/>
    
    
    <category term="MyBatisGenerator" scheme="https://lisj98.github.io/tags/MyBatisGenerator/"/>
    
    <category term="MyBatis" scheme="https://lisj98.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>数据库理论</title>
    <link href="https://lisj98.github.io/2022/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
    <id>https://lisj98.github.io/2022/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/</id>
    <published>2022-09-08T14:51:49.000Z</published>
    <updated>2022-09-08T15:19:19.979Z</updated>
    
    <content type="html"><![CDATA[<p>TODO：一文整理数据库语句：xxx</p><h1 id="1、关系型数据库和非关系型数据库的区别？数据库和非关系型数据库的区别？"><a href="#1、关系型数据库和非关系型数据库的区别？数据库和非关系型数据库的区别？" class="headerlink" title="1、关系型数据库和非关系型数据库的区别？数据库和非关系型数据库的区别？"></a>1、关系型数据库和非关系型数据库的区别？数据库和非关系型数据库的区别？</h1><p><code>关系型数据库</code>是指用关系模型来组织数据的数据库，数据以行和列（即表）的形式存储；<code>非关系型数据库</code>中数据是以键值对的形式存储的；</p><p><code>NoSQL的特点</code>：</p><ul><li>模式自由：不需要定义表结构，数据表中每条记录都可能有不同的格式</li><li>逆规范化：不遵循范式要求，去掉完整性约束，表之间不存在依赖</li><li>扩展性强：可在系统运行的过程中，动态的删除和增加节点</li><li>多副本异步复制：数据快速写入一个节点，其余节点通过日志来实现异步复制</li><li>弱事务：不保证事务的ACID特性，但可以保证事务的最终一致性</li></ul><p> <code>SQL的特点</code>：</p><ul><li>数据集中控制</li><li>数据独立：数据库中的数据独立于应用程序</li><li>数据共享性好：数据库中的数据供多个用户使用</li><li>减少数据冗余：数据统一定义、组织和存储，减少冗余度</li><li>数据结构化：整个数据库按一定的结构形式构成，数据在记录内部和记录类型之间相互关联，用户可通过不同的路径读取数据</li></ul><h1 id="2、char、varchar的区别？"><a href="#2、char、varchar的区别？" class="headerlink" title="2、char、varchar的区别？"></a>2、char、varchar的区别？</h1><p> char存储<code>定长</code>字符串，varchar存储<code>变长</code>字符串，varchar容易产生内存碎片。</p><h1 id="3、DROP、DELETE、TRUNCATE的区别？"><a href="#3、DROP、DELETE、TRUNCATE的区别？" class="headerlink" title="3、DROP、DELETE、TRUNCATE的区别？"></a>3、DROP、DELETE、TRUNCATE的区别？</h1><p><code>drop</code>用来删除数据库、表、索引等，是完全清除结构和数据；</p><p><code>delete</code>只会删除数据记录；</p><p><code>truncate</code>会清除表中的所有数据，保留结构。</p><p>delete属于DML语句，执行完后不会自动提交，可以回滚；truncate和drop属于DDL语句，执行完后会马上自动提交，不能回滚。<br><code>执行速度上：drop &gt; truncate &gt; delete</code>。</p><h1 id="4、SQL中常用的聚合函数？"><a href="#4、SQL中常用的聚合函数？" class="headerlink" title="4、SQL中常用的聚合函数？"></a>4、SQL中常用的聚合函数？</h1><ul><li><code>COUNT(*)</code>：计算表中总的行数，不管某行或某列是否有空值</li><li><code>COUNT(字段)</code>：计算指定列下总的记录数，忽略空值</li><li><code>AVG()</code>：计算指定列的平均值</li><li><code>SUM()</code>：计算指定列的总和</li><li><code>MAX()</code>：计算指定列中的最大值</li><li><code>MIN()</code>：计算指定列中的最小值</li></ul><p><code>补充</code>：COUNT()函数详解：</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">COUNT(主键)</td><td align="left">InnoDB引擎会遍历整张表，把每一行的主键id值取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为NULL）</td></tr><tr><td align="left">COUNT(字段)</td><td align="left">没有NOT NULL约束：InnoDB引擎会遍历整张表，把每一行的字段值取出来，返回给服务层，服务层判断值是否为NULL，不为NULL则计数累加；有NOT NULL约束：InnoDB引擎会遍历整张表，把每一行的字段值取出来，返回给服务层，服务层直接按行进行累加；</td></tr><tr><td align="left">COUNT(数字)</td><td align="left">InnoDB引擎会遍历整张表，但不取值，服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加；</td></tr><tr><td align="left">COUNT(*)</td><td align="left">InnoDB引擎会遍历整张表，但不取值，服务层直接按行进行累加；</td></tr><tr><td align="left">效率</td><td align="left"><code>COUNT(字段) &lt; COUNT(主键id) &lt; COUNT(1) &lt; COUNT(*)</code></td></tr></tbody></table><h1 id="5、数据库中表的关联形式？"><a href="#5、数据库中表的关联形式？" class="headerlink" title="5、数据库中表的关联形式？"></a>5、数据库中表的关联形式？</h1><ul><li><code>一对一</code>：两个表的主键关联或外键关联；</li><li><code>一对多</code>：一般是两张表具有主从关系，从表的外键关联主表的主键。例如主表为班级表，主键为班级号，从表为学生表，主键为学号，外键为班级号，就可以将班级表的班级号（主键）和学生表的班级号（外键）关联起来；</li><li><code>多对多</code>：如果两张表具有多对多的关系，那么它们就需要一张中间表来作为衔接，这个中间表有自己的主键（或者不用主键），它的外键就是需要关联的两张表的主键，所以至少应该设计两个字段；</li><li><code>自关联</code>：一张表与自己进行关联，关联时需要取别名。</li></ul><h1 id="6、等值连接、自连接、自然连接、内连接、外连接、全连接？"><a href="#6、等值连接、自连接、自然连接、内连接、外连接、全连接？" class="headerlink" title="6、等值连接、自连接、自然连接、内连接、外连接、全连接？"></a>6、等值连接、自连接、自然连接、内连接、外连接、全连接？</h1><p>新建两张表：<br><code>球员表</code>：</p><table><thead><tr><th align="left">id</th><th align="left">name</th><th align="left">nationality</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Messi</td><td align="left">Argentina</td></tr><tr><td align="left">2</td><td align="left">Cristiano</td><td align="left">Portugal</td></tr><tr><td align="left">3</td><td align="left">Neymar</td><td align="left">Brazil</td></tr><tr><td align="left">4</td><td align="left">De Bruyne</td><td align="left">Belgium</td></tr><tr><td align="left">5</td><td align="left">Benzema</td><td align="left">French</td></tr></tbody></table><p><code>评分表</code>：</p><table><thead><tr><th align="left">id</th><th align="left">name</th><th align="left">score</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Messi</td><td align="left">93</td></tr><tr><td align="left">2</td><td align="left">Cristiano</td><td align="left">91</td></tr><tr><td align="left">3</td><td align="left">Neymar</td><td align="left">91</td></tr><tr><td align="left">6</td><td align="left">Neuer</td><td align="left">90</td></tr></tbody></table><h2 id="6-1、-等值连接"><a href="#6-1、-等值连接" class="headerlink" title="6.1、 等值连接"></a>6.1、 等值连接</h2><p>取出左表中的每一条记录，和右表进行匹配，若满足判断条件则保留，不满足则舍弃；可以认为和内连接一样，内连接是相对于外连接提出来的概念。<br>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_footballer,tb_score <span class="keyword">where</span> tb_footballer.id<span class="operator">=</span>tb_score.id;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_footballer <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tb_score <span class="keyword">on</span> tb_footballer.id<span class="operator">=</span>tb_score.id;</span><br></pre></td></tr></table></figure><p>两者返回的结果都是一样的：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5.32i5q5ij2mm0.webp" alt="等值连接"></p><p><code>补充</code>：从直观角度看，连接就是将两个表的需要查询的字段连接起来，两个表中字段名不同的直接拼接，字段名相同的会自动重命名，注意连接是列的连接。</p><h2 id="6-2、自连接"><a href="#6-2、自连接" class="headerlink" title="6.2、自连接"></a>6.2、自连接</h2><p>将一个表与其自身做连接，可以用于排列组合等。<br>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_score t1,tb_score t2;# 不加任何限制条件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%87%AA%E8%BF%9E%E6%8E%A51.7ff4y51lvgw0.webp" alt="自连接1"></p><p>再加一个限制条件：去除重复的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_score t1,tb_score t2 <span class="keyword">WHERE</span> t1.name<span class="operator">&lt;&gt;</span>t2.name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%87%AA%E8%BF%9E%E6%8E%A52.57cpa1lopis0.webp" alt="自连接2"></p><p>如果我们认为两个name只是位置不同的话可以视为一条记录，那么我们还可以再设置限制条件：去重<br>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_score t1,tb_score t2 <span class="keyword">WHERE</span> t1.name<span class="operator">&gt;</span>t2.name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%87%AA%E8%BF%9E%E6%8E%A53.apek7l1kegg.webp" alt="自连接3"></p><p>这样便实现了找出一个表中不同组合（忽略次序)的功能。</p><h2 id="6-3、自然连接（NATURAL-JOIN）"><a href="#6-3、自然连接（NATURAL-JOIN）" class="headerlink" title="6.3、自然连接（NATURAL JOIN）"></a>6.3、自然连接（NATURAL JOIN）</h2><p>会将两张表中具有相同列名的列自动进行匹配并在连接结果中删除两个重复列中的一个，不必指定任何同等连接条件。虽然可以指定查询结果包含哪些列，但是不能人为指定匹配列。<br>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_footballer <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tb_score;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5.7exwmi55l200.webp" alt="自然连接"></p><h2 id="6-4、内连接（INNER-JOIN）"><a href="#6-4、内连接（INNER-JOIN）" class="headerlink" title="6.4、内连接（INNER JOIN）"></a>6.4、内连接（INNER JOIN）</h2><p>查询结果中仅包含左右表中均有的记录。<br>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_footballer tf <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tb_score ts <span class="keyword">on</span> tf.name<span class="operator">=</span>ts.name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%86%85%E8%BF%9E%E6%8E%A5.5nkhtvl2bbo0.webp" alt="内连接"></p><h2 id="6-5、左外连接（LEFT-JOIN）"><a href="#6-5、左外连接（LEFT-JOIN）" class="headerlink" title="6.5、左外连接（LEFT JOIN）"></a>6.5、左外连接（LEFT JOIN）</h2><p>包含左表的全部记录以及右表的匹配记录。<br>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_footballer tf <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tb_score ts <span class="keyword">on</span> tf.name<span class="operator">=</span>ts.name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5.392v711wrzc0.webp" alt="左外连接"></p><h2 id="6-6、右外连接（RIGHT-JOIN）"><a href="#6-6、右外连接（RIGHT-JOIN）" class="headerlink" title="6.6、右外连接（RIGHT JOIN）"></a>6.6、右外连接（RIGHT JOIN）</h2><p>包含右表的全部记录以及左表的匹配记录。<br>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_footballer tf <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> tb_score ts <span class="keyword">on</span> tf.name<span class="operator">=</span>ts.name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5.5zcuv3zsrn0.webp" alt="右外连接"></p><h2 id="6-7、全连接（全外连接）"><a href="#6-7、全连接（全外连接）" class="headerlink" title="6.7、全连接（全外连接）"></a>6.7、全连接（全外连接）</h2><p>包含左右表中所有记录，<code>Oracle支持全连接（FULL JOIN），MySQL不支持全连接</code>，不过可以用UNION将左连接和右连接结合起来。<br>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># MySQL实现全连接方式</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_footballer tf <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tb_score ts <span class="keyword">on</span> tf.name<span class="operator">=</span>ts.name</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_footballer tf <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> tb_score ts <span class="keyword">on</span> tf.name<span class="operator">=</span>ts.name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%A8%E8%BF%9E%E6%8E%A5.67wkpe228d40.webp" alt="全连接"></p><h1 id="7、元组、属性？"><a href="#7、元组、属性？" class="headerlink" title="7、元组、属性？"></a>7、元组、属性？</h1><p>通俗来说，<code>元组</code>就是行，<code>属性</code>就是列。</p><h1 id="8、主键、外键、超键、候选键？"><a href="#8、主键、外键、超键、候选键？" class="headerlink" title="8、主键、外键、超键、候选键？"></a>8、主键、外键、超键、候选键？</h1><ul><li><code>主键</code>：数据库表中对存储数据对象予以唯一和完整标识的数据列或属性的组合，一个表只能有一个主键，且主键非空唯一；</li><li><code>外键</code>：外键用于关联另一张表，通常是另一张表的主键，一个表可以有多个外键；</li><li><code>超键</code>：在关系中能唯一标识元组的属性集称为关系模式的超键，也就是说，保证行记录唯一的列都可以用来定义超键；</li><li><code>候选键</code>：最小分割的超键就是候选键，即超键的唯一可以再划分为更小的唯一，比如身份证号和学号都可以作为候选键，但是身份证号和学号拼接起来就只能作为超键，因为拼接起来的字符串不满足最小分割原则。</li></ul><h1 id="9、完整性约束有哪些？"><a href="#9、完整性约束有哪些？" class="headerlink" title="9、完整性约束有哪些？"></a>9、完整性约束有哪些？</h1><ul><li><code>实体完整性</code>：规定表中的每一行记录都是唯一的实体；</li><li><code>域完整性</code>：规定表中的每一列都必须属于数据库系统规定的数据类型；</li><li><code>参照完整性</code>：规定两张表的主键和外键的数据应该一致，保证了关联表数据间的一致性；</li><li><code>用户定义完整性</code>：不同数据库有不同的要求，应满足不同数据库各自的要求。</li></ul><h1 id="10、SQL约束有哪些？"><a href="#10、SQL约束有哪些？" class="headerlink" title="10、SQL约束有哪些？"></a>10、SQL约束有哪些？</h1><ul><li><code>PRIMARY KRY</code>：主键约束，一张表只能有一个主键；</li><li><code>FOREIGN KEY</code>：外键约束，用于指定具体关联主表的哪一列（主键列），防止破坏表之间的连接；</li><li><code>NOT NULL</code>：非空约束；</li><li><code>UNIQUE</code>：唯一约束；</li><li><code>CHECK</code>：check约束，自定义，用于控制该字段的取值范围。</li></ul><h1 id="11、数据库的三大范式？"><a href="#11、数据库的三大范式？" class="headerlink" title="11、数据库的三大范式？"></a>11、数据库的三大范式？</h1><ul><li><code>第一范式</code>：原子性约束，要求每列都是最小的数据单元，不可再分割；</li><li><code>第二范式</code>：唯一性约束，在第一范式的基础上，要求每一列都和主键完全相关，而不是部分相关，例如联合主键，你必须和联合主键中的每一个主键都相关，而不是只和某一个主键相关；</li><li><code>第三范式</code>：冗余性约束，在第二范式的基础上，要求每一列都和主键直接相关，而不是间接相关，即不能有传递依赖关系，例如学生和院系直接相关，而不是和班级依赖，再和院系依赖。</li></ul><h1 id="12、什么是子查询？"><a href="#12、什么是子查询？" class="headerlink" title="12、什么是子查询？"></a>12、什么是子查询？</h1><p>一条SQL语句的查询结果作为另一条SQL语句的参考输入，即多条SQL语句嵌套使用时，内部的SQL查询语句就叫子查询。<br>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_footballer <span class="keyword">WHERE</span> tb_footballer.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> tb_score);</span><br></pre></td></tr></table></figure><h1 id="13、什么是存储过程？它的优缺点是什么？"><a href="#13、什么是存储过程？它的优缺点是什么？" class="headerlink" title="13、什么是存储过程？它的优缺点是什么？"></a>13、什么是存储过程？它的优缺点是什么？</h1><p>存储过程是在大型数据库系统中，<code>一组为了完成特定功能的SQL语句集</code>，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过存储过程名来调用存储过程查出结果。简单来说，就是一组批量执行的SQL语句，类似于Docker中的Docker-compose。</p><p>存储过程的<code>优点</code>：</p><ul><li>效率高：预编译，仅第一次调用时进行编译，后续不再进行编译</li><li>减少网络传输：不用频繁传输大批SQL语句</li><li>复用性好：存储过程往往是针对某一特定功能编写的</li><li>可维护性高：某一特定功能发生变化时，仅需修改对应的存储过程</li><li>安全性高：一般具有用户访问级别限制</li></ul><p>存储过程的<code>缺点</code>：</p><ul><li>存储过程里保存的基本上是业务逻辑需要的SQL，而把业务逻辑放在数据库里这种行为是不推荐的</li><li>调试复杂</li><li>移植复杂：不同数据库对SQL语句有不同要求</li><li>不支持集群：数据库进行分库或者集群部署之后，并不清楚存储过程会保留到哪个数据库中</li></ul><h1 id="14、存储过程中IN、OUT、INOUT参数的区别？"><a href="#14、存储过程中IN、OUT、INOUT参数的区别？" class="headerlink" title="14、存储过程中IN、OUT、INOUT参数的区别？"></a>14、存储过程中IN、OUT、INOUT参数的区别？</h1><p><code>默认参数类型为IN</code>；<br>IN、INOUT参数调用存储过程时没有赋初值，默认值为NULL；OUT参数不管有没有赋初值，参数值均为NULL；</p><ul><li><code>IN</code>：输入参数，该参数不管在存储过程内部如何修改其值，返回的参数值仍然是当初赋的初值，存储过程内的修改不生效；</li><li><code>OUT</code>：输出参数，可用来接收返回值，该参数可以在存储过程内部被修改，并且修改结果也会生效；</li><li><code>INOUT</code>：输入输出参数，该参数结合了IN参数和OUT参数，在存储过程内部可修改，并且修改结果也会生效。</li></ul><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/IN%E3%80%81OUT%E3%80%81INOUT%E5%8F%82%E6%95%B0.3oc3jzanw4i0.webp" alt="IN、OUT、INOUT参数"></p><h1 id="15、存储过程和函数的区别？"><a href="#15、存储过程和函数的区别？" class="headerlink" title="15、存储过程和函数的区别？"></a>15、存储过程和函数的区别？</h1><p><code>不同点</code>：</p><ul><li>存储过程标识符是<code>procedure</code>，函数标识符是<code>function</code>；</li><li>存储过程用于在数据库中执行特定操作（如查询、插入、删除）等，函数用于计算或返回特定的数据； </li><li>定义存储过程时不需要返回类型，只能通过OUT或INOUT来返回值，函数必须要有返回类型，且必须要有return子句，也可以通过OUT、INOUT来返回值；</li><li>存储过程可以作为一个独立的SQL语句执行，函数不能独立执行，必须包含在表达式中；</li><li>存储过程使用<code>call</code>调用，函数使用<code>select</code>调用，可以在SQL语句中调用函数，但是不能调用存储过程。</li></ul><p><code>相同点</code>：</p><ul><li>创建语法相似，都携带一个或多个入参或返回一个或多个出参；</li><li>都是一次编译，多次执行。</li></ul><p><code>使用场景</code>：如果有多个返回值或者不返回值，就用存储过程；如果只有一个值返回，就用函数。</p><h1 id="16、什么是触发器？MySQL中有哪些触发器？"><a href="#16、什么是触发器？MySQL中有哪些触发器？" class="headerlink" title="16、什么是触发器？MySQL中有哪些触发器？"></a>16、什么是触发器？MySQL中有哪些触发器？</h1><p><code>触发器</code>指在insert&#x2F;delete&#x2F;update之前（BEFORE）或之后（AFTER）触发并执行其中定义的SQL语句集合的一个数据库对象。<br><code>触发器类型</code>有:<br> ①BEFORE INSERT<br> ②AFTER INSERT<br> ③BEFORE DELETE<br> ④AFTER DELETE<br> ⑤BEFORE UPDATE<br> ⑥AFTER UPDATE</p><p>使用别名OLD和NEW来引用触发器中发生变化的记录内容：</p><table><thead><tr><th align="left">触发器类型</th><th align="left">NEW和OLD</th></tr></thead><tbody><tr><td align="left">INSERT型触发器</td><td align="left">NEW表示将要或者已经新增的数据</td></tr><tr><td align="left">UPDATE型触发器</td><td align="left">OLD表示修改之前的数据，NEW表示将要或修改之后的数据</td></tr><tr><td align="left">DELETE型触发器</td><td align="left">OLD表示将要或已经删除的数据</td></tr></tbody></table><h1 id="17、视图是什么？"><a href="#17、视图是什么？" class="headerlink" title="17、视图是什么？"></a>17、视图是什么？</h1><p>视图是一张<code>虚拟的表</code>，也就是它在磁盘中并不存在。它代表<code>一部分的表（即单表或关联的多表中的部分记录）</code>，通用场景下我们会根据不同的条件创建不同的视图，即各种SQL查询语句的集合，下次再查询时就只用查询视图名，而不用再去批量执行SQL语句了。视图可以进行增删改查操作，但是限制很多，很多情况下并不支持这些操作，不过话说回来，视图主要用于方便查询，也不推荐使用视图进行增删改。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%A7%86%E5%9B%BE.l2s2v3g9ucg.webp" alt="视图"></p><h1 id="18、存储过程和视图的区别？"><a href="#18、存储过程和视图的区别？" class="headerlink" title="18、存储过程和视图的区别？"></a>18、存储过程和视图的区别？</h1><ul><li>从本质上讲，存储过程和视图都是一段已经编译好的SQL脚本，而<code>存储过程可以提供输入参数，视图不接受参数</code>；</li><li>存储过程的目的是<code>操作数据</code>，视图的目的是方便<code>呈现数据</code>（即存储过程关注的是操作数据这件事，而视图关注的是返回的结果集）。</li></ul><h1 id="19、游标是什么？"><a href="#19、游标是什么？" class="headerlink" title="19、游标是什么？"></a>19、游标是什么？</h1><p>可以把游标看成是编程语言中的指针，用于在返回结果集中遍历数据。</p><h1 id="20、where、on、having有什么区别？"><a href="#20、where、on、having有什么区别？" class="headerlink" title="20、where、on、having有什么区别？"></a>20、where、on、having有什么区别？</h1><p><code>where和having的区别</code>在于：</p><ul><li>where在group by和聚合函数之前对数据进行过滤；</li><li>having在group by和聚合函数之后对数据进行过滤。</li></ul><p><code>where和on的区别</code>在于：</p><ul><li>内连接中，on和where等价；</li><li>外连接中，on在连接操作之前进行，where在连接操作之后进行。</li></ul><p><code>三者执行顺序是：on &gt; 连接 &gt; where &gt; 聚合函数 &gt; having</code>。</p><h1 id="21、IN和EXISTS的区别？"><a href="#21、IN和EXISTS的区别？" class="headerlink" title="21、IN和EXISTS的区别？"></a>21、IN和EXISTS的区别？</h1><ul><li>IN是子查询的表为驱动表，先执行内层查询，再执行外层查询，故适用于子查询结果集小而外层表结果集大的情况；<br>EXISTS是外层表作为驱动表，先执行外层查询，再执行内层查询，故适用于外层表结果集小而子查询结果集大的情况；</li><li>IN是非关联子查询，而对于非关联子查询，必须先完成内层查询后，外层查询才能介入；<br>EXISTS是关联子查询，而对于关联子查询，必须先执行外层查询，接着对所有通过过滤条件的记录，执行内层查询，因为外层查询会把过滤后的结果传递给内层查询；</li><li>IN只执行一次，先确定给定的值是否与子查询或列表中的值相匹配，然后再将内表和外表做一个笛卡尔积，再按照条件进行过滤；<br>EXISTS先遍历循环外表，然后再看内表中的记录有没有和外表一样的，匹配上则将结果放入结果集中。</li></ul><h1 id="22、如何实现行转列、列转行？"><a href="#22、如何实现行转列、列转行？" class="headerlink" title="22、如何实现行转列、列转行？"></a>22、如何实现行转列、列转行？</h1><p>。。。</p><h1 id="23、数据库事务是什么？有哪些特性？"><a href="#23、数据库事务是什么？有哪些特性？" class="headerlink" title="23、数据库事务是什么？有哪些特性？"></a>23、数据库事务是什么？有哪些特性？</h1><p>数据库事务是逻辑上的一组数据库操作，要么都执行，要么都不执行，不可分割。</p><p>数据库事务包含<code>ACID</code>四个特性：</p><ul><li><code>原子性（Atomicity）</code>：事务是一个不可分割的工作单位，事务中的动作要么都完成，要么都不完成；</li><li><code>一致性（Consistency）</code>：事务必须使数据库总体状态保持不变，例如A和B加起来共有10000元钱，那么不管他们如何转账，总和必须总是10000元；</li><li><code>隔离性（Isolation）</code>：多个用户操作同一资源时，一个用户的事务不能被另一个用户的事务所干扰，多个并发事务之间数据相互隔离，各个事务都有各自完整的数据空间；</li><li><code>持久性（Durability）</code>：事务一旦被提交了，那么它对数据库的改变就是永久性的，即使数据库出现故障也不会有任何影响。</li></ul><h1 id="24、如果不考虑隔离性，即事务之间相互影响，会导致什么问题？"><a href="#24、如果不考虑隔离性，即事务之间相互影响，会导致什么问题？" class="headerlink" title="24、如果不考虑隔离性，即事务之间相互影响，会导致什么问题？"></a>24、如果不考虑隔离性，即事务之间相互影响，会导致什么问题？</h1><ul><li><code>脏读</code>：一个事务读取到了另一个事务还没有提交的数据。比如天气太热，M的老婆W准备给M多加100的零花钱去买水喝，就给M发了个红包，几分钟后越想越气，什么家务都不干还想加零花钱，就把这红包给撤回了，M看到了红包很高兴，点进去一看发现被撤回了，空欢喜一场；</li><li><code>不可重复读</code>：一个事务操作中对同一数据读取了多次，但是这多次的结果不一样（强调的是记录本身内容的不一致）。比如M正在吃饭，买单前看了看银行卡里有500块钱，欸，很开心，可以吃顿好的，吃完了看看银行卡还是500块钱，准备去买单，M的老婆正好这时候提现了499元去买口红，结果老板告诉M卡里只有1块钱，M吃了霸王餐，只好打电话向W求救。不可重复读出现的原因就是多个事务并发修改记录；</li><li><code>幻读</code>：在同一个事务中，同一个查询多次返回的结果不一致（强调的是记录数量的不一致）。比如M在手机上查看消费明细有5笔开销，正当他要打印消费明细时，好巧不巧，M的老婆W正好买了一个包包花了5万元，结果M打印出来的明细多了一笔5万元的开销，明细变成了6笔，就像出现了幻觉一样。幻读出现的原因是多个事务并发增加或删除记录。</li></ul><p><code>补充</code>：以上面的例子来说，不可重复读关注的余额，两次查询发现余额变了，即内容变了；而幻读关注的是明细数量，两次查询发现明细数量多了一条。</p><h1 id="25、事务隔离级别？"><a href="#25、事务隔离级别？" class="headerlink" title="25、事务隔离级别？"></a>25、事务隔离级别？</h1><ul><li><code>读未提交（Read Uncommitted）</code>：事务可以读取到其他事务尚未提交的数据，存在脏读、不可重复读和幻读的问题；</li><li><code>读已提交（Read Committed）</code>：只有数据被事务提交之后，其他事务才能读取到改变后的数据，解决了脏读的问题，存在不可重复读和幻读的问题；</li><li><code>可重复读（Repeatable Read）</code>：事务对同一数据多次读取的结果都是一致的，解决了脏读和不可重复读的问题，存在幻读的问题；</li><li><code>串行化（Serializable）</code>：强制事务依次执行，不可插队，解决了脏读、不可重复读和幻读的问题。</li></ul><table><thead><tr><th align="left">隔离级别</th><th align="left">脏读</th><th align="left">不可重复读</th><th align="left">幻读</th><th align="left">数据库默认隔离级别</th></tr></thead><tbody><tr><td align="left">读未提交（Read Uncommitted）</td><td align="left">是</td><td align="left">是</td><td align="left">是</td><td align="left"></td></tr><tr><td align="left">读已提交（Read Committed）</td><td align="left">否</td><td align="left">是</td><td align="left">是</td><td align="left">Oracle</td></tr><tr><td align="left">可重复读（Repeatable Read）</td><td align="left">否</td><td align="left">否</td><td align="left">是</td><td align="left">MySQL</td></tr><tr><td align="left">串行化（Serializable）</td><td align="left">否</td><td align="left">否</td><td align="left">否</td><td align="left"></td></tr></tbody></table><h1 id="26、索引是什么？"><a href="#26、索引是什么？" class="headerlink" title="26、索引是什么？"></a>26、索引是什么？</h1><p><code>索引是对数据库表中一列或多列的值进行排序的一种结构</code>，使用索引可快速访问数据库表中的特定信息，简言之，索引就类似于<code>书本中的目录</code>，提前给你排好了序。举个例子，如果没有索引，那么查询时就会进行全表查询，然后丢弃不满足条件的行，而有索引时，假如索引采用的是B+Tree的结构，那么就会大大减少查询次数，提高查询效率。</p><h1 id="27、索引的优缺点？"><a href="#27、索引的优缺点？" class="headerlink" title="27、索引的优缺点？"></a>27、索引的优缺点？</h1><p><code>优点</code>：</p><ul><li>提前排好序，加快数据的检索速度</li><li>将随机IO变为顺序IO</li><li>通过创建不同种类的索引，可以对数据起到约束作用</li></ul><p><code>缺点</code>：</p><ul><li>创建和维护索引耗费时间，而且随着数据量的增加而增大</li><li>索引需要占用物理空间</li><li>查询效率得到了提升，但是增删改的效率降低了</li></ul><h1 id="28、索引设计原则？"><a href="#28、索引设计原则？" class="headerlink" title="28、索引设计原则？"></a>28、索引设计原则？</h1><p><code>应该使用索引的场景</code>：</p><ul><li>经常需要查询的列上；</li><li>常作为查询条件（where）、排序（order by）、分组（group by）操作的列；</li><li>字符串类型列可以使用前缀索引；</li><li>尽量使用联合索引，而不是单列索引，联合索引很多时候用到了覆盖索引，不用回表查询，性能高；</li><li>要控制索引的数量；</li></ul><p><code>不应该使用索引的场景</code>;</p><ul><li>查询中很少使用的列；</li><li>数据记录比较少的列；</li><li>定义为text、image的列，因为这些列的数据量相当大，要么使用前缀索引，要么压根就不使用索引；</li><li>当对修改数据的性能远远大于搜索数据的性能时。因为使用索引能提高搜索性能，但是会降低修改性能。</li></ul><h1 id="29、索引的类型？"><a href="#29、索引的类型？" class="headerlink" title="29、索引的类型？"></a>29、索引的类型？</h1><ul><li><code>主键索引</code>：作用的列非空且唯一，一个表只有一个主键</li><li><code>唯一索引</code></li><li><code>普通索引</code>：可以为空，可以重复</li><li><code>全文索引</code>：也叫<code>倒排索引</code>，把词条出现的频率和位置做一个归纳，这样就建立了一个以词条为目录项的目录，这样在查找某个词的时候就能很快的定位到该词以及该词所在的句子，类似于ElasticSearch的倒排索引</li><li><code>联合索引</code>：多列组合成一个索引</li></ul><h1 id="30、聚簇索引？非聚簇索引？"><a href="#30、聚簇索引？非聚簇索引？" class="headerlink" title="30、聚簇索引？非聚簇索引？"></a>30、聚簇索引？非聚簇索引？</h1><p>聚簇索引和非聚簇索引是一大类，几乎所有的索引都分为这两类。</p><p><code>聚簇索引</code>：</p><ul><li>又叫<code>簇类索引、簇集索引、聚集索引、聚类索引</code>。是<code>索引项的排列顺序和表中数据记录的排列顺序一样的索引</code>，比如新华字典按照拼音排序，索引项就是拼音，表中数据记录就是汉字，两者排序顺序是一样的，由拼音目录后面的页数也能看出来，页数是连续的；</li><li>正如新华字典中实际汉字所处的页数只有按拼音排序的这一种方式，<code>一个数据库表中也只有一个聚簇索引，表中行的物理顺序和索引中行的物理顺序是一致的</code>（也就是汉字的顺序和拼音的顺序是一致的）；</li><li>聚簇索引的<code>叶子节点存放的是每一行的数据</code>，也就是数据节点。</li></ul><p><code>非聚簇索引</code>：</p><ul><li>不是聚簇索引的二级索引，都称为非聚簇索引，也叫<code>辅助索引</code>。是指<code>索引项的排序和表中数据记录的排序不一样的索引</code>，比如新华字典还有按偏旁部首排序的方式，那么索引项就是偏旁部首，表中数据记录还是汉字，但是新华字典中汉字实际所处页数的排序只有一种就是按拼音排序，所以虽然偏旁部首也能起到索引的作用，但是它的排序和汉字的实际排序不一致，由目录后面对应的页数是不连续的也能看出来。</li><li>非聚簇索引的<code>叶子节点存放的是主键的值或者是指向数据行记录的真实物理地址</code>，所以<code>使用聚簇索引时可以直接得到数据，而使用非聚簇索引时还需要再根据主键或者行记录物理地址来获取实际数据（回表查询）</code>。</li></ul><p><code>补充</code>：InnoDB的主键索引是聚簇索引，非主键索引都是非聚簇索引；MyISAM的主键索引和非主键索引都是非聚簇索引。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.1l2rh4d0mbts.webp" alt="聚簇索引"></p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.fupp087ps8w.webp" alt="非聚簇索引"></p><h1 id="31、覆盖索引？"><a href="#31、覆盖索引？" class="headerlink" title="31、覆盖索引？"></a>31、覆盖索引？</h1><p>覆盖索引是指，<code>查询时使用了索引，并且查询的所有字段都能在索引中找到</code>，覆盖索引可以提高性能。比如：</p><ul><li><code>SELECT * FROM tb_footballer WHERE id=’xx’;</code>查询时使用了id列的主键索引，属于聚簇索引，直接返回整行数据，那么所有字段自然能够找到，属于覆盖索引，性能高；</li><li><code>SELECT id,name FROM tb_footballer WHERE name=’xx’;</code>查询时使用了name列索引，属于辅助索引（非聚簇索引），叶子节点存储的是主键id值，只经过一次索引扫描便能得到id和name信息，属于覆盖索引，性能高；</li><li><code>SELECT id,name,score FROM tb_footballer WHERE name=’xx’;</code>和上述第二种情况一样，但是一次索引扫描只能获取id和name，而对应的score还需要回表查询经过一次对应的主键索引才能查到，不属于覆盖索引，性能差。</li></ul><h1 id="32、前缀索引？"><a href="#32、前缀索引？" class="headerlink" title="32、前缀索引？"></a>32、前缀索引？</h1><p>当字段类型为字符串时，不需要索引一整串字符串，而是只对字符串的前一部分建立索引，这样的索引就叫<code>前缀索引</code>。前缀长度根据<code>索引选择性</code>来决定，索引选择性是指不重复的索引值（基数）和数据表的记录总数的比值，比值越大，索引选择性越好，性能越好。</p><h1 id="33、MySQL支持哪几种索引结构？"><a href="#33、MySQL支持哪几种索引结构？" class="headerlink" title="33、MySQL支持哪几种索引结构？"></a>33、MySQL支持哪几种索引结构？</h1><ul><li><code>B+Tree索引</code>：最常见的索引类型，大部分引擎都支持</li><li><code>Hash索引</code>：底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</li><li><code>R-Tree索引（空间索引）</code>：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</li><li><code>Full-text索引（全文索引）</code>：是一种通过建立倒排索引，快速匹配文档的方式，类似于ElasticSearch</li></ul><h1 id="34、MySQL不同存储引擎对于索引结构的支持？"><a href="#34、MySQL不同存储引擎对于索引结构的支持？" class="headerlink" title="34、MySQL不同存储引擎对于索引结构的支持？"></a>34、MySQL不同存储引擎对于索引结构的支持？</h1><table><thead><tr><th align="left">索引</th><th align="left">InnoDB</th><th align="left">MyISAM</th><th align="left">Memory</th></tr></thead><tbody><tr><td align="left">B+Tree索引</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left">Hash索引</td><td align="left">N</td><td align="left">N</td><td align="left">Y</td></tr><tr><td align="left">R-Tree索引</td><td align="left">N</td><td align="left">Y</td><td align="left">N</td></tr><tr><td align="left">Full-text索引</td><td align="left">Y（5.6版本后）</td><td align="left">Y</td><td align="left">N</td></tr></tbody></table><h1 id="35、MySQL为什么不采用二叉树和红黑树的结构来构造索引？"><a href="#35、MySQL为什么不采用二叉树和红黑树的结构来构造索引？" class="headerlink" title="35、MySQL为什么不采用二叉树和红黑树的结构来构造索引？"></a>35、MySQL为什么不采用二叉树和红黑树的结构来构造索引？</h1><p><code>如果选用二叉树作为索引结构，存在如下缺点</code>：</p><ul><li>顺序插入时，会形成一条链表，查询效率大大降低；</li><li>数据量比较大时，树的层级比较深，检索速度慢。</li></ul><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8C%E5%8F%89%E6%A0%91.y2vlplhy09s.webp" alt="二叉树"></p><p><code>选用红黑树作为索引结构，存在如下缺点</code>：</p><ul><li>数据量比较大时，树的层级比较深，检索速度慢，因为红黑树也是一棵二叉树。</li></ul><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BA%A2%E9%BB%91%E6%A0%91.4gx8swfhlew0.webp" alt="红黑树"></p><h1 id="36、B-Tree树？"><a href="#36、B-Tree树？" class="headerlink" title="36、B-Tree树？"></a>36、B-Tree树？</h1><p><code>B-Tree树</code>就是<code>B树</code>，是一种多路自平衡查找树，相较于二叉树可以有多个分支。</p><p><code>M阶B树具有如下特点</code>：</p><ul><li>所有叶子节点都在同一层，每一个节点最多存储M-1个key，并且按升序排列；</li><li>每个节点最多拥有M棵子树；</li><li>根节点至少有2棵子树，分支节点至少拥有M&#x2F;2棵子树；</li><li><code>所有键值分布在整棵树中，非叶子节点和叶子节点都会存放数据</code>。</li></ul><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/B-Tree%E6%A0%91.1eu6070tgjq8.webp" alt="B-Tree树"></p><p>B树存在如下问题：<code>每个节点中既有key又有data</code>，而每一页的存储空间是有限的，如果data数据量太大那么能存储的key就会很少，与此同时还会导致树的层级变深，检索速度变慢。</p><h1 id="37、B-Tree树？"><a href="#37、B-Tree树？" class="headerlink" title="37、B+Tree树？"></a>37、B+Tree树？</h1><p>B+Tree是B树的变体，如：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/B+Tree%E6%A0%91.rq596x6thds.webp" alt="B+Tree树"></p><p>B+Tree树与B树的区别：</p><ul><li>每个节点可以包含更多的键；</li><li><code>非叶子节点仅仅起到索引数据的作用，非叶子节点中不会存放数据</code>；</li><li><code>所有的数据都只会保存在叶子节点</code>，从而防止key和data数据量相差太大导致树层级太深的问题；</li><li>叶子节点形成一个单向链表，更易于检索。</li></ul><p>MySQL索引结构对经典的B+Tree进行了优化，在原B+Tree的基础上增加了一个指向相邻叶子节点的链表指针，形成了一个<code>环状链表</code>，从而提高区间访问的性能，利于排序。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BB%8F%E8%BF%87MySQL%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84B+Tree.5nnjprmal5w0.webp" alt="经过MySQL优化后的B+Tree"></p><h1 id="38、Hash索引？"><a href="#38、Hash索引？" class="headerlink" title="38、Hash索引？"></a>38、Hash索引？</h1><p>哈希表就是数组+链表；</p><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中；</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/Hash%E7%B4%A2%E5%BC%951.4a8zq36b0oc0.webp" alt="Hash索引1"></p><p>如果两个或多个键值映射到了同一个槽位上，就发生了hash碰撞，多余的键值就会以链表的形式继续向后关联；</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/Hash%E7%B4%A2%E5%BC%952.23ipeypxshk0.webp" alt="Hash索引2"></p><p>Hash索引的特点：</p><ul><li>只能用于对等比较（&#x3D;，in），不支持范围查询；</li><li>无法利用索引完成排序操作；</li><li>查询效率高，在不存在hash碰撞的情况下只需要一次检索就够了，效率通常要高于B+Tree树。</li></ul><h1 id="39、Full-text索引？"><a href="#39、Full-text索引？" class="headerlink" title="39、Full-text索引？"></a>39、Full-text索引？</h1><p>也叫倒排索引，把词条出现的频率和位置做一个归纳，这样就建立了一个以词条为目录项的目录，这样在查找某个词的时候就能很快的定位到该词以及该词所在的句子，类似于ElasticSearch的倒排索引。</p><h1 id="40、B-树索引和哈希索引的区别？"><a href="#40、B-树索引和哈希索引的区别？" class="headerlink" title="40、B+树索引和哈希索引的区别？"></a>40、B+树索引和哈希索引的区别？</h1><ul><li>B+树默认有序，哈希表默认无序，所以B+树利于排序，哈希表利于查询；</li><li>哈希索引只能进行等值查询，不能进行范围查询，而以上B+树都支持；</li><li>底层实现上B+树是树形结构，哈希表是线性结构。</li></ul><h1 id="41、索引中最左前缀法则是什么？"><a href="#41、索引中最左前缀法则是什么？" class="headerlink" title="41、索引中最左前缀法则是什么？"></a>41、索引中最左前缀法则是什么？</h1><p>如果索引了多列，即联合索引，那么就要遵守<code>最左前缀法则</code>，即查询从索引的最左列开始（根据创建索引时的顺序），并且<code>不得跳过索引中的列</code>，如果跳过某一列，该列后面的字段索引将会失效。</p><p>举例说明：对一张表中A、B、C三个字段建立了联合索引，那么查询时：</p><p>①只要指定条件中A存在，那么索引就不会失效；</p><p>②只存在A、B时，C部分索引失效；</p><p>③只存在A、C时，B、C都将失效。</p><p>需要注意的是对A、B、C的顺序并没有要求，比如<code>SELECT * FROM tb_footballer WHERE A=’xx’ AND B=’xx’ AND C=’xx’;</code>和<code>SELECT * FROM tb_footballer WHERE B=’xx’ AND C=’xx’ AND A=’xx’;</code>的效果是一样的。</p><h1 id="42、引起索引失效的几种情况？"><a href="#42、引起索引失效的几种情况？" class="headerlink" title="42、引起索引失效的几种情况？"></a>42、引起索引失效的几种情况？</h1><ul><li>不满足最左前缀法则；</li><li>出现范围查询（判断条件中存在&lt;或&gt;）时，范围查询右侧的列索引失效，如<code>SELECT * FROM tb_footballer WHERE A&lt;xx AND B&gt;xx;</code>那么B列索引将失效。需要注意的是&lt;&#x3D;和&gt;&#x3D;时，索引不会失效。</li><li>索引列上进行了运算操作，比如用了函数运算；</li><li>字符串类型字段使用时不加引号；</li><li>头部模糊查询，索引失效；尾部模糊查询，索引不会失效；</li><li>使用or时，or左右两侧的列都有索引时，索引才会生效；</li><li>MySQL在查询时，会评估使用索引和全表扫描哪个效率更高，从而选择效率更高的那一个。</li></ul><h1 id="43、SQL优化之插入数据"><a href="#43、SQL优化之插入数据" class="headerlink" title="43、SQL优化之插入数据"></a>43、SQL优化之插入数据</h1><ul><li>建议批量插入数据</li><li>建议手动控制事务</li><li>根据主键进行顺序插入，主键顺序插入的性能高于乱序插入</li><li>对于大批量插入数据，使用load代替insert</li></ul><h1 id="44、SQL优化之主键优化"><a href="#44、SQL优化之主键优化" class="headerlink" title="44、SQL优化之主键优化"></a>44、SQL优化之主键优化</h1><p>这个PPT写的太好，直接引用：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96.6lvj1y3vztw0.webp" alt="主键优化"></p><p>主键优化原则：</p><ul><li>尽量降低主键长度</li><li>插入数据时，尽量选择顺序插入，使用AUTO_INCREMENT自增主键</li><li>尽量不要使用UUID或其他随机号作为主键</li><li>业务操作时，避免对主键的修改</li></ul><h1 id="45、SQL优化之order-by优化"><a href="#45、SQL优化之order-by优化" class="headerlink" title="45、SQL优化之order by优化"></a>45、SQL优化之order by优化</h1><p>MySQL排序有两种方式：</p><ul><li><code>Using filesort</code>：通过索引扫描或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序</li><li><code>Using index</code>：通过有序索引顺序扫描直接返回有序数据，可见这种方式效率更高</li></ul><p>order by优化原则：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，需要在创建索引时一并指定对应的字段是升序还是降序（ASC、DESC）</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲器大小sort_buffer_size（默认256k）</li></ul><h1 id="46、SQL优化之group-by优化"><a href="#46、SQL优化之group-by优化" class="headerlink" title="46、SQL优化之group by优化"></a>46、SQL优化之group by优化</h1><p>对指定分组列建立索引，同样遵循最左前缀法则。</p><h1 id="47、SQL优化之limit优化"><a href="#47、SQL优化之limit优化" class="headerlink" title="47、SQL优化之limit优化"></a>47、SQL优化之limit优化</h1><p>limit分页原则是<code>先按序扫描所有记录，然后再丢弃不满足条件的记录</code>，所以在数据量太大时，性能较差。可以通过<code>覆盖索引+子查询</code>的方式来进行优化。<br>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_footballer <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10000</span>,<span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>可以优化为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_footballer t1,(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> tb_footballer <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10000</span>,<span class="number">20</span>) t2 <span class="keyword">WHERE</span> t1.id<span class="operator">=</span>t2.id;</span><br></pre></td></tr></table></figure><h1 id="48、MySQL中有哪几种锁？"><a href="#48、MySQL中有哪几种锁？" class="headerlink" title="48、MySQL中有哪几种锁？"></a>48、MySQL中有哪几种锁？</h1><p>全局锁、表级锁、行锁。</p><p><code>补充</code>：从事务的角度来分，锁分为：</p><ul><li><code>共享锁（S锁、读锁）</code>：一个事务对表或行加了S锁后，不会阻塞其他事务的读，但是会阻塞其他事务的写。<code>什么叫阻塞呢</code>，就是我这条语句也不会报错，会一直等待在那里不返回结果，直到事务一释放了读锁。即自己能读不能写，其他人能读能写（但是写会阻塞）；</li><li><code>排他锁（X锁、独占锁、写锁）</code>：一个事务对表或行加了写锁后，会阻塞其他事务的读和写。即自己能读能写，其他人能读能写（读写均阻塞）。</li></ul><p>理解上，事务对应用户。</p><h1 id="49、全局锁？"><a href="#49、全局锁？" class="headerlink" title="49、全局锁？"></a>49、全局锁？</h1><p><code>全局锁</code>就是对整个数据库进行加锁，加锁后整个数据库实例就处于只读状态，可用于数据库备份。<br>存在如下问题：<br>①在主库上备份，在备份期间都不能执行更新，业务就得停摆；<br>②在从库上备份，在备份期间就不能执行主库同步过来的二进制文件，导致主从延迟。</p><h1 id="50、表级锁？"><a href="#50、表级锁？" class="headerlink" title="50、表级锁？"></a>50、表级锁？</h1><p>表级锁是对整张表进行加锁。<br>表级锁分为三类：</p><h2 id="50-1、表锁"><a href="#50-1、表锁" class="headerlink" title="50.1、表锁"></a>50.1、表锁</h2><p>表锁又分为两类：</p><ul><li>表S锁（read lock）；</li><li>表X锁（write lock）。</li></ul><h2 id="50-2、元数据锁（meta-data-lock、MDL）"><a href="#50-2、元数据锁（meta-data-lock、MDL）" class="headerlink" title="50.2、元数据锁（meta data lock、MDL）"></a>50.2、元数据锁（meta data lock、MDL）</h2><ul><li>元数据锁是系统自动控制，无需显式使用，元数据可以理解为表结构，在表上有未提交的事务时，不能修改这张表的表结构，元数据锁的目的就是维护表结构的数据一致性；</li><li>当对表的数据层面进行增删改查的时候，加元数据S锁；当对表结构进行修改的时候，加元数据X锁；</li><li>这样理解，当一个事务对表执行某种操作时，数据库会根据操作的类型对表加上元数据S锁或者元数据X锁，如果加上的是元数据S锁，那么其他事务执行的操作若对应的元数据锁也是S锁则可以正常进行，不会阻塞，而其他加元数据X锁的操作就会被阻塞，直到原来的锁被释放为止。举个例子，SELECT * FROM tb_footballer;这条语句会给tb_footballer这个表加上元数据S锁，而INSERT、UPDATE、DELETE这些操作加的也是S锁，那么这些操作就能进行，然而ALTER TABLE对表加的是X锁，那么这个操作就会被阻塞，因为S锁和X锁之间是互斥的。</li><li>常见的SQL操作对应的元数据锁：</li></ul><table><thead><tr><th align="left">SQL操作</th><th align="left">锁类型</th></tr></thead><tbody><tr><td align="left">lock tables xxx read&#x2F;write</td><td align="left">SHARED_READ_ONLY&#x2F;SHARED_NO_READ_WRITE</td></tr><tr><td align="left">select、select…lock in share mode</td><td align="left">SHARED_READ</td></tr><tr><td align="left">insert、update、delete、select…for update</td><td align="left">SHARED_WRITE</td></tr><tr><td align="left">alter table…</td><td align="left">EXCLUSIVE</td></tr><tr><td align="left">补充</td><td align="left">共享锁（SHARED_READ、SHARED_WRITE）与排他锁（EXCLUSIVE）互斥</td></tr></tbody></table><h2 id="50-3、意向锁"><a href="#50-3、意向锁" class="headerlink" title="50.3、意向锁"></a>50.3、意向锁</h2><ul><li>若没有意向锁，那么一个用户在执行DML操作对表加了行锁后，另一个用户想对这张表加表锁时，就要逐行判断是否有行锁，以此来决定能否加表锁；而有了意向锁之后，在执行DML操作时不仅会对涉及的行加行锁，还会对该表加上意向锁，其他用户想对表加表锁时就只需要判断意向锁的类型而不用逐行判断行锁了。总而言之，<code>意向锁就是为了解决行锁和表锁的冲突</code>。</li><li>意向锁的类型：<ul><li><code>意向共享锁（IS）</code>：由语句select…lock in share mode添加，与表S锁兼容，与表X锁互斥；</li><li><code>意向排他锁（IX）</code>：由insert、update、delete、select…for update添加，与表S锁及表X锁都互斥；</li></ul></li><li>由意向锁的类型可知，一个用户加了IS之后，其他用户就只能对表加表S锁，而如果加的是IX，那么其他用户就不能对表加锁；</li><li>意向锁是一种不与行级锁冲突的表级锁；</li><li>意向锁之间是相互兼容的；</li><li>一旦事务提交了，意向共享锁、意向排他锁都会自动释放。</li></ul><h1 id="51、行级锁？"><a href="#51、行级锁？" class="headerlink" title="51、行级锁？"></a>51、行级锁？</h1><p>InnoDB的数据是基于索引组织的，<code>行级锁是通过对索引项加锁而不是对行记录加锁来实现的</code>。默认情况下，InnoDB使用next-key锁（即临键锁）进行搜索和索引扫描。<br>行级锁分为三类：</p><h2 id="51-1、行锁（Record-Lock）（又叫记录锁）"><a href="#51-1、行锁（Record-Lock）（又叫记录锁）" class="headerlink" title="51.1、行锁（Record Lock）（又叫记录锁）"></a>51.1、行锁（Record Lock）（又叫记录锁）</h2><ul><li><code>锁定单个行记录的锁</code>，防止其他事务对该行进行update或delete。需要注意的是<code>它锁定的是索引记录而不是整行的数据记录</code>；</li></ul><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%A1%8C%E9%94%81.104fhw80fnu8.webp" alt="行锁"></p><ul><li>行锁也分为<code>行S锁</code>和<code>行X锁</code>，兼容性与表级锁一致；</li><li>常见的SQL语句，在执行时，所加的行锁如下：</li></ul><table><thead><tr><th align="left">SQL</th><th align="left">行锁类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">INSERT</td><td align="left">X锁</td><td align="left">自动加锁</td></tr><tr><td align="left">UPDATE</td><td align="left">X锁</td><td align="left">自动加锁</td></tr><tr><td align="left">DELETE</td><td align="left">X锁</td><td align="left">自动加锁</td></tr><tr><td align="left">SELECT</td><td align="left">不加锁</td><td align="left"></td></tr><tr><td align="left">SELECT…LOCK IN SHARE MODE</td><td align="left">S锁</td><td align="left">自动加锁</td></tr><tr><td align="left">SELECT…FOR UPDATE</td><td align="left">X锁</td><td align="left">自动加锁</td></tr></tbody></table><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，临键锁会自动优化为行锁；</li><li>如果表中没有索引或者不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，即行锁升级为表锁。</li></ul><h2 id="51-2、间隙锁（Gap-Lock）"><a href="#51-2、间隙锁（Gap-Lock）" class="headerlink" title="51.2、间隙锁（Gap Lock）"></a>51.2、间隙锁（Gap Lock）</h2><ul><li>间隙锁就是<code>锁定索引记录的间隙（不包含该记录）</code>，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读；</li></ul><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%97%B4%E9%9A%99%E9%94%81.6vvt4k1y8ec0.webp" alt="间隙锁"></p><ul><li>对唯一索引进行检索时，对不存在的记录进行等值匹配，会使用间隙锁锁住大于该记录的第一个值之前的间隙（因为InnoDB采用B+树索引，叶子节点是有序的双向链表，所以索引项也是有序的）；</li><li>针对非唯一索引进行检索时，由于可能存在相同值，所以需要向右遍历至不等于该记录的第一个值，然后使用间隙锁锁住之前的间隙；</li><li>针对唯一索引进行范围检索时，会对左值加行锁，右值加临键锁；</li><li>间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一个间隙上采用间隙锁。</li></ul><h2 id="51-3、临键锁（Next-Key-Lock）"><a href="#51-3、临键锁（Next-Key-Lock）" class="headerlink" title="51.3、临键锁（Next-Key Lock）"></a>51.3、临键锁（Next-Key Lock）</h2><p>临键锁就是<code>行锁和间隙锁组合</code>，同时锁住数据和数据前面的间隙。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B8%B4%E9%94%AE%E9%94%81.2nlfjl7u1260.webp" alt="临键锁"></p><h1 id="52、锁兼容、锁互斥是什么？"><a href="#52、锁兼容、锁互斥是什么？" class="headerlink" title="52、锁兼容、锁互斥是什么？"></a>52、锁兼容、锁互斥是什么？</h1><p>当多个事务同时对同一表或行执行操作时，会根据操作的类型对该表或行加上对应的锁类型，后续操作若加上的锁或待获取的锁和已有锁类型兼容，则可以立即执行，若和已有锁互斥，则会阻塞。</p><p>锁之间的兼容性：</p><table><thead><tr><th align="left">兼容性</th><th align="left">S</th><th align="left">X</th><th align="left">IS</th><th align="left">IX</th></tr></thead><tbody><tr><td align="left">S</td><td align="left">Y</td><td align="left">N</td><td align="left">Y</td><td align="left">N</td></tr><tr><td align="left">X</td><td align="left">N</td><td align="left">N</td><td align="left">N</td><td align="left">N</td></tr><tr><td align="left">IS</td><td align="left">Y</td><td align="left">N</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left">IX</td><td align="left">N</td><td align="left">N</td><td align="left">Y</td><td align="left">Y</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TODO：一文整理数据库语句：xxx&lt;/p&gt;
&lt;h1 id=&quot;1、关系型数据库和非关系型数据库的区别？数据库和非关系型数据库的区别？&quot;&gt;&lt;a href=&quot;#1、关系型数据库和非关系型数据库的区别？数据库和非关系型数据库的区别？&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="数据库" scheme="https://lisj98.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库理论" scheme="https://lisj98.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>多线程理论</title>
    <link href="https://lisj98.github.io/2022/09/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    <id>https://lisj98.github.io/2022/09/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA/</id>
    <published>2022-09-08T14:40:40.000Z</published>
    <updated>2022-09-16T00:47:30.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-进程和线程的区别？"><a href="#1-进程和线程的区别？" class="headerlink" title="1. 进程和线程的区别？"></a>1. 进程和线程的区别？</h1><ul><li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位，一个进程包含多个线程；</li><li>并发性：多个进程可以并发执行，多个线程也可以并发执行；</li><li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有资源，但可以访问所属进程的资源；</li><li>系统开销：在创建和撤销进程的时候，都要为其分配和释放资源，所以创建和撤销进程的资源要大于创建和撤销线程的资源；</li><li>内存空间：进程有独立的地址空间，线程有自己的堆栈和局部变量，但没有独立的地址空间。</li></ul><h1 id="2-什么叫线程安全？"><a href="#2-什么叫线程安全？" class="headerlink" title="2. 什么叫线程安全？"></a>2. 什么叫线程安全？</h1><p>如果代码所在进程中有多个线程在同时运行，并且这些线程会同时运行某一段代码，如果每次运行的结果和单线程运行这段代码的结果一致，而且各个变量的值也和预期的一样，那么这段代码就是线程安全的。</p><h1 id="3-线程的几种状态？"><a href="#3-线程的几种状态？" class="headerlink" title="3. 线程的几种状态？"></a>3. 线程的几种状态？</h1><ul><li><code>新建状态（NEW）</code>：新创建了一个线程对象；</li><li><code>就绪状态（RUNNABLE）</code>：线程处于可运行状态，除了CPU之外，其他的运行所需资源都已全部获得；</li><li><code>运行状态（RUNNING）</code>：就绪状态的线程获得了CPU的使用权，程序代码开始执行；</li><li><code>阻塞状态（BLOCKED）</code>：线程因某种原因而放弃CPU，暂时停止运行。阻塞的情况分三种：<ul><li><code>无条件等待阻塞</code>：调用了wait()、join()、LockSupport.park等方法、等待获得资源锁、等待某个I&#x2F;O请求完成。wait()需要另一线程调用notify()或notifyAll()唤醒；join()需要等待线程执行特定时间；</li><li><code>特定时间等待阻塞</code>：调用了sleep()、wait(time)、join(time)、LockSupport.parkNanos、LockSupport.parkUntil等方法。</li></ul></li><li><code>终止状态（TERMINATED）</code>：线程执行完毕或因异常退出了run()方法，该线程结束生命周期。</li></ul><h1 id="4-Java创建多线程后，调用start-和run-方法的区别？"><a href="#4-Java创建多线程后，调用start-和run-方法的区别？" class="headerlink" title="4. Java创建多线程后，调用start()和run()方法的区别？"></a>4. Java创建多线程后，调用start()和run()方法的区别？</h1><p>调用start()方法会执行一系列诸如线程状态检查、加入其对应的线程组、判断是否启动成功并维护线程组等动作，然后线程会被放到等待队列，等待CPU调度，这意味着<code>该线程并不会马上执行</code>，start()方法体中会调用到具体任务的run()方法；</p><p>而单单调用run()方法的话只是<code>普普通通地调用Runnable对象的一个方法，并没有经历start()方法所做的线程的准备工作</code>，和普通对象调用普通方法一样。<br><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%B0%83%E7%94%A8run%E5%92%8Cstart%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB.21ggpijdyqow.webp" alt="调用run和start方法的区别"><br><code>补充</code>：<code>定义任务用Runnable或Callable接口</code>，区别是前者不产生返回值，后者产生返回值，后者通常结合<code>Future</code>和<code>FutureTask</code>使用，用于异步获取结果，调用ExecutorService对象的submit()方法会产生Future对象，可以用isDone()方法来查询Future是否完成，用get()方法来获取结果；<code>定义线程用Thread</code>。</p><h1 id="5-对Future和FutureTask的理解？"><a href="#5-对Future和FutureTask的理解？" class="headerlink" title="5. 对Future和FutureTask的理解？"></a>5. 对Future和FutureTask的理解？</h1><ul><li><code>Future</code>是一个接口，为Runnable或Callable任务提供：①取消②查询是否取消成功③查询是否执行成功④获取执行结果的功能；</li><li><code>FutureTask</code>是Future接口的实现类，它既可以作为一个Runnable任务，也可以作为一个Future，它具备Future接口的所有功能，还额外提供了许多其他功能，例如设置结果，处理可能发生的中断等。</li></ul><p><code>Future模式的思想</code>就是在子线程执行的时候，主线程不阻塞仍继续执行，等到主线程需要子线程的执行结果时再去获取子线程的执行结果（此时子线程没有执行完成的话就会阻塞直至完成），主线程还可以根据一定的逻辑对子线程进行操作，例如设置是否需要阻塞等待子线程完成。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Future%E6%96%B9%E6%B3%95.6us4lzm0uys0.webp" alt="Future方法"></p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/FutureTask%E6%96%B9%E6%B3%95.14tsdz50pzs0.webp" alt="FutureTask方法"></p><h1 id="6-怎么解决共享资源竞争，实现线程安全？"><a href="#6-怎么解决共享资源竞争，实现线程安全？" class="headerlink" title="6. 怎么解决共享资源竞争，实现线程安全？"></a>6. 怎么解决共享资源竞争，实现线程安全？</h1><ul><li>使用<code>synchronized</code>关键字修饰方法或代码块：只有获得锁的线程才能访问资源；</li><li>使用<code>显示的Lock对象</code>对代码块进行加锁释放锁：只有获得锁的线程才能访问资源；</li><li>使用<code>原子类（AtomicInteger，AtomicLong，AtomicReference）</code>来保证原子性：原子操作是不能被线程调度机制中断的操作，一旦开始，那么就会在线程上下文切换之前完成，这样就保证了其他线程来不及修改这个变量，仅适用于简单操作，<code>原子性</code>就是其他线程不能对本线程做出的修改进行干涉，即不能中途插入进来改变变量的值；</li><li>使用<code>volatile</code>修饰域：只要某个线程对这个域进行了修改，其他的线程都将看到变化；</li><li>使用<code>线程本地存储（ThreadLocal）</code>：根除对变量的共享，为使用相同变量的每个不同的线程都创建不同的存储。</li></ul><h1 id="7-synchronized，volatile和CAS的区别？"><a href="#7-synchronized，volatile和CAS的区别？" class="headerlink" title="7. synchronized，volatile和CAS的区别？"></a>7. synchronized，volatile和CAS的区别？</h1><ul><li>synchronized保证可见性和原子性，会导致其他线程阻塞，属于悲观锁；</li><li>volatile保证可见性，不保证原子性，禁止指令重排，不需要加锁；</li><li>CAS保证可见性及原子性，不会导致其他线程阻塞，属于乐观锁。</li></ul><p><code>补充</code>：<br><code>Java内存模型</code>：Java所有变量都存储在主内存中，所有线程都可以访问；每个线程创建时，JVM会为其创建一个私有的工作内存，里面保存该线程使用到的变量的副本；线程对变量的操作都必须在自己的工作内存中进行，读取时从主内存将变量读取到工作内存中，在工作内存中修改完毕后再刷新到主内存中。<br><code>指令重排</code>：是指代码的执行过程有时并不是按照代码书写过程来的，编译器和CPU可以保证在输出结果一致的情况下对代码进行重排序优化，以提高执行效率。<br><code>内存屏障</code>：内存屏障是一个CPU指令，可以禁止指令重排，它可以确保屏障前的指令不会排到屏障后面，屏障后的指令不会排到屏障前面，即在内存屏障这条指令执行时，它前面的指令都已执行完毕。<br><code>volatile和内存屏障的关系</code>：当用volatile修饰一个变量时，会在对变量进行读操作前插入一个读屏障指令，在对变量进行写操作后插入一个写屏障指令。<br><code>volatile为什么不能保证原子性呢</code>：修改volatile变量分为四步，①从主内存中读取变量到工作内存中；②修改变量值；③写回到工作内存；④刷新回主内存。举个例子，一个变量i被volatile修饰，两个线程想对这个变量修改，都对其进行自增操作也就是i++，在字节码及底层，i++被抽象为三个操作：即先取值，再自加，再赋值三个操作，线程A首先得到了i的初始值100，但是还没来得及修改，就阻塞了，这时线程B开始了，它也得到了i的值，由于i的值未被修改，即使是被volatile修饰，主存的变量还没变化，那么线程B得到的值也是100，之后对其进行加1操作，得到101后，将新值写入到缓存中，再刷入主存中。根据可见性的原则，这个主存的值可以被其他线程可见。问题来了，线程A已经读取到了i的值为100，也就是说读取的这个原子操作已经结束了，接下来就不会再读取而是直接对变量进行改动了，所以这个可见性来的有点晚，即线程A不知道变量i已经被线程B修改了还在傻乎乎地延续它自己的修改，线程A阻塞结束后，继续将100这个值加1，得到101，再将值写到缓存，最后刷入主存，所以即便是volatile具有可见性，也不能保证对它修饰的变量具有原子性。</p><h1 id="8-用volatile修饰的变量和用atomic修饰的变量有什么不同？"><a href="#8-用volatile修饰的变量和用atomic修饰的变量有什么不同？" class="headerlink" title="8. 用volatile修饰的变量和用atomic修饰的变量有什么不同？"></a>8. 用volatile修饰的变量和用atomic修饰的变量有什么不同？</h1><p>用volatile修饰的变量不具有原子性，用atomic修饰的变量具有原子性。</p><h1 id="9-使用volatile关键字的场景？"><a href="#9-使用volatile关键字的场景？" class="headerlink" title="9. 使用volatile关键字的场景？"></a>9. 使用volatile关键字的场景？</h1><ul><li>对变量的写操作不依赖于当前值，比如自增、自减等操作；</li><li>该变量不宜和其他变量位于同一表达式中。</li></ul><p>总而言之，就是需要满足原子性操作的前提。</p><h1 id="10-synchronized和Lock的区别？"><a href="#10-synchronized和Lock的区别？" class="headerlink" title="10. synchronized和Lock的区别？"></a>10. synchronized和Lock的区别？</h1><ul><li>synchronized是一个关键字，而Lock是一个接口；</li><li>synchronized是隐式的加锁，Lock是显式的加锁；</li><li>synchronized可以作用在方法和代码块上，而Lock只能作用在代码块上；</li><li>synchronized是阻塞式加锁，而Lock中的tryLock()支持非阻塞式加锁；</li><li>synchronized没有超时机制，而Lock中的tryLock()可以支持超时机制；</li><li>synchronized不可中断，而Lock中的lockInterruptibly()可中断的获取锁。（ReentrantLock.lockInterruptibly()允许在等待时由其它线程调用等待线程的Thread.interrupt()方法来中断等待线程的等待而直接返回，这时不用获取锁，而会抛出一个InterruptedException。ReentrantLock.lock()方法不允许Thread.interrupt()中断，使检测到Thread.isInterrupted()一样会继续尝试获取锁，失败则继续休眠。只是在最后获取锁成功后再把当前线程置为interrupted状态,然后再中断线程）；</li><li>synchronized采用的是monitor对象监视器，Lock的底层原理是AQS；</li><li>synchronized只有一个同步队列和一个等待队列，而Lock有一个同步队列，可以有多个等待队列（同步队列：排队取锁的线程所在的队列；等待队列：调用wait()方法后，线程会从同步队列转移到等待队列）；</li><li>synchronized是非公平锁，而Lock可以是公平锁也可以是非公平锁；</li><li>synchronized用notify()方法进行唤醒，而Lock用condition唤醒；</li><li>Lock有ReadWriteLock支持并发读。</li></ul><h1 id="11-对wait-，notify-，和notifyAll-的理解？"><a href="#11-对wait-，notify-，和notifyAll-的理解？" class="headerlink" title="11. 对wait()，notify()，和notifyAll()的理解？"></a>11. 对wait()，notify()，和notifyAll()的理解？</h1><ul><li>wait()会在等待外部事件产生变化的时候将任务挂起，并且只有在notify()或notifyAll()发生时，即发生了某些令人感兴趣的事件时，这个任务才会被唤醒并重新执行；</li><li>wait()方法释放锁，notify()或notifyAll()方法加锁；</li><li>只能在同步控制方法或同步代码块（即用synchronized修饰）里调用wait()，notify()或notifyAll()方法；</li><li>在调用wait()，notify()或notifyAll()方法前必须先获得对象的锁；</li><li>notify()唤醒单个线程，但是不能指定具体条件，所以只有一个线程在等待时（即只有一个线程调用了wait()方法）才适用，notifyAll()唤醒所有等待线程（即所有调用了wait()方法的线程）。</li></ul><h1 id="12-wait-和sleep-的区别？"><a href="#12-wait-和sleep-的区别？" class="headerlink" title="12. wait()和sleep()的区别？"></a>12. wait()和sleep()的区别？</h1><ul><li>调用sleep()方法会导致此线程暂停执行指定时间，将CPU时间片让给其他线程，但是它<code>不会释放已获得的对象锁</code>；</li><li>调用wait()方法<code>会释放对象锁</code>，只有针对此对象调用notify()或notifyAll()方法后线程才会继续执行。</li></ul><h1 id="13-对yield-，join-的理解？"><a href="#13-对yield-，join-的理解？" class="headerlink" title="13. 对yield()，join()的理解？"></a>13. 对yield()，join()的理解？</h1><ul><li>yield()方法用于暂停正在执行的线程，将CPU的控制权转交给其他线程，本线程<code>进入就绪状态（注意不是阻塞状态）</code>，意在合理控制线程的执行流程；</li><li>join()方法可理解为<code>插队</code>，当一个线程需要等待另一个线程的返回结果时，就需要用到该方法，调用该方法的线程的优先级达到最高，其他线程要等待该线程执行完毕。</li></ul><h1 id="14-Java中什么是竞态条件？"><a href="#14-Java中什么是竞态条件？" class="headerlink" title="14. Java中什么是竞态条件？"></a>14. Java中什么是竞态条件？</h1><p>当多个线程访问同一资源时，如果对线程访问资源的顺序有要求，就称存在竞态条件。</p><h1 id="15-定时线程的使用？"><a href="#15-定时线程的使用？" class="headerlink" title="15. 定时线程的使用？"></a>15. 定时线程的使用？</h1><ul><li>使用定时器Timer类；</li><li>使用定时调度线程池ScheduledExecutorService。</li></ul><h1 id="16-线程同步常见方法？"><a href="#16-线程同步常见方法？" class="headerlink" title="16. 线程同步常见方法？"></a>16. 线程同步常见方法？</h1><p>sleep()，wait()，notify()，notifyAll()，await()，signal()，signalAll()。</p><h1 id="17-如何停止一个线程？"><a href="#17-如何停止一个线程？" class="headerlink" title="17. 如何停止一个线程？"></a>17. 如何停止一个线程？</h1><ul><li>run()方法或call()方法执行完后线程自动停止；</li><li>使用interrupt()方法中断线程。</li></ul><h1 id="18-interrupt-，interrupted-，isInterrupted-方法的区别？"><a href="#18-interrupt-，interrupted-，isInterrupted-方法的区别？" class="headerlink" title="18. interrupt()，interrupted()，isInterrupted()方法的区别？"></a>18. interrupt()，interrupted()，isInterrupted()方法的区别？</h1><ul><li><code>interrupt()</code>方法用于中断线程，但是仅仅是将线程的中断状态设置为ture，线程是否真的中断需要线程自己时不时的判断这个状态来决定。具体地说，当一个线程调用interrupt()方法时，①如果线程处于阻塞状态（sleep()，wait()，join()等），那么线程将立即退出阻塞状态，中断标志位复位为false，并抛出一个InterruptedException异常；②如果线程处于I&#x2F;O阻塞状态，那么中断标志位将置为true，并抛出一个ClosedByInterruptException异常(ClosedByInterruptException异常不是InterruptedException异常)；③如果线程处于NIO阻塞状态，那么中断标志位将置为true，并立即结束轮询操作；④如果线程处于正常状态，那么中断标志位将置为true。也就是说，线程检查到中断标志位为true时，就自行停止线程，处于阻塞状态的线程在检测到InterruptedException异常后，需要在catch中停止线程。</li><li><code>interrupted()</code>方法用于返回当前线程的中断状态，并且会清除中断标志（即中断标志复位为false），也就是说，如果一个被中断线程（中断标志为true）调用了该方法，那么返回的结果是true，但是当前线程的中断状态标志被清除为false了，下一次再调用该方法返回的状态结果就是false了。</li><li><code>isInterrupted()</code>方法用于返回调用该方法的线程对象所对应的线程的中断状态，但是它不会修改中断标志。interrupted()方法和isInterrupted()方法都是用来返回线程的中断状态的，区别就在于作用的线程对象不同，还有是否要清除中断标志状态位。</li></ul><p>中断标志位的判断：中断线程时，当线程抛出了一个InterruptedException异常，或者调用了interrupted()方法时，中断标志位会被复位为false，其他时候都为true。</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/interrupt()%E3%80%81interrupted()%E3%80%81isInterrupted()%E5%8C%BA%E5%88%AB.78005z3pai00.webp" alt="interrupt()、interrupted()、isInterrupted()区别"></p><h1 id="19-线程池的优点？"><a href="#19-线程池的优点？" class="headerlink" title="19. 线程池的优点？"></a>19. 线程池的优点？</h1><ul><li>重用存在的线程，减少开销；</li><li>可有效地控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免阻塞；</li><li>可提供定时执行，并发数控制等功能。</li></ul><h1 id="20-实现多线程有哪些方式（线程的创建方式）？"><a href="#20-实现多线程有哪些方式（线程的创建方式）？" class="headerlink" title="20. 实现多线程有哪些方式（线程的创建方式）？"></a>20. 实现多线程有哪些方式（线程的创建方式）？</h1><ul><li>实现Runnable接口，重写run()方法，再将Runnable对象传给Thread的构造函数；</li><li>实现Callable接口，重写call()方法，再结合Future接口，将Future对象传给Thread的构造函数；</li><li>继承Thread类，重写run()方法，Thread实现了Runnable接口，因此含有run()方法；</li><li>使用线程池。</li></ul><h1 id="21-什么是乐观锁和悲观锁？"><a href="#21-什么是乐观锁和悲观锁？" class="headerlink" title="21. 什么是乐观锁和悲观锁？"></a>21. 什么是乐观锁和悲观锁？</h1><ul><li><code>乐观锁</code>：就像它的名字一样，对并发间操作产生的线程安全问题持乐观状态，它认为竞争不总是会发生，因此它不需要持有锁，将比较-替换两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，则进行相应的重试机制；</li><li><code>悲观锁</code>：还是像它的名字一样，对并发间操作产生的线程安全问题持悲观状态，它认为竞争总是会发生，因此每次对某资源进行操作时，总是会对资源进行加锁，除非它释放锁，不然别的线程只有一直等待。</li></ul><h1 id="22-什么叫死锁？"><a href="#22-什么叫死锁？" class="headerlink" title="22. 什么叫死锁？"></a>22. 什么叫死锁？</h1><p>某个线程在等待另一个线程，而后者又等待别的线程，这样一直下去，直到这个链条上的线程又在等待第一个线程释放锁，这就造成了各个线程之间相互等待无法释放锁，导致线程无法继续执行下去，这被称为死锁。</p><h1 id="23-产生死锁的四个必要条件？"><a href="#23-产生死锁的四个必要条件？" class="headerlink" title="23. 产生死锁的四个必要条件？"></a>23. 产生死锁的四个必要条件？</h1><ul><li><code>互斥条件</code>：线程使用的资源中至少有一个是不能共享的；</li><li><code>请求与保持条件</code>：一个线程因请求资源而阻塞时，对已获得的资源保持不放；</li><li><code>不剥夺条件</code>：资源不能被线程强行抢占；</li><li><code>循环等待条件</code>：若干线程之间形成一种头尾相连的循环等待资源关系。</li></ul><p>同时满足以上四个条件时，就会产生死锁。</p><h1 id="24-导致死锁的原因？"><a href="#24-导致死锁的原因？" class="headerlink" title="24. 导致死锁的原因？"></a>24. 导致死锁的原因？</h1><ul><li>资源竞争不当</li><li>线程获取锁的顺序不当</li></ul><h1 id="25-守护（后台）线程和非守护线程的区别？"><a href="#25-守护（后台）线程和非守护线程的区别？" class="headerlink" title="25. 守护（后台）线程和非守护线程的区别？"></a>25. 守护（后台）线程和非守护线程的区别？</h1><p><code>守护线程</code>是指程序运行的时候在后台提供一种通用服务的线程。当所有的非守护线程结束时，程序也就终止了，也就是JVM停止运行了，同时会杀死进程中的所有守护线程，换句话说，只要有任何非守护线程还在运行，程序就不会终止，守护线程也不会被干掉。守护线程的一个例子就是垃圾回收器，只要JVM不停止，垃圾收集器就会一直运行下去。</p><h1 id="26-什么是多线程的上下文切换？"><a href="#26-什么是多线程的上下文切换？" class="headerlink" title="26. 什么是多线程的上下文切换？"></a>26. 什么是多线程的上下文切换？</h1><p>多线程的上下文切换是指CPU的控制权由一个正在运行的线程切换到另一个处于就绪状态并等待CPU执行权的线程的过程。</p><h1 id="27-怎么唤醒一个阻塞的线程？"><a href="#27-怎么唤醒一个阻塞的线程？" class="headerlink" title="27. 怎么唤醒一个阻塞的线程？"></a>27. 怎么唤醒一个阻塞的线程？</h1><ul><li>sleep()或join()导致的阻塞：等待时间完成或上一个线程执行完成；</li><li>wait()：使用notify()或notifyAll()。</li></ul><h1 id="28-线程池中execute-和submit-方法的区别？"><a href="#28-线程池中execute-和submit-方法的区别？" class="headerlink" title="28. 线程池中execute()和submit()方法的区别？"></a>28. 线程池中execute()和submit()方法的区别？</h1><ul><li>execute()是Executor接口中的方法，submit()是ExecutorService接口中的方法，ExecutorService接口继承了Executor接口；</li><li>execute()只能接受Runnable任务参数，submit()既可以接受Runnable任务参数也可以接受Callable任务参数；</li><li>execute()没有返回值，submit()返回Future类型对象。</li></ul><h1 id="29-如果提交任务时，线程池队列已满，这时会发生什么？"><a href="#29-如果提交任务时，线程池队列已满，这时会发生什么？" class="headerlink" title="29. 如果提交任务时，线程池队列已满，这时会发生什么？"></a>29. 如果提交任务时，线程池队列已满，这时会发生什么？</h1><p>非定长的队列会先扩容，扩容到不能再扩容了就调用拒绝策略，定长的线程池队列会直接调用拒绝策略。</p><h1 id="30-线程池的类型？"><a href="#30-线程池的类型？" class="headerlink" title="30. 线程池的类型？"></a>30. 线程池的类型？</h1><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%B1%BB%E5%9E%8B.48aamkpke2g0.webp" alt="线程池的类型"><br><code>补充</code>：7.默认线程池修改<br><code>ThreadPool threadPoolExecutor = new ThreadPoolExecutor(参数);</code></p><h1 id="31-线程池的几个重要参数？"><a href="#31-线程池的几个重要参数？" class="headerlink" title="31. 线程池的几个重要参数？"></a>31. 线程池的几个重要参数？</h1><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0.3wr65k37cns0.webp" alt="线程池的几个重要参数"></p><h1 id="32-线程池的阻塞队列有哪些？"><a href="#32-线程池的阻塞队列有哪些？" class="headerlink" title="32. 线程池的阻塞队列有哪些？"></a>32. 线程池的阻塞队列有哪些？</h1><table><thead><tr><th align="left">线程池类型</th><th align="left">队列类型</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><strong>newCachedThreadPool</strong></td><td align="left"><strong>SynchronousQueue</strong></td><td align="left">同步队列，无缓冲，拿一个出来，放一个进去，例如生产者-消费者模式</td></tr><tr><td align="left"><strong>newFixedThreadPool</strong></td><td align="left"><strong>LinkedBlockingQueue</strong></td><td align="left"></td></tr><tr><td align="left"><strong>newScheduledThreadPool</strong></td><td align="left"><strong>DelayedWorkQueue</strong></td><td align="left"></td></tr><tr><td align="left"><strong>newSingleThreadExecutor</strong></td><td align="left"><strong>LinkedBlockingQueue</strong></td><td align="left"></td></tr><tr><td align="left"><strong>newSingleThreadScheduledExecutor</strong></td><td align="left"><strong>DelayedWorkQueue</strong></td><td align="left"></td></tr><tr><td align="left"><strong>newWorkStealingPool</strong></td><td align="left">可使用多种队列，每个线程对应一种队列</td><td align="left"></td></tr><tr><td align="left"><strong>ThreadPoolExecutor</strong></td><td align="left">自行通过参数指定</td><td align="left">默认</td></tr></tbody></table><h1 id="33-线程池的拒绝策略有哪些？"><a href="#33-线程池的拒绝策略有哪些？" class="headerlink" title="33. 线程池的拒绝策略有哪些？"></a>33. 线程池的拒绝策略有哪些？</h1><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.3cezqfohock0.webp" alt="线程池的拒绝策略"></p><h1 id="34-锁到底锁的是什么？"><a href="#34-锁到底锁的是什么？" class="headerlink" title="34. 锁到底锁的是什么？"></a>34. 锁到底锁的是什么？</h1><p>可以这样理解，一段synchronized的代码被一个线程执行之前，它要先拿到执行这段代码的权限，在Java里就是拿到某个同步对象的锁(一个对象只有一把锁)；如果这个时候同步对象的锁被其他线程拿走了，它(这个线程)就只能等了(线程阻塞在锁池等待队列中)。 取到锁后，它就开始执行同步代码(被synchronized修饰的代码)；线程执行完同步代码后马上就把锁还给同步对象，其他在锁池中等待的某个线程就可以拿到锁执行同步代码了。这样就保证了同步代码在同一时刻只有一个线程在执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-进程和线程的区别？&quot;&gt;&lt;a href=&quot;#1-进程和线程的区别？&quot; class=&quot;headerlink&quot; title=&quot;1. 进程和线程的区别？&quot;&gt;&lt;/a&gt;1. 进程和线程的区别？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;调度：线程作为调度和分配的基本单位，进程作为拥有资源</summary>
      
    
    
    
    <category term="多线程" scheme="https://lisj98.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程理论" scheme="https://lisj98.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>IO理论</title>
    <link href="https://lisj98.github.io/2022/09/08/IO%E7%90%86%E8%AE%BA/"/>
    <id>https://lisj98.github.io/2022/09/08/IO%E7%90%86%E8%AE%BA/</id>
    <published>2022-09-08T14:32:19.000Z</published>
    <updated>2022-09-08T15:19:34.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-谈谈你对IO流的理解？"><a href="#1-谈谈你对IO流的理解？" class="headerlink" title="1.    谈谈你对IO流的理解？"></a>1.    谈谈你对IO流的理解？</h1><p>设备之间的传输需要媒介，流正是Java提供的媒介。在Java IO中读取和输入数据是面向流（Stream）的，流就像一条存在于各种输入输出设备之间的河流一样，这条河流永不停止的向前流动（普通IO流是单向的，NIO流是双向的），开发人员将程序运行过程中需要的各种数据从数据源写入到流中，这条河流带着数据不断向前流动，正如我们只能舀起河流中我们正前方的水一样，我们也只能触碰到流的一个横截面，程序需要数据时就可以直接从流中获取（字节流直接从河流中取数据，字符流需要先将河流中的数据取出来放到一个缓冲区中，再从缓冲区中取），也可将流中的数据写出到某些文本文件等媒体中。</p><h1 id="2-Java中有几种类型的流？"><a href="#2-Java中有几种类型的流？" class="headerlink" title="2.    Java中有几种类型的流？"></a>2.    Java中有几种类型的流？</h1><ul><li>按照流的方向分：<ul><li><code>输入流</code>：写入，将数据从数据源读到流中；</li><li><code>输出流</code>：写出，将数据从流中写出到数据源中；</li></ul></li><li>按照实现功能分：<ul><li><code>节点流</code>：即普通的输入输出流；</li><li><code>处理流</code>（也可称为<code>过滤流</code>）：在节点流的基础上加以包装，提供一些新的功能的流；</li></ul></li><li>按照传输数据的单位分：<ul><li><code>字节流</code>：传输单位为字节，数据按照8位传输，不经过缓冲区（内存）；</li><li><code>字符流</code>：传输单位为字符，数据按照16位传输，需要经过缓冲区。</li></ul></li></ul><h1 id="3-常见的IO流类型？"><a href="#3-常见的IO流类型？" class="headerlink" title="3.    常见的IO流类型？"></a>3.    常见的IO流类型？</h1><ul><li>字节输入输出流</li></ul><table><thead><tr><th align="left">类</th><th align="left">功能</th><th align="left">对应的OutputStream</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;节点流&#x3D;&#x3D;</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><strong>ByteArrayInputStream</strong></td><td align="left">将字符数组转换成InputStream</td><td align="left"><strong>ByteArrayOutputStream</strong></td><td align="left">将OutputStream写出为字符数组</td></tr><tr><td align="left"><strong>StringBufferInputStream</strong></td><td align="left">将String转换成InputStream</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><strong>FileInputStream</strong></td><td align="left">从文件中读取信息到流中</td><td align="left"><strong>FileOutputStream</strong></td><td align="left">将信息写至文件中</td></tr><tr><td align="left"><strong>PipedInputStream</strong></td><td align="left">用于多线程中的数据源，一个线程使用 PipedInputStream，另一个线程使用 PipedOutputStream，实现线程间通信</td><td align="left"><strong>PipedOutputStream</strong></td><td align="left">用于多线程中的数据源，一个线程使用 PipedInputStream，另一个线程使用 PipedOutputStream，实现线程间通信</td></tr><tr><td align="left"><strong>SequenceInputStream</strong></td><td align="left">用于顺序读取各个输入流</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><strong>FilterInputStream</strong></td><td align="left">处理流的抽象父类</td><td align="left"><strong>FilterOutputStream</strong></td><td align="left">处理流的抽象父类</td></tr><tr><td align="left">&#x3D;&#x3D;处理流&#x3D;&#x3D;</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><strong>DataInputStream</strong></td><td align="left">用于读取基本Java数据类型</td><td align="left"><strong>DataOutputStream</strong></td><td align="left">用于输出基本Java数据类型</td></tr><tr><td align="left"><strong>BufferedInputStream</strong></td><td align="left">缓冲区</td><td align="left"><strong>BufferedOutputStream</strong></td><td align="left">缓冲区</td></tr><tr><td align="left"><strong>LineNumberInputStream</strong></td><td align="left">跟踪输入流中的行号</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><strong>PushbackInputStream</strong></td><td align="left">能弹出一个字节的缓冲区，因此可以将读到的最后一个字符回退</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><strong>PrintStream</strong></td><td align="left">用于产生格式化输出</td></tr></tbody></table><ul><li>字符输入输出流</li></ul><table><thead><tr><th align="left">字节流</th><th align="left">对应的字符流</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;节点流&#x3D;&#x3D;</td><td align="left"></td></tr><tr><td align="left"><strong>InputStream</strong></td><td align="left"><strong>Reader</strong>(适配器类：InputStreamReader，把InputStream转换为Reader)</td></tr><tr><td align="left"><strong>OutputStream</strong></td><td align="left"><strong>Writer</strong>(适配器类：OutputStreamWriter，把OutputStream转换为Writer)</td></tr><tr><td align="left"><strong>FileInputStream</strong></td><td align="left"><strong>FileReader</strong></td></tr><tr><td align="left"><strong>FileOutputStream</strong></td><td align="left"><strong>FileWriter</strong></td></tr><tr><td align="left"><strong>StringBufferInputStream</strong>(已弃用)</td><td align="left"><strong>StringReader</strong></td></tr><tr><td align="left"></td><td align="left"><strong>StringWriter</strong></td></tr><tr><td align="left"><strong>ByteArrayInputStream</strong></td><td align="left"><strong>CharArrayReader</strong></td></tr><tr><td align="left"><strong>ByteArrayOutputStream</strong></td><td align="left"><strong>CharArrayWriter</strong></td></tr><tr><td align="left"><strong>PipedInputStream</strong></td><td align="left"><strong>PipedReader</strong></td></tr><tr><td align="left"><strong>PipedOutputStream</strong></td><td align="left"><strong>PipedWriter</strong></td></tr><tr><td align="left">&#x3D;&#x3D;处理流&#x3D;&#x3D;</td><td align="left"></td></tr><tr><td align="left"><strong>FilterInputStream</strong></td><td align="left"><strong>FilterReader</strong></td></tr><tr><td align="left"><strong>FilterOutputStream</strong></td><td align="left"><strong>FilterWriter</strong></td></tr><tr><td align="left"><strong>BufferedInputStream</strong></td><td align="left"><strong>BufferedReader</strong></td></tr><tr><td align="left"><strong>BufferedOutputStream</strong></td><td align="left"><strong>BufferedWriter</strong></td></tr><tr><td align="left"><strong>DataInputStream</strong></td><td align="left"><strong>DataInputStream</strong>(使用read()方法时)；<strong>BufferedReader</strong>(使用readLine()方法时)</td></tr><tr><td align="left"><strong>PrintStream</strong></td><td align="left"><strong>PrintWriter</strong></td></tr><tr><td align="left"><strong>LineNumberInputStream</strong>(已弃用)</td><td align="left"><strong>LineNumberReader</strong></td></tr><tr><td align="left"><strong>StreamTokenizer</strong></td><td align="left"><strong>StreamTokenizer</strong>(使用接受Reader的构造器)</td></tr><tr><td align="left"><strong>PushbackInputStream</strong></td><td align="left"><strong>PushbackReader</strong></td></tr></tbody></table><p><code>补充</code>：最明智的做法是尽量尝试使用Reader和Writer，一旦发现程序无法成功编译，则转而使用InputStream和OutputStream。<br>InputStream实现了Closeable接口，含有close()方法，用于关闭流；<br>OutputStream实现了Closeable和Flushable接口，含有close()和flush()方法，用于关闭流和将数据刷新到文件中；<br>Reader实现了Readable和Closeable接口，含有read()和close()方法，用于读取资源到流中以及关闭流；<br>Writer实现了Appendable、Closeable和Flushable，含有append()、close()和flush()方法，用于向流中追加自定义字符序列，关闭流以及刷新数据到文件中。</p><h1 id="4-RandomAccessFile类？"><a href="#4-RandomAccessFile类？" class="headerlink" title="4.    RandomAccessFile类？"></a>4.    RandomAccessFile类？</h1><p><code>不属于InputStream、OutputStream、Reader或Writer的继承体系，是一个独立的类</code>，由于实现了DataInput接口，因此具有<code>读</code>功能，实现了DataOutput接口，因此具有<code>写</code>功能，同时还具备<code>查询文件相关信息</code>如文件大小，编码等功能。</p><h1 id="5-什么是缓冲区？"><a href="#5-什么是缓冲区？" class="headerlink" title="5.    什么是缓冲区？"></a>5.    什么是缓冲区？</h1><p><code>缓冲区</code>就是一段特殊的内存区域，当程序需要频繁地访问或操作某个资源，而这个资源位于外部文件或数据库中时，就可以将这个资源暂时读写到缓冲区，由于缓冲区是内存区域，因此读写会非常快，可以显著提高程序性能。对于Java字符流的操作都是在缓冲区进行的，如果我们想主动将缓冲区中的内容刷新到外部文件或者数据库中时，就可以使用flush()方法操作。</p><h1 id="6-什么是阻塞IO，什么是非阻塞IO？"><a href="#6-什么是阻塞IO，什么是非阻塞IO？" class="headerlink" title="6.    什么是阻塞IO，什么是非阻塞IO？"></a>6.    什么是阻塞IO，什么是非阻塞IO？</h1><p>IO操作包含对硬盘的读写、对socket的读写以及对外设的读写。<br>当用户线程发起一个IO请求操作时，操作系统内核会去查看要读取的数据是否就绪，对于<code>阻塞IO</code>来说，如果数据没有就绪，线程就会一直在那里等待，直到数据就绪；对于<code>非阻塞IO</code>来说，如果数据没有就绪，就会返回一个标志信息告知用户线程当前要读的数据没有就绪，用户线程依旧可以执行其他任务，当数据就绪后，便将数据拷贝到用户线程，这样才完成了一个完整的IO请求操作。<br><code>一个完整的IO请求操作</code>包括两个阶段：①查看数据是否就绪；②操作系统内核将数据拷贝到用户线程。阻塞IO和非阻塞IO的差别就在第一个阶段时，用户线程是否会阻塞在那里一直等待。</p><h1 id="7-如何实现对象克隆？"><a href="#7-如何实现对象克隆？" class="headerlink" title="7.    如何实现对象克隆？"></a>7.    如何实现对象克隆？</h1><ul><li>实现Cloneable接口并重写clone()方法；</li><li>实现Serializable接口，通过对象的序列化和反序列化实现。</li></ul><h1 id="8-谈谈你对NIO的理解？"><a href="#8-谈谈你对NIO的理解？" class="headerlink" title="8.    谈谈你对NIO的理解？"></a>8.    谈谈你对NIO的理解？</h1><p>NIO即New IO，是JDK1.4中引入的，是非阻塞式、面向缓冲的。NIO中存在一个称为<code>选择器（Selector）</code>的东西，它允许你把多个<code>通道（Channel）</code>注册到一个选择器上，然后使用一个线程来定时轮询这些通道，若这些通道里有某个通道准备好可以进行读写操作了，那么<code>缓冲器（Buffer）</code>就可以对该通道进行读写。<br><code>NIO的原理</code>：可以把通道想象成煤矿，把缓冲器想象成运煤车，运煤车拉运煤矿而归，我们再从运煤车上获得煤矿。换句话说，我们并没有直接和通道进行交互，而是和缓冲器进行交互，并把缓冲器派送到通道。通道要么从缓冲器获得数据，要么向缓冲器发送数据。<br>可以这么认为，<code>缓冲器=流，通道=数据源</code>。<br><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/IO/NIO%E5%9B%BE%E8%A7%A3.70dombsgdqs0.webp" alt="NIO图解"><br><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/IO/NIO%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3.7e6c3vwe7bw0.webp" alt="NIO概念详解"></p><h1 id="9-BIO、NIO和AIO的区别？"><a href="#9-BIO、NIO和AIO的区别？" class="headerlink" title="9.    BIO、NIO和AIO的区别？"></a>9.    BIO、NIO和AIO的区别？</h1><ul><li><code>BIO</code>：就是传统的java.io包，它是基于流模型实现的，交互方式是<code>同步并阻塞</code>，即读写输入输出流时，在读写动作完成之前，线程会一直阻塞在那里等待结果；</li><li><code>NIO</code>：即JDK1.4引入的java.nio包，提供了选择器（Selector）、通道（Channel）、缓冲器（Buffer）的概念。首先需要将多个Channel注册到Selector上，Selector定时轮询这些Channel，若某个Channel准备好可以进行读写操作了，则分配相应的Buffer进行操作。可以构建多路复用的IO程序，交互方式为<code>同步非阻塞</code>；</li><li><code>AIO</code>：为JDK1.7之后引入的包，交互方式为<code>异步非阻塞</code>，异步IO是基于事件和回调机制实现的，也就是用户线程在发起读写操作后会直接返回，不会阻塞在那里，当读写操作完成后，会由操作系统将数据拷贝到用户进程中，最后通知用户线程数据已经准备妥当。AIO属于异步模型，用户线程可以同时处理别的事情，在结果返回后，Java提供了两种进一步处理结果的方式：<ul><li>基于回调的方式。即实现CompletionHandler接口，在调用时把回调函数传递给相应的调用者即可；</li><li>使用Future。通过返回一个Future结果，用户线程可以调用Future的方法来查看读写操作是否完成。</li></ul></li></ul><p><code>补充</code>：<code>IO多路复用</code>，即单个线程同时处理多个IO流，NIO中轮询操作是用户线程进行的，如果把这个任务交给其他线程，那么用户线程就可以把轮询花费的时间用来做其他事了。IO多路复用有两种实现方式;</p><ul><li>Select&#x2F;poll：将Channel注册到Selector上，通过轮询Channel是否就绪，将就绪的Channel返回；</li><li>Select&#x2F;epoll：将Channel注册到Selector上，基于回调的方式告知Selector哪些Channel已经就绪，然后将就绪的Channel返回。与select&#x2F;poll方式的区别就在于poll是Selector主动轮询，epoll是由操作系统通知Selector。</li></ul><h1 id="10-内存映射文件是什么？"><a href="#10-内存映射文件是什么？" class="headerlink" title="10.    内存映射文件是什么？"></a>10.    内存映射文件是什么？</h1><p><code>内存映射文件</code>允许我们创建和修改那些因为太大而不能放入内存的文件，有了内存映射文件，我们就可以假定整个文件都存放在内存中，而且完全可以把它当成一个非常大的数组来访问。常见用法是Channel调用map()方法产生一个MappedByteBuffer，这是一种特殊类型的缓冲器，可以指定映射文件的初始位置和映射区域的长度，如此一来就相当于直接操作内存文件了，实际文件还是在外部数据源中。</p><h1 id="11-什么是Java序列化？如何实现Java序列化？"><a href="#11-什么是Java序列化？如何实现Java序列化？" class="headerlink" title="11.    什么是Java序列化？如何实现Java序列化？"></a>11.    什么是Java序列化？如何实现Java序列化？</h1><p>当我们创建对象时，只要我们需要，它就会一直存在，但是在程序终止时它就会消失，<code>Java的对象序列化</code>将那些实现了Serializable接口的类的对象转换成一个字节序列，这些字节序列可以在任何地方比如网络间进行传输，在以后还能将这个字节序列完全恢复为原来的对象。<br>要序列化一个对象，首先要创建某些OutputStream对象，然后将其封装在一个ObjectOutputStream对象内，这时，只需要调用writeObject()即可将对象序列化，并将其发送给OutputStream（对象序列化是基于字节的，因此要使用InputStream和OutputStream继承层次结构）。要反序列化（即将字节序列恢复为对象），需要将一个InputStream对象封装在ObjectInputStream内，然后调用readObject()，和往常一样，我们最后获得的是一个引用，它指向一个向上转型的Object，所以必须向下转型才能对它们进行操作。<br><code>补充</code>：<code>实现了Serializable接口只是代表该对象可以序列化</code>。序列化是对象转换成字节序列，即内存中的数据输出到流中，反序列化是字节序列转换为对象，即将流中的数据读入到内存。</p><h1 id="12-持久性是什么？"><a href="#12-持久性是什么？" class="headerlink" title="12.    持久性是什么？"></a>12.    持久性是什么？</h1><p><code>持久性</code>意味着一个对象的生命周期并不取决于程序是否正在执行，它可以生存于程序的调用之间，通过将一个序列化对象写入磁盘，然后在重新调用程序时恢复该对象，就能够实现持久性的效果。</p><h1 id="13-实现Java序列化既可以实现Serializable接口，也可以实现Externalizable接口，这两者之间的区别是什么？"><a href="#13-实现Java序列化既可以实现Serializable接口，也可以实现Externalizable接口，这两者之间的区别是什么？" class="headerlink" title="13.    实现Java序列化既可以实现Serializable接口，也可以实现Externalizable接口，这两者之间的区别是什么？"></a>13.    实现Java序列化既可以实现Serializable接口，也可以实现Externalizable接口，这两者之间的区别是什么？</h1><p><code>Externalizable接口继承了Serializable接口</code>，同时添加了<code>writeExternal()</code>和<code>readExternal()</code>两个方法，这两个方法会在序列化和反序列化的过程中被<code>自动调用</code>。对于Serializable对象，对象完全以它存储的二进制位为基础来构造，而不用构造器；而对于一个Externalizable对象来说，所有默认构造器（无参）都会被调用（包括在字段定义时的初始化），所以必须注意默认构造器中的逻辑。<code>如果有writeExternal()和readExternal()两个方法，那么默认构造器就不会生效</code>，所以要谨慎对待这两个方法中的逻辑，writeExternal()方法用于序列化时将来自对象的信息写入，readExternal()方法用于恢复数据。因此，Serializable接口看起来似乎更加便捷。<br>也可用Serializable接口代替Externalizable接口，即添加<code>writeObject()</code>与<code>readObject()</code>两个方法，在序列化和反序列化的过程中，这两个方法会被自动调用，只要提供了这两个方法，就不会使用默认的以二进制位构造的序列化机制。</p><h1 id="14-怎么只序列化对象的一部分或者恢复一部分？"><a href="#14-怎么只序列化对象的一部分或者恢复一部分？" class="headerlink" title="14.    怎么只序列化对象的一部分或者恢复一部分？"></a>14.    怎么只序列化对象的一部分或者恢复一部分？</h1><p>当我们对序列化进行控制时，可能某个特定子对象不想让Java的序列化机制自动保存和恢复，例如子对象表示的是我们不希望将其序列化的敏感信息（如密码）。即使对象中的这些信息是private的，序列化处理后人们也可以通过读取文件或者拦截网络传输的方式访问到它，<code>将类实现为Externalizable</code>就可以避免这种情况。实现了Externalizable接口的类的对象中，没有任何东西可以自动序列化，都需要经过默认构造函数，或者writeExternal()和readExternal()两个方法。<br>如果是一个Serializable对象，那么所有序列化都会自动进行，但是可以用<code>transient关键字</code>逐个字段地关闭序列化，它的意思是“不用麻烦你保存或恢复数据，我自己会处理的”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-谈谈你对IO流的理解？&quot;&gt;&lt;a href=&quot;#1-谈谈你对IO流的理解？&quot; class=&quot;headerlink&quot; title=&quot;1.    谈谈你对IO流的理解？&quot;&gt;&lt;/a&gt;1.    谈谈你对IO流的理解？&lt;/h1&gt;&lt;p&gt;设备之间的传输需要媒介，流正是Jav</summary>
      
    
    
    
    <category term="IO" scheme="https://lisj98.github.io/categories/IO/"/>
    
    
    <category term="IO理论" scheme="https://lisj98.github.io/tags/IO%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码解析</title>
    <link href="https://lisj98.github.io/2022/09/08/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://lisj98.github.io/2022/09/08/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-09-08T14:13:10.000Z</published>
    <updated>2022-09-08T14:13:38.952Z</updated>
    
    <content type="html"><![CDATA[<p>TODO：红黑树的逻辑</p><h1 id="1-前情提要"><a href="#1-前情提要" class="headerlink" title="1. 前情提要"></a>1. 前情提要</h1><p>ConcurrentHashMap继承了AbstractMap，实现了ConcurrentMap接口，ConcurrentMap接口实现了Map接口，也就是说它和HashMap并没有直接的联系</p><p>ConcurrentHashMap的key和value都不能为空</p><p>ConcurrentHashMap是线程安全的Map，JDK 1.8中这个线程安全主要是通过CAS(比较和替换)+自旋来实现的，JDK 1.7中是通过加锁实现的</p><p>JDK1.7的结构是维护了一个大小为16的Segment数组，然后每个Segment数组中又分别维护了一个哈希表，也就是说数组套数组套链表，每个线程操作各自的Segment数组，互不影响</p><p>JDK1.8的结构类似于HashMap，没有Segment数组的概念，就是维护了一个哈希表，保证线程安全的实现方式主要是CAS+自旋，什么是CAS+自旋呢，就是线程在要操作某个变量的时候，先和自己的副本比较一下变量值，如果两者是相同的就直接修改，如果两者不同就不修改，回到代码块最开始的循环处，再执行一次循环，就这样循环往复，直到能修改值为止</p><p>JDK1.7的ConcurrentHashMap示例：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/JDK1.2emddb6cg0e8.webp" alt="JDK1"></p><p>JDK1.8的ConcurrentHashMap示例：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/JDK1.6t3yso8mo8o0.webp" alt="JDK1"></p><h1 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h1><h2 id="2-1-属性"><a href="#2-1-属性" class="headerlink" title="2.1. 属性"></a>2.1. 属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大容量 2^30</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树化节点个数(链表-&gt;树)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表化节点个数(树-&gt;链表)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树化最小的容量要求</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小迁移步长</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容戳位数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大扩容线程数 2^16-1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在sizeCtl中扩容戳的位移 16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span> <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标志forwarding node节点，forwarding node是桶数组扩容时的辅助节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表的桶数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容后的新数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本计数器值，在没有线程竞争时用作维护Map元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计数数组，用在线程竞争时各个线程共同维护Map元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sizeCtl，线程间共享变量，用以标识数组现在的状态以及线程能执行的操作</span></span><br><span class="line"><span class="comment"> * 为0，代表数组没有被初始化，数组容量为16(空参构造)；</span></span><br><span class="line"><span class="comment"> * 为正数，如果数组没有初始化则代表数组的初始容量，如果数组已经初始化了则代表数组扩容阈值(数组的初始容量*0.75)</span></span><br><span class="line"><span class="comment"> * 为-1，代表一个线程正在进行数组初始化，其他线程就不能初始化了</span></span><br><span class="line"><span class="comment"> * 小于0并且不为-1，则表示数组正在扩容，-(1+n)表示此时有n个线程正在共同完成数组的扩容操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记扩容线程扩容数组时的起始位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示是否有线程正在操作数组，0表示没有，1表示有</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;<span class="comment">//当前类对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> SIZECTL;<span class="comment">//sizeCtl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> TRANSFERINDEX;<span class="comment">//transferIndex</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> BASECOUNT;<span class="comment">//baseCount</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLSBUSY;<span class="comment">//cellsBusy</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLVALUE;<span class="comment">//value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">SIZECTL = U.objectFieldOffset</span><br><span class="line">(k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br><span class="line">TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">(k.getDeclaredField(<span class="string">&quot;transferIndex&quot;</span>));</span><br><span class="line">BASECOUNT = U.objectFieldOffset</span><br><span class="line">(k.getDeclaredField(<span class="string">&quot;baseCount&quot;</span>));</span><br><span class="line">CELLSBUSY = U.objectFieldOffset</span><br><span class="line">(k.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">CELLVALUE = U.objectFieldOffset</span><br><span class="line">(ck.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">ABASE = U.arrayBaseOffset(ak);</span><br><span class="line"><span class="type">int</span> <span class="variable">scale</span> <span class="operator">=</span> U.arrayIndexScale(ak);</span><br><span class="line"><span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2.2. 方法"></a>2.2. 方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.无参构造，什么都是默认的，在put时才初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.指定初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">//initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)，计算出大于原值加一半又加1的最接近2的幂，要分情况分析，如initialCapacity为31，则容量为64，而initialCapacity为17，则容量为32</span></span><br><span class="line"><span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">           MAXIMUM_CAPACITY :</span><br><span class="line">           tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//sizeCtl见属性详解</span></span><br><span class="line"><span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.复制一个Map</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.指定初始容量、负载因子，并发线程数固定为1</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.指定初始容量、负载因子和估计的并发线程数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line"><span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line"><span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">          MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line"><span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tableSizeFor方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和HashMap的处理逻辑一致，计算出一个大于c的最接近2的幂，具体解析见HashMap的该方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么时候该用无参构造，什么时候该用有参构造呢？我们通常直接使用无参构造，什么都用默认的，但是如果一开始就能确定集合里有多少个元素的话，就应该用有参构造来确定初始容量，因为频繁的扩容很消耗性能，只有在无法确定集合里有多少元素的情况下才应该使用无参构造。</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.put方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.putIfAbsent方法</span></span><br><span class="line"><span class="keyword">public</span> V putIfAbsent方法(K key, V value) &#123;</span><br><span class="line"><span class="keyword">return</span> putVal(key, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.putAll方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> putAll方法(Map&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; m) &#123;</span><br><span class="line">tryPresize(m.size());</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet())</span><br><span class="line">putVal(e.getKey(), e.getValue(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.putVal方法</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">//key和value都不能为空</span></span><br><span class="line"><span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//计算hash值确定桶下标，spread方法返回值：(h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS，和HashMap计算hash值的计算方法一样</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line"><span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//链表节点的个数</span></span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">Node&lt;K,V&gt; f;</span><br><span class="line"><span class="type">int</span> n, i, fh;</span><br><span class="line"><span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//table无具体指向，即没初始化则初始化数组</span></span><br><span class="line">tab = initTable();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//链表首节点为空，即当前桶内无元素，则创建节点</span></span><br><span class="line"><span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line"><span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//首节点的hash值为-1，则代表该节点是一个forwarding node，即桶数组当前位置存储了一个forwarding node，而forwarding node是对数组进行扩容迁移的标志，也就表示目前正有线程对桶数组进行迁移，那么本线程就要协助迁移数组</span></span><br><span class="line">tab = helpTransfer(tab, f);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//正常往链表节点后添加元素</span></span><br><span class="line"><span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//锁住链表首节点，相当于锁住当前桶，同时也不会影响对其他桶的操作</span></span><br><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//tabAt再判断一次是防止链表节点变成了树节点，那么接下来的操作就不适用了</span></span><br><span class="line"><span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">binCount = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">K ek;</span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((ek = e.key) == key ||</span><br><span class="line">         (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//链表首节点为所查询节点，修改原值</span></span><br><span class="line">oldVal = e.val;</span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">e.val = value;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">                            <span class="comment">//链表首节点不为所查询节点，往后添加</span></span><br><span class="line">Node&lt;K,V&gt; pred = e;</span><br><span class="line"><span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                          value, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//若之前链表已经进化成红黑树，则用红黑树的逻辑</span></span><br><span class="line">Node&lt;K,V&gt; p;</span><br><span class="line">binCount = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                      value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">oldVal = p.val;</span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">p.val = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//判断是否需要将链表进化成红黑树</span></span><br><span class="line">treeifyBin(tab, i);</span><br><span class="line"><span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> oldVal;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//addCount：1.维护集合长度，2.判断是否需要扩容</span></span><br><span class="line">addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put加锁图解：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/put%E5%8A%A0%E9%94%81.4o02hw60p8o0.webp" alt="put加锁"></p><h3 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.initTable</span></span><br><span class="line"><span class="comment">//初始化哈希表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab;</span><br><span class="line"><span class="type">int</span> sc;</span><br><span class="line"><span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是刚创建Map，调用的有参构造，那sizeCtl肯定大于0，调用的是无参构造，那sizeCtl肯定等于0</span></span><br><span class="line"><span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//sizeCtl&lt;0，要么表示某一个线程正在初始化数组，要么表示数组正在扩容，因此其他线程不能干扰本线程的操作，所以需要调用yield()方法让出CPU执行权</span></span><br><span class="line">Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//sizeCtl&gt;0，要么表示还没有开始初始化数组，要么数组已经初始化完成表示的是阈值。而sc在上个if判断条件中记录的是旧sizeCtl的值，SIZECTL和sc进行比较，相同则说明sizeCtl没有被其他线程修改，则可以继续进行，将sc的值改成-1，表示当前线程正在初始化数组，其他线程就不能操作数组了，不相同则说明其他线程修改了sizectl的值，那么就需要重新循环直到两个值相等为止(CAS+自旋)</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="comment">//指向一个真正的桶数组，之前的table只是个引用</span></span><br><span class="line">Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">table = tab = nt;</span><br><span class="line">                    <span class="comment">//&gt;&gt;&gt;2表示除以4，n-1/4n=0.75n，又赋值给sizectl，而此时数组已经初始化完了，那么sizectl就表示扩容阈值了</span></span><br><span class="line">sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">sizeCtl = sc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resizeStamp方法"><a href="#resizeStamp方法" class="headerlink" title="resizeStamp方法"></a>resizeStamp方法</h3><p>该方法表示一个扩容戳(16位)，根据它可以判断多线程是否为同一批次，操作同一数组，并且可以得到原数组的长度。</p><p>n为原数组的长度，numberOfLeadingZeros(n)方法用来计算n中1前面的0有多少个，然后跟1&lt;&lt;15进行或运算</p><p>举个例子，n&#x3D;32(0…0 0…0 0…0 00100000)，1前面有26个0，那么就用(0…0 0…0 0…0 00011010)与(0…0 0…0 10000000 0…0)进行或运算，得到结果(0…0 0…0 10000000 00011010)。</p><p>这个扩容戳有什么用呢，在数组迁移时会用到，它会用来规定一个批次，多线程根据这个批次号来确定扩容的原数组。后面使用它时它将作为int类型的高16位来使用，低16位就表示扩容线程数</p><p>比如上面的结果(0…0 0…0 10000000 00011010)，后面该值会左移16位，那么(10000000 00011010)就变成了高16位，而这个值肯定是由32得出来的，那么多线程就知道当前扩容的数组长度为32，也就知道当前是对哪个数组进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.resizeStamp</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">resizeStamp</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h3><ol><li>维护元素数量</li><li>判断是否需要扩容</li></ol><p>获取集合长度的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.size</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line"><span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">        (n &gt; (<span class="type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">        (<span class="type">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcurrentHashMap.sumCount</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">CounterCell[] as = counterCells;</span><br><span class="line">CounterCell a;</span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line"><span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">sum += a.value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>baseCount变量，put元素时线程要维护这个变量，进行++操作</p><p>CounterCell数组也是用来维护Map元素数量的，在多线程环境下，两个线程同时对baseCount操作，那么肯定有一个成功，一个失败，成功的那个自然用baseCount记录数量，失败的那个就要用CounterCell数组来记录元素数量，最后把数组中所有的value值和baseCount加起来就是整个Map的元素数量</p><p>它是这样一种结构：CounterCell数组类似于哈希表中的桶，每个桶中有一个CounterCell对象，这个对象又有一个属性value，计算Map中元素数量就是将每个桶中CounterCell对象的value值加起来再加上baseCount，得到的总数就是集合的元素数量</p><p>CounterCell数组和baseCount都是多线程共享的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.addCount</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">CounterCell[] as;</span><br><span class="line"><span class="type">long</span> b, s;</span><br><span class="line">    <span class="comment">//(as = counterCells) != null成立则直接到b处，baseCount语句不执行，baseCount=0</span></span><br><span class="line">    <span class="comment">//(as = counterCells) != null不成立则到a处，说明baseCount的累加操作失败，比如两个线程同时进来，那么一个添加成功，一个添加失败，失败的那个就会进到a处，这时，失败的就会利用数组中的CounterCell记录数量，而成功的则用baseCount记录数量</span></span><br><span class="line"><span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">CounterCell a;</span><br><span class="line"><span class="type">long</span> v;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line">        <span class="comment">//标识是否有多线程竞争</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//a</span></span><br><span class="line">        <span class="comment">//as == null || (m = as.length - 1) &lt; 0表示数组为空或长度为0</span></span><br><span class="line">        <span class="comment">//(a = as[ThreadLocalRandom.getProbe() &amp; m]) == null表示当前线程负责的桶位中没有CounterCell对象</span></span><br><span class="line">        <span class="comment">//U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)表示当前线程对应的桶位不为空，但是累加失败</span></span><br><span class="line"><span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">        (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">        !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">fullAddCount(x, uncontended);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//b.s是通过累加CounterCell数组中每一个CounterCell对象的value值加上baseCount得来的，到这一步的条件是上面if语句中的(as = counterCells) != null成立，即CounterCell数组不为空</span></span><br><span class="line">s = sumCount();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//check就是传进来的binCount，即链表节点个数。第一次put时会进入到这个条件中</span></span><br><span class="line"><span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab, nt;</span><br><span class="line"><span class="type">int</span> n, sc;</span><br><span class="line">        <span class="comment">//s为Map中元素总数，&gt;=阈值时需要扩容</span></span><br><span class="line"><span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;<span class="comment">//sc&lt;0表示有其他线程正在进行扩容</span></span><br><span class="line">                <span class="comment">//不需要协助扩容，5个条件见helpTransfer方法的解释</span></span><br><span class="line"><span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//需要协助扩容，则线程数+1。高16位扩容戳不变，低16位+1</span></span><br><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">transfer(tab, nt);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                               (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//没有线程进行扩容，则当前线程负责扩容，sizectl的值形式变为(高16位扩容戳+低16位线程数)，为什么是+2不是+1，在下面的helpTransfer方法中有解释</span></span><br><span class="line">transfer(tab, <span class="literal">null</span>);</span><br><span class="line">s = sumCount();<span class="comment">//返回元素总数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fullAddCount方法"><a href="#fullAddCount方法" class="headerlink" title="fullAddCount方法"></a>fullAddCount方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.fullAddCount</span></span><br><span class="line"><span class="comment">//addCount方法中累加baseCount失败，或者CounterCell数组已经得到初始化的线程会进到这个方法中，使用CounterCell数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">fullAddCount</span><span class="params">(<span class="type">long</span> x, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line">    <span class="comment">//获取当前线程的hash值，hash值相同的线程负责一个CounterCell[]数组的一格</span></span><br><span class="line"><span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">h = ThreadLocalRandom.getProbe();<span class="comment">//初始化后重新获取hash值</span></span><br><span class="line">wasUncontended = <span class="literal">true</span>;<span class="comment">//为true表示当前桶位没有线程竞争</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">CounterCell[] as;</span><br><span class="line">CounterCell a;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> v;</span><br><span class="line">        <span class="comment">//a.桶不为空，给那些c.累加baseCount失败，b.没抢占初始化的那些线程使用</span></span><br><span class="line"><span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//1.当前桶位为空</span></span><br><span class="line"><span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当前桶位没有线程在填入CounterCell对象，cellsBusy为0表示没有线程正在使用数组，为1表示有线程正在使用数组</span></span><br><span class="line"><span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">CounterCell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x);<span class="comment">//新建一个CounterCell对象，value值为1，后续会自加</span></span><br><span class="line">                    <span class="comment">//没有线程正在操作数组，则修改cellsBusy为1，表示我要往数组里插入对象了，其他线程就不能插手了</span></span><br><span class="line"><span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//为true表示对象填入成功</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">CounterCell[] rs;</span><br><span class="line"><span class="type">int</span> m, j;</span><br><span class="line">                            <span class="comment">//counterCells数组不为空，并且线程对应桶位为空，则填入CounterCell对象</span></span><br><span class="line"><span class="keyword">if</span> ((rs = counterCells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">rs[j] = r;</span><br><span class="line">created = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">cellsBusy = <span class="number">0</span>;<span class="comment">//填入对象完成，cellsBusy修改为0，其他线程可以操作数组了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (created)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//创建对象并且填入桶成功，退出循环</span></span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//不成功继续循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">collide = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//2.进不来，一直为false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">wasUncontended = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//3.对应的桶位不为空，直接累加CounterCell对象的value值，然后退出循环，累加失败(有其他线程修改过)则重新计算线程hash值，继续循环</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//4.数组被其他的线程修改了，或者数组长度超过了可用CPU大小，则重新计算hash值，继续循环</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">collide = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//5.用来控制重新计算线程hash值,当前桶位有对象，累加value又失败了，数组又没被其他线程修改过，则将collide置为true，并重新计算hash值，如果又一轮失败了，那么直接进入6中</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//6.没有其他线程正在操作数组</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">         U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//如果CAS自旋失败两次则直接扩容数组</span></span><br><span class="line"><span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">rs[i] = as[i];</span><br><span class="line">counterCells = rs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">cellsBusy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">collide = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">&#125;</span><br><span class="line">h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        <span class="comment">//b.如果有多个因累加baseCount失败而同时进入本方法的线程，第一个抢占了本if语句的线程，CounterCells数组为空(counterCells == as)，更没有其他线程在对数组进行操作(cellsBusy == 0)，它就初始化数组，初始长度为2，并且将cellsBusy设为1，告诉其他线程我正在初始化数组，你们继续循环</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">           U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line"><span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[<span class="number">2</span>];</span><br><span class="line">rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x);</span><br><span class="line">counterCells = rs;</span><br><span class="line">init = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">cellsBusy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//数组初始化完成，当前负责初始化的线程退出循环</span></span><br><span class="line"><span class="keyword">if</span> (init)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//c.如果有多个因累加baseCount失败而同时进入本方法的线程，a中CounterCells数组为空，b中又被其他线程抢了先，那么就尝试再一次累加baseCount，累加成功则退出循环，执行自己下一步；累加失败则继续循环，最终在a中操作</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line"><span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算集合总数图解：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/%E8%AE%A1%E7%AE%97%E9%9B%86%E5%90%88%E6%80%BB%E6%95%B0.50ezwqf3n0w0.webp" alt="计算集合总数"></p><h3 id="helpTransfer方法"><a href="#helpTransfer方法" class="headerlink" title="helpTransfer方法"></a>helpTransfer方法</h3><p>put、replace、compute等往Map中放元素的时候会触发helpTransfer操作，而修改Map中的元素时必定会触发addCount操作，addCount中有这样一个操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.addCount</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">transfer(tab, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>即这个时候SIZECTL也就是sizectl已经被修改为<code>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</code>了，含义就是高16位扩容戳标记本批次线程，低16位为2表示目前有一个线程参加扩容了。这里理解时要忽略高16位的扩容戳，因为扩容戳首位肯定是1，那么忽略掉之后sizectl就是-2，表示此时数组正在扩容，扩容线程数为2-1&#x3D;1，为什么是+2不是+1呢，因为-1表示数组正在初始化</p><p>所以下面helpTransfer中，sc并不是传统意义上的负几负几，而是我们忽略掉扩容戳之后的数，因此理解上忽略掉高16位的扩容戳，而代码实现上结合高16位扩容戳+低16位线程数</p><p>另外SIZECTL(sizeCtl)是一个静态变量，所以一个线程在put-&gt;addCount-&gt;transfer一系列操作中修改了这个值的时候，另一个线程进来put-&gt;helpTransfer得到的是修改后的值，也就是<code>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</code>这个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协助迁移数组(扩容时是创建一个新桶数组，再把旧数组的值迁移到新数组中)</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">Node&lt;K,V&gt;[] nextTab;<span class="comment">//指向新数组</span></span><br><span class="line"><span class="type">int</span> sc;</span><br><span class="line"><span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//只要参数tab.length是一样的，那么rs这个值必定是一样的，因此它跟addCount()方法中的rs必定是一样的</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line"><span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">        (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//a</span></span><br><span class="line"><span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">        sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//sc+1即后16位+1，表示增加了一个线程来协助扩容</span></span><br><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">transfer(tab, nextTab);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nextTab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码a中：</p><ul><li>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs用来判断线程是否为同一批次，即扩容戳是否一致，是否操作的同一数组</li><li>sc &#x3D;&#x3D; rs + 1，在transfer()方法中，如果数组迁移完毕了有这样一个操作：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.transfer</span></span><br><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">finishing = advance = <span class="literal">true</span>;</span><br><span class="line">i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sc - 1表示低16位-1，表示减去一个协助扩容的线程，每一个进入transfer方法的线程如果发现数组迁移完毕了，那么自己就退出扩容，线程数-1，每一个都这样操作，直到所有线程都-1，那么就回归到了最开始的情况，而最开始是+2，初始情况必定有一个线程，初始情况的这个线程也-1了，最后的sc自然是(16位扩容戳+0000000000000001)，而(rs&lt;&lt;16)+1也是这个数，所以两数相等就表示扩容完毕，就没必要再协助扩容了</p><ul><li>sc &#x3D;&#x3D; rs + MAX_RESIZERS表示达到了最大扩容线程数，不能再有线程进来协助扩容了</li><li>transferIndex &lt;&#x3D; 0表示已经没有要迁移的桶了</li></ul><p>sc &#x3D;&#x3D; rs + 1和sc &#x3D;&#x3D; rs + MAX_RESIZERS有bug，其中的rs应该为(rs&lt;&lt;16)</p><h3 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h3><p>tryPresize、helpTransfer、addCount时会触发transfer操作，通俗点说，只要元素数量达到了阈值就会触发transfer方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.transfer</span></span><br><span class="line"><span class="comment">//迁移数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="comment">//如果是多CPU，那么每个线程划分任务，一个线程负责一块范围或者多块范围的桶，最小任务数是16，即一个线程最少要负责16个相接的桶</span></span><br><span class="line"><span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"><span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">//创建两倍大小的新数组</span></span><br><span class="line">Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">nextTab = nt;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">sizeCtl = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录线程开始迁移的桶位，从后往前迁移</span></span><br><span class="line">transferIndex = n;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//记录新数组的末尾</span></span><br><span class="line"><span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    <span class="comment">//若某个桶位迁移完成了，则在该桶中放入一个ForwardingNode节点</span></span><br><span class="line">ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//advance用来表示当前桶位是否已经迁移完毕</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//finishing用来表示整个数组是否已经迁移完毕</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        <span class="comment">//i记录当前正在迁移桶位的下标</span></span><br><span class="line">        <span class="comment">//bound记录迁移的最后一个桶位的下标</span></span><br><span class="line">        <span class="comment">//数组从后往前迁移，所以i从右往左，bound在最左边</span></span><br><span class="line">Node&lt;K,V&gt; f;</span><br><span class="line"><span class="type">int</span> fh;</span><br><span class="line"><span class="keyword">while</span> (advance) &#123;</span><br><span class="line"><span class="type">int</span> nextIndex, nextBound;</span><br><span class="line"><span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                <span class="comment">//a.i移到了bound左边或者finishing为true说明整个桶数组已经迁移完毕。若线程负责的区间中右端根本没有值，则会进入这个条件中，一直到无值的桶位中forwarding node补全为止；若区间右端有值，则一定先进入c条件中，等到全部迁移完才会进入本条件中，最开始肯定是先进入到c条件中的</span></span><br><span class="line">advance = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//b.nextIndex或者说transferIndex&lt;=0和上面情况一样，也是说明整个桶数组已经迁移完毕</span></span><br><span class="line">i = -<span class="number">1</span>;</span><br><span class="line">advance = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">           (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">            nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                         nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">//c.nextIndex - stride是为了控制区间，限定当前线程所负责的最后一个桶位，比如30-16，那么当前线程应该从30处理到14，这个区间中的16个桶位就是由它负责，bound限定不动为14，i一直从右向左移(30,29,28,27......14)。而如果只有1个线程的话，那么在迁移到14时，a条件中的--i已经小于bound了，那么就要在此条件中重新限定范围区间</span></span><br><span class="line">                <span class="comment">//要注意一点，这里的TRANSFERINDEX每次会更新为nextBound，如果有另外的线程进来协助扩容，就会根据当前已经更新后的TRANSFERINDEX值重新计算任务区间，即另外的线程领到下一个区间，多个线程就这样循环领取任务，这里就是多线程协助扩容的关键所在</span></span><br><span class="line">bound = nextBound;</span><br><span class="line">i = nextIndex - <span class="number">1</span>;</span><br><span class="line">advance = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line"><span class="type">int</span> sc;</span><br><span class="line">            <span class="comment">//迁移完成</span></span><br><span class="line">            <span class="comment">//a.所有桶位迁移完毕后先进b维护线程数，由最后一个线程进a来维护新数组</span></span><br><span class="line"><span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">nextTable = <span class="literal">null</span>;</span><br><span class="line">table = nextTab;</span><br><span class="line">                <span class="comment">//重新计算阈值1.5n，等同于2n*0.75</span></span><br><span class="line">sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//b.所有桶位迁移完毕后先进这里，sc-1即低16位-1，表示减去一个扩容的线程数。如果我不是最后一个线程，那么sc - 2后肯定不等于resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，那么直接返回，我自己的部分迁移完成了，我去接着自己的操作，由最后一个线程完成新数组的指向；如果我是最后一个数组，那么sc - 2后肯定等于resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，则直接将对应标志位置为true</span></span><br><span class="line">            <span class="comment">//这里sc-1和sc-2不要看成sc-3，正确流程应该是sc记录原sizectl值，然后sc-1赋值给sizectl，sc-2还是原sizectl-2</span></span><br><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">finishing = advance = <span class="literal">true</span>;</span><br><span class="line">i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//当前桶位无元素，则直接在桶中添加forwarding node</span></span><br><span class="line">advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//当前桶位的节点hash值为MOVED，也就是-1，说明当前节点已经是forwarding node节点了，直接将advance置为true，表示当前桶位已经处理过了</span></span><br><span class="line">advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//锁住首节点</span></span><br><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//tabAt再判断一次是防止链表节点变成了树节点，那么接下来的操作就不适用了</span></span><br><span class="line"><span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">Node&lt;K,V&gt; ln, hn;</span><br><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//runBit是用来确定某个桶中的值在扩容后到底应该放在新桶中的高位还是低位，若fh&gt;n，则runBit==n;若fh&lt;n，则runBit==0</span></span><br><span class="line">                        <span class="comment">//例如，原桶容量为32，阈值为24，其中存了一个key为63的节点，63%32=31，那么在原桶中，63应该被放在tab[31]的位置，但是扩容后，新桶容量为64了，63%64=63，那么在新桶中，63就应该被放在nextTab[63]的位置，而nextTab[31]的位置就应该置null了</span></span><br><span class="line"><span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">Node&lt;K,V&gt; lastRun = f;<span class="comment">//lastRun记录节点</span></span><br><span class="line">                        <span class="comment">//上一条语句的lastRun = f;是判断链表首节点应该放在新桶中的高位还是低位，这个for语句是判断链表首节点后面的节点应该放在新桶的高位还是低位</span></span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="comment">//b和runBit的作用一样</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="comment">//举个例子，若tab[1]存了1和33，在判断33时，runBit=0，而如果不经过下面if判断与runBit = b;操作，那么lastRun就被存到了新桶的低位，这肯定是不行的。而经过这个判断后，b=33，runBit=33，lastRun就被存到高位，正确</span></span><br><span class="line"><span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">runBit = b;</span><br><span class="line">lastRun = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//fh&lt;=n，原值放在低位</span></span><br><span class="line">ln = lastRun;</span><br><span class="line">hn = <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//fh&gt;n，原值放在高位</span></span><br><span class="line">hn = lastRun;</span><br><span class="line">ln = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">                        <span class="comment">//上面一个for循环处理了链表首节点后面的节点，这一个for循环处理链表首节点</span></span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash;</span><br><span class="line"><span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line"><span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line"><span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line"><span class="type">else</span></span><br><span class="line"><span class="variable">hn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">&#125;</span><br><span class="line">                        <span class="comment">//将低位值ln放在新桶下标为i的节点</span></span><br><span class="line">setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//将高位值hn放在新桶下标为i+n的节点</span></span><br><span class="line">setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//将原桶中的当前节点设置为forwarding node节点</span></span><br><span class="line">setTabAt(tab, i, fwd);</span><br><span class="line">advance = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">(h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">lo = p;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">loTail.next = p;</span><br><span class="line">loTail = p;</span><br><span class="line">++lc;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">hi = p;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">hiTail.next = p;</span><br><span class="line">hiTail = p;</span><br><span class="line">++hc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">     (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">     (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">setTabAt(nextTab, i, ln);</span><br><span class="line">setTabAt(nextTab, i + n, hn);</span><br><span class="line">setTabAt(tab, i, fwd);</span><br><span class="line">advance = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素根据key值重新分配桶位：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/%E5%85%83%E7%B4%A0%E6%A0%B9%E6%8D%AEkey%E5%80%BC%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E6%A1%B6%E4%BD%8D.1fpa4quzhlr4.webp" alt="元素根据key值重新分配桶位"></p><p>单线程任务迁移：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1%E8%BF%81%E7%A7%BB.490olvlc7ok0.webp" alt="单线程任务迁移"></p><p>多线程协助扩容：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/ConcurrentHashMap/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8D%8F%E5%8A%A9%E6%89%A9%E5%AE%B9.1wle838nfhts.webp" alt="多线程协助扩容"></p><h3 id="tryPresize方法"><a href="#tryPresize方法" class="headerlink" title="tryPresize方法"></a>tryPresize方法</h3><h3 id="isEmpty方法"><a href="#isEmpty方法" class="headerlink" title="isEmpty方法"></a>isEmpty方法</h3><p>判断集合是否为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.isEmpty</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sumCount() &lt;= <span class="number">0L</span>; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.get</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab;</span><br><span class="line">Node&lt;K,V&gt; e, p;</span><br><span class="line"><span class="type">int</span> n, eh;</span><br><span class="line">K ek;</span><br><span class="line"><span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line"><span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//1.首节点为所求</span></span><br><span class="line"><span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line"><span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line"><span class="keyword">return</span> e.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.hash值小于0，有多种情况</span></span><br><span class="line"><span class="comment">//2.1.树节点的hash值为-2，则调用的TreeNode内部类的find方法</span></span><br><span class="line"><span class="comment">//2.2.forwading node节点的hash值为-1，则调用ForwardingNode内部类的find方法</span></span><br><span class="line"><span class="comment">//2.3.RESERVED节点的hash值为-3，则调用ReservationNode内部类的find方法</span></span><br><span class="line"><span class="comment">//把这个条件放在while循环之前就是为了根据节点类型的不同调用特殊的子类方法</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//3.首节点不为所求则向后遍历</span></span><br><span class="line"><span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">        ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line"><span class="keyword">return</span> e.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcurrentHashMap.getOrDefault</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">V v;</span><br><span class="line"><span class="keyword">return</span> (v = get(key)) == <span class="literal">null</span> ? defaultValue : v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="containsKey方法"><a href="#containsKey方法" class="headerlink" title="containsKey方法"></a>containsKey方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.containsKey</span></span><br><span class="line"><span class="comment">//实际调用的key方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="containsValue方法"><a href="#containsValue方法" class="headerlink" title="containsValue方法"></a>containsValue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.containsValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">Node&lt;K,V&gt;[] t;</span><br><span class="line"><span class="keyword">if</span> ((t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">Traverser&lt;K,V&gt; it = <span class="keyword">new</span> <span class="title class_">Traverser</span>&lt;K,V&gt;(t, t.length, <span class="number">0</span>, t.length);</span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p; (p = it.advance()) != <span class="literal">null</span>; ) &#123;</span><br><span class="line">V v;</span><br><span class="line"><span class="keyword">if</span> ((v = p.val) == value || (v != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-补充"><a href="#3-补充" class="headerlink" title="3. 补充"></a>3. 补充</h1><h2 id="unSafe类"><a href="#unSafe类" class="headerlink" title="unSafe类"></a>unSafe类</h2><h3 id="compareAndSwapInt方法"><a href="#compareAndSwapInt方法" class="headerlink" title="compareAndSwapInt方法"></a>compareAndSwapInt方法</h3><p>是一个本地方法，用C语言编写的</p><p>var1：对象</p><p>var2：内存中的值</p><p>var4：期望值</p><p>var5：新值</p><p>如果var1对象的var2和var4值相等，就让var2&#x3D;var5，并返回true，否则不修改且返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br></pre></td></tr></table></figure><h3 id="tabAt方法"><a href="#tabAt方法" class="headerlink" title="tabAt方法"></a>tabAt方法</h3><h3 id="casTabAt方法"><a href="#casTabAt方法" class="headerlink" title="casTabAt方法"></a>casTabAt方法</h3><h3 id="objectFieldOffset方法"><a href="#objectFieldOffset方法" class="headerlink" title="objectFieldOffset方法"></a>objectFieldOffset方法</h3><p>objectFieldOffset()方法用来获取类的某一字段的偏移量，也就是内存地址，那么在使用SIZECTL时，它就能获取到内存中sizeCtl的值，也就是说，如果没有其他的线程修改掉sizeCtl的值时，这两个值始终是相同的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> SIZECTL;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> TRANSFERINDEX;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> BASECOUNT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLSBUSY;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLVALUE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">SIZECTL = U.objectFieldOffset</span><br><span class="line">(k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br><span class="line">TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">(k.getDeclaredField(<span class="string">&quot;transferIndex&quot;</span>));</span><br><span class="line">BASECOUNT = U.objectFieldOffset</span><br><span class="line">(k.getDeclaredField(<span class="string">&quot;baseCount&quot;</span>));</span><br><span class="line">CELLSBUSY = U.objectFieldOffset</span><br><span class="line">(k.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">CELLVALUE = U.objectFieldOffset</span><br><span class="line">(ck.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">ABASE = U.arrayBaseOffset(ak);</span><br><span class="line"><span class="type">int</span> <span class="variable">scale</span> <span class="operator">=</span> U.arrayIndexScale(ak);</span><br><span class="line"><span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>baseCount基础变量，添加元素后线程要维护这个变量，进行++操作，如果有多个线程同时对baseCount进行操作，就会有冲突，有冲突线程就会对counterCells数组里面的具体counterCells对象的value属性进行++操作，最后baseCount的值就是数组里所有value值的总和</p><p>counterCells数组就是用来维护baseCount的</p><p>对数组中每一个对象都没操作成功就说明这个数组该扩容了，扩容的标准就是线程的数量，或者说计算机CPU的核数，因为一个线程操作一个数组位</p><p>值加成功就退出循环，加失败就一直循环，即自旋</p><p>sumCount当前集合的长度，就是通过baseCount和对counterCells对象的value累加获得的</p><p>判断集合长度的目的就是为了扩容</p><p>transfer(x,x)协助扩容，transfer(x,null)自行扩容</p><p>transfer方法就是扩容方法</p><p>nextTable是扩容后的新数组</p><p>transferIndex是旧数组的size</p><p>把原来大数组划分为几个小块，一个线程负责一个块去进行数据迁移到新数组，stride就是块的数目，根据CPU的核数即线程数计算，一个线程最少负责size为16的数组迁移</p><p>synchronized(f)保证迁移的时候别的线程没有添加节点，锁住的就是当前链表的首节点</p><p>helpTansfer帮助扩容</p><p>协助扩容是以领任务的方式从后往前，最小任务数量是16</p><p>位运算效率最高，因为是二进制运算</p><p>加锁影响效率，所以用CAS+自旋的操作</p><h2 id="ConcurrentHashMap为什么不允许空键和空值"><a href="#ConcurrentHashMap为什么不允许空键和空值" class="headerlink" title="ConcurrentHashMap为什么不允许空键和空值"></a>ConcurrentHashMap为什么不允许空键和空值</h2><p>代码层面，get(null)，计算hash值的时候就抛异常了，而HashMap里若key&#x3D;&#x3D;null，hash值会被设为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.get</span></span><br><span class="line"><span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());<span class="comment">//此处抛异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap.get</span></span><br><span class="line"><span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap.hash</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>再说containsKey方法，里面调用get方法，也是抛异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>再说containsValue方法，对value是否为空进行了判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br></pre></td></tr></table></figure><p>put方法，根本put不进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br></pre></td></tr></table></figure><p>这是实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TODO：红黑树的逻辑&lt;/p&gt;
&lt;h1 id=&quot;1-前情提要&quot;&gt;&lt;a href=&quot;#1-前情提要&quot; class=&quot;headerlink&quot; title=&quot;1. 前情提要&quot;&gt;&lt;/a&gt;1. 前情提要&lt;/h1&gt;&lt;p&gt;ConcurrentHashMap继承了AbstractMap，实</summary>
      
    
    
    
    <category term="集合" scheme="https://lisj98.github.io/categories/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="ConcurrentHashMap" scheme="https://lisj98.github.io/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap源码解析</title>
    <link href="https://lisj98.github.io/2022/09/08/LinkedHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://lisj98.github.io/2022/09/08/LinkedHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-09-08T14:12:08.000Z</published>
    <updated>2022-09-08T14:12:51.065Z</updated>
    
    <content type="html"><![CDATA[<p>TODO：红黑树的逻辑</p><h1 id="1-前情提要"><a href="#1-前情提要" class="headerlink" title="1. 前情提要"></a>1. 前情提要</h1><p>LinkedHashMap继承了HashMap</p><p>LinkedHashMap和HashMap的不同之处就在于前者维护了一个双向链表，而后者包含的是单向链表。要注意这个双向链表不是说每个桶里的都是单独的双向链表，而是所有桶里的所有节点都连了起来构成了一个双向链表。具体理解见<a href="#222">2.2.2. put方法</a>。</p><p>LinkedHashMap能保证插入顺序，即最后遍历出来的集合和插入时的顺序是一致的，而不是HashMap那种随机的。要说明的一点是HashMap里也不是随机的，它这个随机指的是插入顺序和遍历顺序不一致，不管你怎么插入，它的遍历方式默认是根据桶的顺序从前往后一个链表一个链表的输出，所以它每一个桶中的单向链表是可以保证顺序的，但是整体结合起来就不能保证顺序了。具体见<a href="#2218">2.2.18. 几个迭代器</a>。</p><p>LinkedHashMap中还有一种按访问时间排序的排序方式，最不常访问-&gt;最近访问，需要通过一种特殊的构造器来实现。put, putIfAbsent, get, getOrDefault, compute, computeIfAbsent, computeIfPresent, merge 这些方法都会对被访问的Entry更新一次访问，replace方法只有在被访问Entry的值得到修改之后才会更新访问，putAll方法会给所有Entry条目更新一次访问。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">8</span>,<span class="number">0.75f</span>,<span class="literal">true</span>);</span><br><span class="line">map.put(<span class="string">&#x27;c&#x27;</span>,<span class="number">4</span>);</span><br><span class="line">map.put(<span class="string">&#x27;e&#x27;</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="string">&#x27;d&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">map.replace(<span class="string">&#x27;e&#x27;</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;Character, Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Character character, Integer integer)</span> &#123;</span><br><span class="line">System.out.println(character+<span class="string">&quot; &quot;</span>+integer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c <span class="number">4</span></span><br><span class="line">d <span class="number">1</span></span><br><span class="line">e <span class="number">5</span></span><br></pre></td></tr></table></figure><p>其他的允许空键空值、初始容量、负载因子、非同步、迭代器快速失败就和就和HashMap一样了</p><p>说白了，LinkedHashMap就是为了解决HashMap无法保证输出顺序的问题而生的。</p><h1 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h1><h2 id="2-1-静态常量"><a href="#2-1-静态常量" class="headerlink" title="2.1. 静态常量"></a>2.1. 静态常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表头节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表尾节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否按访问时间排序，构造函数中会用到</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><h2 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2.2. 方法"></a>2.2. 方法</h2><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/LinkedHashMap/LinkedHashMap%E5%85%A8%E9%83%A8%E6%96%B9%E6%B3%95.1ri1zh0sh5og.webp" alt="LinkedHashMap全部方法"></p><h3 id="2-2-1-构造方法"><a href="#2-2-1-构造方法" class="headerlink" title="2.2.1. 构造方法"></a>2.2.1. 构造方法</h3><p>五种，基本上都是调用父类HashMap的操作，值得注意的是e.设定按访问时间排序的那种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.无参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.指定初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(initialCapacity);</span><br><span class="line">accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.指定初始容量和负载因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//d.复制一个Map</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">accessOrder = <span class="literal">false</span>;</span><br><span class="line">putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//e.设定为按访问时间排序，accessOrder = true</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                     <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                     <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line"><span class="built_in">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-put方法"><a href="#2-2-2-put方法" class="headerlink" title="2.2.2. put方法"></a>2.2.2. put方法<a id="222"></a></h3><p>全部调用父类HashMap的put方法，但是父类HashMap是个单向链表，这是个双向链表，怎么适用的呢？head和tail在哪里初始化的呢？答案是这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap.putVal</span></span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>由于子类LinkedHashMap重写了newNode方法，因此创建的节点是特殊双向链表类型的节点，这个节点大体上还是HashMap中的节点没变，每个桶中单向链表的链接方式也没变，但是每个Entry对象中多了一个before和after对象，这就意味着在原哈希表不变的基础上将每个节点按照插入的顺序前后链接了起来，而不管这个节点落在了哪个桶中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap.newNode</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">linkNodeLast(p);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap.linkNodeLast</span></span><br><span class="line"><span class="comment">//head和tail都是在这里初始化的</span></span><br><span class="line"><span class="comment">//第一次插入节点，tail和head都为空，因此指向同一节点p(首次插入的节点)；之后last不可能为空，则tail向后移动,head始终不变</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">tail = p;</span><br><span class="line"><span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">head = p;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p.before = last;</span><br><span class="line">last.after = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/LinkedHashMap/Node%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.1inwe8wyl9b.gif" alt="Node初始化过程"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap.Entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">Entry&lt;K,V&gt; before, after;<span class="comment">//before, after分别指向当前节点的前驱结点和后继节点</span></span><br><span class="line">Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/LinkedHashMap/LinkedHashMap%E9%9D%9E%E5%B8%B8%E8%A7%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.4dakza8830u0.webp" alt="LinkedHashMap非常规双向链表"></p><p>如果你把这个“双向链表”理解成了每个桶中单向链表修改成双向链表，那么一定有个疑问，LinkedHashMap使用的是HashMap的put方法，那些tab[i]命中桶的逻辑在LinkedHashMap中没有实现，怎么命中的呢？通过这个图就知道，HashMap我什么都没动，只是拿过来添加了另外的两条线，我什么都用HashMap的，只是最后遍历输出时用我自己的遍历方法而已。</p><h3 id="2-2-3-get方法"><a href="#2-2-3-get方法" class="headerlink" title="2.2.3. get方法"></a>2.2.3. get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和父类HashMap的get方法基本一致，只不过多了一个是否需要按访问时间进行排序的判断条件</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line"><span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (accessOrder)</span><br><span class="line">afterNodeAccess(e);</span><br><span class="line"><span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////设定一个默认值，若查询到节点则以节点的value返回；若未查询到节点则以自定义的默认值返回</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> defaultValue;</span><br><span class="line">       <span class="keyword">if</span> (accessOrder)</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">       <span class="keyword">return</span> e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-afterNodeAccess方法"><a href="#2-2-4-afterNodeAccess方法" class="headerlink" title="2.2.4. afterNodeAccess方法"></a>2.2.4. afterNodeAccess方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将最近访问的节点移动到最后，适用于按访问时间排序输出时</span></span><br><span class="line"><span class="comment">//注意这个方法只是操作双向链表的(红线，与黑线无关)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; last;<span class="comment">//e是需要移动的节点,last是原链表最后一个节点</span></span><br><span class="line"><span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">    (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;<span class="comment">//a</span></span><br><span class="line">p.after = <span class="literal">null</span>;<span class="comment">//b</span></span><br><span class="line"><span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">head = a;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b.after = a;<span class="comment">//c</span></span><br><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">a.before = b;<span class="comment">//d</span></span><br><span class="line"><span class="type">else</span></span><br><span class="line"><span class="variable">last</span> <span class="operator">=</span> b;</span><br><span class="line"><span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">head = p;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p.before = last;<span class="comment">//e</span></span><br><span class="line">last.after = p;<span class="comment">//f</span></span><br><span class="line">&#125;</span><br><span class="line">tail = p;<span class="comment">//g</span></span><br><span class="line">++modCount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合put方法最后的那张图，这个方法实际上并没有对基础哈希表(黑线)做什么改变，它只是将双向链表中某一个节点(红线)移动到链表末尾(head、tail、after、before都是LinkedHashMap特有的，比HashMap多的)，从而实现按访问时间排序的目的。</p><p>abcdefg分别对应下图中的7张图：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/LinkedHashMap/afterNodeAccess%E6%93%8D%E4%BD%9C.2tphyh44use0.gif" alt="afterNodeAccess操作"></p><h3 id="2-2-5-afterNodeInsertion方法"><a href="#2-2-5-afterNodeInsertion方法" class="headerlink" title="2.2.5. afterNodeInsertion方法"></a>2.2.5. afterNodeInsertion方法</h3><p>插入节点后移除创建最久的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">//但是removeEldestEntry()这个方法在不重写的情况下返回false，所以永远不会进入这个if语句</span></span><br><span class="line">    <span class="comment">//那这个方法有什么用？可能是重新实现一个LinkedHashMap时会用到吧，重写removeEldestEntry()这个方法</span></span><br><span class="line"><span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line"><span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-6-removeEldestEntry方法"><a href="#2-2-6-removeEldestEntry方法" class="headerlink" title="2.2.6. removeEldestEntry方法"></a>2.2.6. removeEldestEntry方法</h3><p>移除创建最久的Entry</p><p>官方文档中写着可以通过这种方法控制Entry的条目数，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个方法是个protected方法，这意味着只有在和LinkedHashMap同包的类才能使用，所以重新实现一个LinkedHashMap再重写这个方法时才能用到？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-7-afterNodeRemoval方法"><a href="#2-2-7-afterNodeRemoval方法" class="headerlink" title="2.2.7. afterNodeRemoval方法"></a>2.2.7. afterNodeRemoval方法</h3><p>HashMap.removeNode方法后处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap.removeNode</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">...</span><br><span class="line">afterNodeRemoval(node);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于仅修改双向链表的指向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">    (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">p.before = p.after = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">head = a;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b.after = a;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">tail = b;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-8-containsValue方法"><a href="#2-2-8-containsValue方法" class="headerlink" title="2.2.8. containsValue方法"></a>2.2.8. containsValue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用双向链表遍历，速度更快；HashMap是先定位桶，再遍历链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after) &#123;</span><br><span class="line"><span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> e.value;</span><br><span class="line"><span class="keyword">if</span> (v == value || (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-9-clear方法"><a href="#2-2-9-clear方法" class="headerlink" title="2.2.9. clear方法"></a>2.2.9. clear方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比HashMap多了一步，将双向链表的首尾节点置空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.clear();</span><br><span class="line">head = tail = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-10-replaceAll方法"><a href="#2-2-10-replaceAll方法" class="headerlink" title="2.2.10. replaceAll方法"></a>2.2.10. replaceAll方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换所有key的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; function)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (function == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line"><span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">e.value = function.apply(e.key, e.value);</span><br><span class="line"><span class="keyword">if</span> (modCount != mc)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">map.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="number">33</span>,<span class="number">1</span>);</span><br><span class="line">map.replaceAll(<span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//第一个参数为key，第二个参数为value</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer integer, Integer integer2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> integer+integer2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;Integer, Integer&gt; m = it.next();</span><br><span class="line">System.out.println(m.getKey()+<span class="string">&quot; &quot;</span>+m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">17</span> <span class="number">25</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">33</span> <span class="number">34</span></span><br></pre></td></tr></table></figure><h3 id="2-2-11-replacementNode方法"><a href="#2-2-11-replacementNode方法" class="headerlink" title="2.2.11. replacementNode方法"></a>2.2.11. replacementNode方法</h3><p>用新节点替换旧节点(链表)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被调用地方：HashMap.untreeify：红黑树退化为链表</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">hd = p;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tl.next = p;</span><br><span class="line">tl = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap.replacementNode</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap.replacementNode</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="comment">//q记录要替换的原节点p</span></span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">    <span class="comment">//t为初始化完成的q</span></span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; t =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">    <span class="comment">//用t替换p</span></span><br><span class="line">transferLinks(q, t);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap和LinkedHashMap中处理逻辑基本一致，都是创建一个新节点复制原节点的信息，再将新节点链接起来，只不过LinkedHashMap中多了双向链表的逻辑</p><h3 id="2-2-12-replacementTreeNode方法"><a href="#2-2-12-replacementTreeNode方法" class="headerlink" title="2.2.12. replacementTreeNode方法"></a>2.2.12. replacementTreeNode方法</h3><p>用新节点替换旧节点(红黑树)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被调用地方：HashMap.treeifyBin：链表进化为红黑树</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line"><span class="type">int</span> n, index;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line"><span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">resize();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">hd = p;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p.prev = tl;</span><br><span class="line">tl.next = p;</span><br><span class="line">&#125;</span><br><span class="line">tl = p;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">hd.treeify(tab);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap.replacementTreeNode</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap.replacementTreeNode</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">TreeNode&lt;K,V&gt; t = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">transferLinks(q, t);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap和LinkedHashMap中处理逻辑基本一致，都是创建一个新节点复制原节点的信息，再将新节点链接起来，只不过LinkedHashMap中多了双向链表的逻辑</p><h3 id="2-2-13-transferLinks方法"><a href="#2-2-13-transferLinks方法" class="headerlink" title="2.2.13. transferLinks方法"></a>2.2.13. transferLinks方法</h3><p>更新双向链表中的链接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * src：原Entry</span></span><br><span class="line"><span class="comment"> * dst：目的Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span><br><span class="line"><span class="params">                           LinkedHashMap.Entry&lt;K,V&gt; dst)</span> &#123;</span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">head = dst;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b.after = dst;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">tail = dst;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">a.before = dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-14-forEach方法"><a href="#2-2-14-forEach方法" class="headerlink" title="2.2.14. forEach方法"></a>2.2.14. forEach方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据双向链表的顺序输出；HashMap是根据桶的顺序一个链表一个链表的输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line"><span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">action.accept(e.key, e.value);</span><br><span class="line"><span class="keyword">if</span> (modCount != mc)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-15-entrySet方法"><a href="#2-2-15-entrySet方法" class="headerlink" title="2.2.15. entrySet方法"></a>2.2.15. entrySet方法</h3><p>将LinkedHashMap里的每个&lt;K,V&gt;(键值对)封装成Entry对象，并返回Entry对象的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line"><span class="keyword">return</span> (es = entrySet) == <span class="literal">null</span> ? (entrySet = <span class="keyword">new</span> <span class="title class_">LinkedEntrySet</span>()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展：</p><p>entrySet属性定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p>LinkedEntrySet内部类定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedEntrySet内部类定义</span></span><br><span class="line"><span class="comment">//继承于AbstractSet，是一个Entry对象的Set集合</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedEntrySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line"><span class="comment">//EntrySet的大小，即LinkedHashMap的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123;</span><br><span class="line">LinkedHashMap.<span class="built_in">this</span>.clear();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取遍历Entry对象的迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedEntryIterator</span>();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断LinkedHashMap中是否含有某对键值对，传入的参数应该是个Entry对象，即封装好后的键值对</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line"><span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line"><span class="keyword">return</span> candidate != <span class="literal">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除LinkedHashMap中某对键值对，参数要求同上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line"><span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line"><span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line"><span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, Spliterator.SIZED |</span><br><span class="line">                                Spliterator.ORDERED |</span><br><span class="line">                                Spliterator.DISTINCT);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历EntrySet，在accept()方法中自定义操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line"><span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">action.accept(e);</span><br><span class="line"><span class="keyword">if</span> (modCount != mc)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">map1.put(<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">map1.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map1.put(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">map2.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map2.put(<span class="number">9</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//iterator()方法获取迭代器，it实际是一个LinkedEntryIterator对象</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map1.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;Integer, Integer&gt; entry1 = it.next();</span><br><span class="line"><span class="comment">//contains()方法</span></span><br><span class="line"><span class="keyword">if</span>(map2.entrySet().contains(entry1)) &#123;</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">//remove()方法</span></span><br><span class="line">map2.entrySet().remove(entry1);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;key：&quot;</span>+entry1.getKey()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;Value：&quot;</span>+entry1.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//forEach()方法</span></span><br><span class="line">map2.entrySet().forEach(entry2 -&gt; System.out.println(<span class="string">&quot;key：&quot;</span>+entry2.getKey()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;Value：&quot;</span>+entry2.getValue()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//size()方法</span></span><br><span class="line">System.out.println(map1.entrySet().size());</span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key：<span class="number">1</span> Value：<span class="number">9</span></span><br><span class="line">key：<span class="number">17</span> Value：<span class="number">8</span></span><br><span class="line">key：<span class="number">5</span> Value：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">key：<span class="number">9</span> Value：<span class="number">9</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="2-2-16-keySet方法"><a href="#2-2-16-keySet方法" class="headerlink" title="2.2.16. keySet方法"></a>2.2.16. keySet方法</h3><p>返回所有key的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原理和entrySet方法一样</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">Set&lt;K&gt; ks = keySet;</span><br><span class="line"><span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">ks = <span class="keyword">new</span> <span class="title class_">LinkedKeySet</span>();</span><br><span class="line">keySet = ks;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展：</p><p>keySet属性定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;K&gt;        keySet;</span><br></pre></td></tr></table></figure><p>LinkedKeySet内部类定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedKeySet内部类定义</span></span><br><span class="line"><span class="comment">//原理和LinkedEntrySet内部类一样</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedKeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123;</span><br><span class="line">LinkedHashMap.<span class="built_in">this</span>.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedKeyIterator</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title function_">spliterator</span><span class="params">()</span>  &#123;</span><br><span class="line"><span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, Spliterator.SIZED |</span><br><span class="line">                                Spliterator.ORDERED |</span><br><span class="line">                                Spliterator.DISTINCT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> K&gt; action)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line"><span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">action.accept(e.key);</span><br><span class="line"><span class="keyword">if</span> (modCount != mc)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例类比entrySet方法</p><h3 id="2-2-17-values方法"><a href="#2-2-17-values方法" class="headerlink" title="2.2.17. values方法"></a>2.2.17. values方法</h3><p>返回所有value的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">Collection&lt;V&gt; vs = values;</span><br><span class="line"><span class="keyword">if</span> (vs == <span class="literal">null</span>) &#123;</span><br><span class="line">vs = <span class="keyword">new</span> <span class="title class_">LinkedValues</span>();</span><br><span class="line">values = vs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展：</p><p>values属性定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure><p>LinkedValues内部类定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedValues内部类定义</span></span><br><span class="line"><span class="comment">//原理和LinkedEntrySet内部类一样</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedValues</span> <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;V&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123;</span><br><span class="line">LinkedHashMap.<span class="built_in">this</span>.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedValueIterator</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> containsValue(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, Spliterator.SIZED |</span><br><span class="line">                                Spliterator.ORDERED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line"><span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="literal">null</span>; e = e.after)</span><br><span class="line">action.accept(e.value);</span><br><span class="line"><span class="keyword">if</span> (modCount != mc)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例类比entrySet方法</p><h3 id="2-2-18-几个迭代器"><a href="#2-2-18-几个迭代器" class="headerlink" title="2.2.18. 几个迭代器"></a>2.2.18. 几个迭代器<a id="2218"></a></h3><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/LinkedHashMap/LinkedHashMap%E5%87%A0%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8.3wnmjm0gbpw0.webp" alt="LinkedHashMap几个迭代器"></p><p>大体和HashMap的迭代器差不多</p><p>区别就在于迭代输出方式，HashMap是根据桶的顺序从前往后一个链表一个链表的输出，LinkedHashMap是根据双向链表链接的顺序输出</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>,<span class="number">0.75f</span>);</span><br><span class="line"><span class="comment">//1，17，33在同一个桶里</span></span><br><span class="line">map.put(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">map.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="number">33</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;Integer, Integer&gt; m = it.next();</span><br><span class="line">System.out.println(m.getKey()+<span class="string">&quot; &quot;</span>+m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个it引用指向的是一个LinkedEntryIterator对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap.LinkedEntryIterator</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedEntryIterator</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashIterator</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Map.Entry&lt;K,V&gt; <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nextNode();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而输出时调用到了next()方法，实际上调用了nextNode()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap.nextNode</span></span><br><span class="line"><span class="keyword">final</span> LinkedHashMap.Entry&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line"><span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line"><span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">current = e;</span><br><span class="line">next = e.after;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是在双向链表中根据after这个属性往后遍历，所以插入顺序是怎么样的，输出顺序就是怎么样的(不按访问时间排序的情况下)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TODO：红黑树的逻辑&lt;/p&gt;
&lt;h1 id=&quot;1-前情提要&quot;&gt;&lt;a href=&quot;#1-前情提要&quot; class=&quot;headerlink&quot; title=&quot;1. 前情提要&quot;&gt;&lt;/a&gt;1. 前情提要&lt;/h1&gt;&lt;p&gt;LinkedHashMap继承了HashMap&lt;/p&gt;
&lt;p&gt;Li</summary>
      
    
    
    
    <category term="集合" scheme="https://lisj98.github.io/categories/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="LinkedHashMap" scheme="https://lisj98.github.io/tags/LinkedHashMap/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="https://lisj98.github.io/2022/09/08/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://lisj98.github.io/2022/09/08/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-09-08T14:08:24.000Z</published>
    <updated>2022-09-08T14:12:34.579Z</updated>
    
    <content type="html"><![CDATA[<p>TODO：红黑树的逻辑</p><h1 id="1-前情提要"><a href="#1-前情提要" class="headerlink" title="1. 前情提要"></a>1. 前情提要</h1><p>HashMap实现了Map接口，允许空键和空值；</p><p>HashMap底层是哈希表，也就是说它的本质是哈希表(数组+链表)，链表超过一定长度会用红黑树代替，理解HashMap就把它想象成哈希表，再在哈希表的基础上去理解；</p><p>HashMap是及其类似于Hashtable的，只是它是unsynchronized的，也允许空键和空值，不保证Map中元素的顺序（插入顺序、访问顺序等，原因见<a href="#2415">2.4.15</a>）；</p><p>遍历集合所需的时间和HashMap实例的capacity(容量)、size(大小)成正比，所以初始容量不宜设置太高、负载因子不宜设置太低；</p><p>HashMap实例有两个影响性能的因素：initial capacity(初始容量)、load factor(负载因子)。容量指哈希表中桶(也称bin，bucket)的个数，注意容量和元素数量(键值对)不是一样的概念，初始容量是哈希表被创建时的容量，负载因子是哈希表在其元素数量增加之前所允许达到的最大度量。当哈希表中的元素数量超过了当前容量(容量会不断扩容，所以是当前容量)和负载因子的乘积时，哈希表会进行扩容(resize)；</p><p>默认负载因子是0.75，默认初始容量是16；</p><p>使用足够大的capacity比让它重复resize效率更好；</p><p>注意HashMap的实现不是同步的，多个线程同时操作一个HashMap时可能会出问题，要解决此问题，要么进行同步控制，要么使用<code>Collections.synchronizedMap(new xxxMap())</code>方法来包装Map，这个方法中当map调用put、get、keySet、entrySet等方法时会对当前对象进行加锁，因此保证了线程安全：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/Synchronized.6zidejqqdz00.webp" alt="Synchronized"></p><p>iterator(迭代器)方面，如果在创建迭代器之后对集合进行了修改，那么迭代器将立即抛出ConcurrentModificationException(快速失败)，只能通过迭代器自己的remove()方法来修改集合才是安全的，它通过控制modCount和expectedModCount来判断集合是否被修改了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">Node&lt;K,V&gt; p = current;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line"><span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">current = <span class="literal">null</span>;</span><br><span class="line"><span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> p.key;</span><br><span class="line">removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">expectedModCount = modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意迭代器的快速失败不是百分百保证的，也就是说它可能抛出异常，也可能不抛出异常，所以不能依赖于迭代器抛出异常来检测错误操作；</p><p>HashMap结构示例：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E4%BE%8B.ifyj1ucliow.webp" alt="哈希表示例"></p><h1 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h1><p>HashMap&lt;K,V&gt;：继承于AbstractMap&lt;K,V&gt;接口，后者实现了Map&lt;K,V&gt;接口</p><h2 id="2-1-属性"><a href="#2-1-属性" class="headerlink" title="2.1. 属性"></a>2.1. 属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始容量，16，容量必须是2的幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量，2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认负载因子，0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO：红黑树的相关常量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组结构</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Node&lt;K,V&gt;静态内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map中键值对的数目</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map被修改过的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行resize的临界点(capacity * load factor)，初始值为0</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子(不是默认负载因子)</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h2 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2.2. 方法"></a>2.2. 方法</h2><h3 id="x2F-x2F-TODO-2-2-1-hash"><a href="#x2F-x2F-TODO-2-2-1-hash" class="headerlink" title="&#x2F;&#x2F;TODO 2.2.1. hash()"></a>&#x2F;&#x2F;TODO 2.2.1. hash()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算出key对应的hashcode，然后将hashcode和其右移16位后的值进行异或运算得出hash值，然后在后面通过hash值得出桶的下标</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-构造方法"><a href="#2-2-2-构造方法" class="headerlink" title="2.2.2. 构造方法"></a>2.2.2. 构造方法</h3><p>有4种类型的构造方法：</p><ol><li>无参构造，只初始化负载因子，且为默认负载因子</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>直接复制一个Map</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//putMapEntries()方法，最后还是调用到putVal()方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>含初始容量和负载因子的有参构造</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种指定初始容量，负载因子为默认</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这种指定初始容量和负载因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//判断初始容量，&lt;0自然不合法则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//初始容量设置的值比最大容量还大，则限制为最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//负载因子数值不合法则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">//初始化HashMap实例的负载因子和扩容阈值</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tableSizeFor()方法，返回大于cap的最接近2的幂的数，因为表容量必须是2的倍数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//无符号右移1位，再进行或运算</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">//上面的操作就是不断补齐最高位后面的1，然后+1就得到了2的幂</span></span><br><span class="line">    <span class="comment">//比如：cap=28(00011100)，最后得到的n就是00011111，再加1就得到了32</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上构造函数有几点需要说明：扩容阈值(threshold)可能并不是想象中的 capacity*load factor，容量(capacity)(不是初始容量initialCapacity)也没有被初始化，那么容量什么时候被初始化的呢？threshold为什么不是capacity*load factor呢？</p><p>其实是在执行put()方法更准确来说是resize()方法时才确定了HashMap的当前容量和扩容阈值</p><h3 id="2-4-2-put方法"><a href="#2-4-2-put方法" class="headerlink" title="2.4.2. put方法"></a>2.4.2. put方法</h3><p>不知道转了几手的流程图：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/%E4%B8%8D%E7%9F%A5%E9%81%93%E8%BD%AC%E4%BA%86%E5%87%A0%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.4x3r9sra0so0.webp" alt="不知道转了几手的流程图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们所使用的常规put方法,最后调用的都是putVal方法</span></span><br><span class="line"><span class="comment">//第一种，最常见</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">putMapEntries(m, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四种</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ? (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五种：putVal方法</p><p>拆分解析：</p><p>块1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab;<span class="comment">//哈希表的桶</span></span><br><span class="line">Node&lt;K,V&gt; p; <span class="comment">//每个桶下的链表节点</span></span><br><span class="line"><span class="type">int</span> n, i;</span><br></pre></td></tr></table></figure><p>块2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最开始节点个数(table.length)为0，哈希表中没有元素,而threshold经过构造函数中的tableSizeFor()方法指定了一个大于初始容量的最接近2的幂的数，这个数后来作为容量使用(具体见resize方法 ),而现在容量是0，因此需要resize设定表容量和阈值</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure><p>块3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(n - 1) &amp; hash：计算出key在哈希表中的下标，即哪个桶</span></span><br><span class="line"><span class="comment">//p = tab[i = (n - 1) &amp; hash]：即将p指向链表首节点，此后就在这个桶下的这个链表中进行操作</span></span><br><span class="line"><span class="comment">//若该下标下没有元素，则新建节点并将节点地址存在桶中</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/putVar%E6%96%B9%E6%B3%95%E5%9D%973.38w9p6tkluw0.webp" alt="putVar方法块3"></p><p>块4：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p在块3中已经指向新建立的节点了，这一步就是判断要put的这个&lt;K,V&gt;是否和已存在的节点一致，若一致，则e和p指向同一节点，并在之后的块7中覆盖原有值</span></span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/putVal%E6%96%B9%E6%B3%95%E5%9D%974.7earmake1ow0.webp" alt="putVal方法块4"></p><p>块5：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断链表是否已经转成了红黑树，若已经是红黑树了则需要加的不是普通链表节点而是树节点了</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br></pre></td></tr></table></figure><p>块6：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//既没有转成红黑树，key也不存在</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">//p在前面的块2中指向了第一个链表节点，若不存在下一个节点，则直接链接在后面</span></span><br><span class="line">    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//链表长度达到8，桶数组长度达到64时转成红黑树，binCount=7就意味着即将建立第8个链表节点，这个时候就应该转成红黑树了</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//e在上面的if语句中指向了新节点，p.next和e指向了同一节点，而p.next用的和下面这个if语句同样的hash、key、value,用意是什么？结束for循环。</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//p,e交换，目的是向后遍历</span></span><br><span class="line">p = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/putVal%E6%96%B9%E6%B3%95%E5%9D%976.1jpc17pv6280.webp" alt="putVal方法块6"></p><p>块7：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新值换旧值</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">    e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="comment">//注意这里的return仅仅是方法返回值，节点中的实际值已经通过e.value = value改了</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>块8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录对Map的修改次数，用于迭代器遍历时判断Map是否被修改过</span></span><br><span class="line">++modCount;</span><br><span class="line"><span class="comment">//大于阈值则扩容</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br></pre></td></tr></table></figure><h3 id="2-4-3-resize方法"><a href="#2-4-3-resize方法" class="headerlink" title="2.4.3. resize方法"></a>2.4.3. resize方法</h3><p>需要注意当Map中的元素数量达到阈值时才会触发resize操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表=数组+链表，链表长度动态可变，所以下面就直接称呼表而不称数组了，实际上容量变的是数组的容量</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">// oldTab指向旧表(Node&lt;K,V&gt;数组)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">// 旧表的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;<span class="comment">//原扩容阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a.旧表中有元素</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//旧表容量超过HashMap最大限度，没什么好说的，最大化处理，它也不能再扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//&lt;&lt;1左移1位，相当于*2</span></span><br><span class="line">        <span class="comment">//新表容量*2满足条件的情况下，旧阈值也*2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//b.旧表中没元素且旧阈值&gt;0，则新表容量设为旧阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//c.旧表没元素且旧阈值为0，新表容量设为默认初始容量16，新阈值为默认负载因子0.75*默认初始容量16=12</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对应上述b情况</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果新表容量和*负载因子后的结果也不超过限定最大容量，新阈值则为新表容量*负载因子，否则只能设为最大值</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阈值更新</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面就是复制旧表到新表的过程了</span></span><br><span class="line">    <span class="comment">//旧表不为空则需要执行复制操作，旧表为空则不用管</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上便是resize的过程，总结：</p><p>a.旧表有数据：</p><p>​    a.1. 旧表容量已经超过或等于最大容量了，则只将阈值更新到最大；</p><p>​    a.2. 旧表容量&gt;&#x3D;默认初始容量16且*2后&lt;最大容量2^30，则容量和阈值均*2；</p><p>​    a.3. 不满足a.2条件，则更新容量*2，新阈值&#x3D;新容量*负载因子；</p><p>b. 旧表无数据(容量为0)且旧阈值&gt;0(构造函数指定了初始容量)，则更新容量&#x3D;旧阈值，新阈值&#x3D;新容量*负载因子，对应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧表无数据即第一次put时</span></span><br><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">7</span>);<span class="comment">//因为无参构造函数只指定了默认负载因子，因此阈值为初始值0</span></span><br></pre></td></tr></table></figure><p>c. 旧表无数据且旧阈值&#x3D;0，则新表容量设为DEFAULT_INITIAL_CAPACITY&#x3D;16，新表阈值设为DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY&#x3D;12，完完全全的默认初始化，对应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧表无数据即第一次put时</span></span><br><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();<span class="comment">//因为无参构造函数只指定了默认负载因子，因此阈值为初始值0</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">1</span>,<span class="number">0.8f</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">capacityMethod</span> <span class="operator">=</span> map.getClass().getDeclaredMethod(<span class="string">&quot;capacity&quot;</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">thresholdField</span> <span class="operator">=</span> map.getClass().getDeclaredField(<span class="string">&quot;threshold&quot;</span>);</span><br><span class="line">    thresholdField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    capacityMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">        map.put(i,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容量：&quot;</span>+capacityMethod.invoke(map)+<span class="string">&quot; &quot;</span>+<span class="string">&quot;阈值：&quot;</span>+thresholdField.get(map)+<span class="string">&quot; &quot;</span>+<span class="string">&quot;元素数量&quot;</span>+map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/resize%E5%AE%B9%E9%87%8F%E3%80%81%E9%98%88%E5%80%BC%E3%80%81%E5%85%83%E7%B4%A0%E6%95%B0%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.vk3dvkxflr4.webp" alt="resize容量、阈值、元素数量之间的关系"></p><p>值得注意的一点是threshold这个属性在最开始初始化的时候其实是作为容量来体现的，在tableSizeFor()方法中会将用户自定义的初始容量参数传进去，得到一个大于这个数的最接近2的幂的数，然后赋值给threshold这个属性，这个时候threshold!&#x3D;capacity*load factor，查看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (table != <span class="literal">null</span>) ? table.length :</span><br><span class="line">        (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">        DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这个时候threshold就是容量，然后在resize的过程中threshold才恢复了阈值的作用，到那个时候threshold&#x3D;&#x3D;capacity*load factor这个式子才算成立。</p><h3 id="2-4-4-get方法"><a href="#2-4-4-get方法" class="headerlink" title="2.4.4. get方法"></a>2.4.4. get方法</h3><p>获取某个key对应的value值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//get链表节点方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">//桶</span></span><br><span class="line">    Node&lt;K,V&gt; first, e; <span class="comment">//链表节点</span></span><br><span class="line">    <span class="type">int</span> n; </span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">//链表首节点不为空，则遍历链表，否则说明不存在查询节点，返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//链表首节点和所查询节点hash、key值均相同则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//链表首节点并非查询节点则继续向后遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//树节点调用对应的树方法</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//否则一直向后遍历直到找到查询节点，直接返回节点</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/getNode%E6%96%B9%E6%B3%95.2dkydqxx9wis.webp" alt="getNode方法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设定一个默认值，若查询到节点则以节点的value返回；若未查询到节点则以自定义的默认值返回</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-5-containsKey方法"><a href="#2-4-5-containsKey方法" class="headerlink" title="2.4.5. containsKey方法"></a>2.4.5. containsKey方法</h3><p>查询是否包含指定key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际上调用了getNode方法判断key是否存在</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-6-containsValue方法"><a href="#2-4-6-containsValue方法" class="headerlink" title="2.4.6. containsValue方法"></a>2.4.6. containsValue方法</h3><p>查询是否包含指定value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">//桶</span></span><br><span class="line">    V v;<span class="comment">//中间值</span></span><br><span class="line">    <span class="comment">//表不为null该方法才有执行下去的必要</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//遍历整个链表，找到就返回true，否则返回false</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="comment">//这里并没有重写equals方法，所以里面还是用==判断，也就是判断实际物理地址是否相等，物理地址相等的自然肯定是同一对象了</span></span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-7-isEmpty方法"><a href="#2-4-7-isEmpty方法" class="headerlink" title="2.4.7. isEmpty方法"></a>2.4.7. isEmpty方法</h3><p>判断表是否为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过表中元素数量判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-8-clear方法"><a href="#2-4-8-clear方法" class="headerlink" title="2.4.8. clear方法"></a>2.4.8. clear方法</h3><p>清除表中所有元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">//记录对表的修改次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//表不为空则直接全部置空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-9-remove方法"><a href="#2-4-9-remove方法" class="headerlink" title="2.4.9. remove方法"></a>2.4.9. remove方法</h3><p>移除指定元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅匹配key</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//key、value一起匹配</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实际操作方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">//桶</span></span><br><span class="line">    Node&lt;K,V&gt; p; <span class="comment">//链表节点</span></span><br><span class="line">    <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">//表不为空才有移除的必要</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e;<span class="comment">//node节点为待删除节点</span></span><br><span class="line">        K k; V v;</span><br><span class="line">        <span class="comment">//a.首节点为所查询节点则将node指向该节点以便后续移除</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">//没找到则向后遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//树节点调用树对应方法</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//b.从第二节点(e = p.next)开始，找到则将node指向该节点以便后续移除，没找到则继续向后遍历</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">//注意这个break，若找到了查询节点，那么node是指向p后面一个节点的，如果没找到，那么node为null</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除节点步骤</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">//树节点调用对应的树节点移除方法</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">//对应上述a情况，即链表首节点就是所查询节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">//对应上述b情况，删除node节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">//记录修改表的次数</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">//元素数量减1</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/removeNode.ujnuf2ygshs.gif" alt="removeNode"></p><h3 id="2-4-10-replace方法"><a href="#2-4-10-replace方法" class="headerlink" title="2.4.10. replace方法"></a>2.4.10. replace方法</h3><p>替换指定key对应的value值</p><p>效果等同于put覆盖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换指定key对应的value值</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">replace</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当指定key的值等于oldValue时才将其替换为newValue</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="literal">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换所有key的值</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; function)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (function == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                e.value = function.apply(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-12-forEach方法"><a href="#2-4-12-forEach方法" class="headerlink" title="2.4.12. forEach方法"></a>2.4.12. forEach方法</h3><p>遍历Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                action.accept(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&#x27;c&#x27;</span>,<span class="number">9</span>);</span><br><span class="line">map.put(<span class="string">&#x27;e&#x27;</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="string">&#x27;d&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;Character, Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Character c, Integer i)</span> &#123;    <span class="comment">//两个参数分别为key和value</span></span><br><span class="line">    System.out.println(c+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/forEach%E6%96%B9%E6%B3%95.4f9a2slush40.webp" alt="forEach方法"></p><h3 id="2-4-12-compute方法"><a href="#2-4-12-compute方法" class="headerlink" title="2.4.12. compute方法"></a>2.4.12. compute方法</h3><p>用来对指定key的value值进行自定义操作，也可用来创建新节点(作为put使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compute方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(K key,</span></span><br><span class="line"><span class="params">                 BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; first; </span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="literal">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="literal">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//e先指向链表首节点</span></span><br><span class="line">            Node&lt;K,V&gt; e = first; </span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//找到目标节点则old指向目标节点并退出循环，没找到则向后遍历</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//oldValue记录目标节点的值</span></span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> (old == <span class="literal">null</span>) ? <span class="literal">null</span> : old.value;</span><br><span class="line">    <span class="comment">//不管key存在与否，只对值进行操作，apply方法指定具体操作，v是操作后的返回值</span></span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> remappingFunction.apply(key, oldValue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面为找目标节点过程，下面为修改值的过程</span></span><br><span class="line">    <span class="comment">//目标节点存在</span></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//新值不为空</span></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//修改目标节点的值为新值</span></span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新值为空则移除节点(注意)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            removeNode(hash, key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//目标节点不存在但是apply后有明确值返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//t是树操作的节点</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="built_in">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这个时候就要根据compute方法入参的key和新值v来创建新节点了</span></span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="comment">//红黑树转换</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意key不存在时不要使用compute这种方法，因为key不存在value自然不存在，值为null，而若remappingFunction.apply方法中对入参value做了操作，就相当于拿null和其他值做计算，肯定会出错。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&#x27;c&#x27;</span>,<span class="number">4</span>);</span><br><span class="line">map.put(<span class="string">&#x27;e&#x27;</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="string">&#x27;d&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//key存在且计算后的值不为空</span></span><br><span class="line">map.compute(<span class="string">&#x27;c&#x27;</span>, <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;Character, Integer, Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Character character, Integer integer)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> integer+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//key存在但计算后的值为空，会移除该节点</span></span><br><span class="line">map.compute(<span class="string">&#x27;c&#x27;</span>, (character, integer) -&gt; <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//key不存在但计算后的值不为空</span></span><br><span class="line">map.compute(<span class="string">&#x27;f&#x27;</span>, (character, integer) -&gt; <span class="number">9</span>);</span><br><span class="line"><span class="comment">//key不存在且计算后的值为空</span></span><br><span class="line">map.compute(<span class="string">&#x27;g&#x27;</span>, (character, integer) -&gt; <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//错误示例：key不存在时操作value</span></span><br><span class="line"><span class="comment">//map.compute(&#x27;f&#x27;, (character, integer) -&gt; integer+1);</span></span><br><span class="line"></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;Character, Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Character character, Integer integer)</span> &#123;</span><br><span class="line">System.out.println(character+<span class="string">&quot; &quot;</span>+integer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/compute%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.1owplt2d3j34.webp" alt="compute方法运行结果"></p><p>其他类似方法：</p><p>computeIfAbsent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">computeIfAbsent</span><span class="params">(K key,</span></span><br><span class="line"><span class="params">                         Function&lt;? <span class="built_in">super</span> K, ? extends V&gt; mappingFunction)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mappingFunction == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">Node&lt;K,V&gt;[] tab;</span><br><span class="line">Node&lt;K,V&gt; first;</span><br><span class="line"><span class="type">int</span> n, i;</span><br><span class="line"><span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">TreeNode&lt;K,V&gt; t = <span class="literal">null</span>;</span><br><span class="line">Node&lt;K,V&gt; old = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="literal">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">n = (tab = resize()).length;</span><br><span class="line"><span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;K,V&gt; e = first;</span><br><span class="line">K k;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">old = e;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">++binCount;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//a.和compute方法不同点就在于这里，若key存在则直接返回值，也就相当于什么都不做</span></span><br><span class="line">V oldValue;</span><br><span class="line"><span class="keyword">if</span> (old != <span class="literal">null</span> &amp;&amp; (oldValue = old.value) != <span class="literal">null</span>) &#123;</span><br><span class="line">afterNodeAccess(old);</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> mappingFunction.apply(key);</span><br><span class="line">    <span class="comment">//新值为空不移除节点</span></span><br><span class="line"><span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;<span class="comment">//有key有value则一定会在a处返回，除非最开始put时只存了key，value为null才会走到这一步</span></span><br><span class="line">old.value = v;</span><br><span class="line">afterNodeAccess(old);</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">t.putTreeVal(<span class="built_in">this</span>, tab, hash, key, v);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tab[i] = newNode(hash, key, v, first);</span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line">&#125;</span><br><span class="line">++modCount;</span><br><span class="line">++size;</span><br><span class="line">afterNodeInsertion(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和compute的区别就是：只有旧value为null的时候才会更新value(key不存在时也会新建节点并更新value)。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&#x27;c&#x27;</span>,<span class="number">4</span>);</span><br><span class="line">map.put(<span class="string">&#x27;e&#x27;</span>,<span class="literal">null</span>);</span><br><span class="line">map.put(<span class="string">&#x27;d&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//key存在且对应的value也存在，什么都不做</span></span><br><span class="line">map.computeIfAbsent(<span class="string">&#x27;c&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Character, Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Character character)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//计算后的值为空，什么都不做</span></span><br><span class="line">map.computeIfAbsent(<span class="string">&#x27;c&#x27;</span>, character -&gt; <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//最开始put时只存了key，没存value，更新value</span></span><br><span class="line">map.computeIfAbsent(<span class="string">&#x27;e&#x27;</span>, character -&gt; <span class="number">8</span>);</span><br><span class="line"><span class="comment">//key不存在且计算后的值不为空，新建节点</span></span><br><span class="line">map.computeIfAbsent(<span class="string">&#x27;g&#x27;</span>, character -&gt; <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;Character, Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Character character, Integer integer)</span> &#123;</span><br><span class="line">System.out.println(character+<span class="string">&quot; &quot;</span>+integer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/computeIfAbsent%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.5qjfdm9md0w0.webp" alt="computeIfAbsent方法运行结果"></p><p>computeIfPresent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">computeIfPresent</span><span class="params">(K key,</span></span><br><span class="line"><span class="params">                          BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (remappingFunction == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line">V oldValue;</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">//key存在且value也存在才会执行操作</span></span><br><span class="line"><span class="keyword">if</span> ((e = getNode(hash, key)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (oldValue = e.value) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="comment">//新值不为空则更新</span></span><br><span class="line"><span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">e.value = v;</span><br><span class="line">afterNodeAccess(e);</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//新值为空则移除节点</span></span><br><span class="line">removeNode(hash, key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其他两个方法的区别是：key不存在时不会新建节点了，和compute一致，新值为空时会移除节点</p><p>举例;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&#x27;c&#x27;</span>,<span class="number">4</span>);</span><br><span class="line">map.put(<span class="string">&#x27;e&#x27;</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="string">&#x27;d&#x27;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//key存在，value也存在，新值不为空</span></span><br><span class="line">map.computeIfPresent(<span class="string">&#x27;c&#x27;</span>, <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;Character, Integer, Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Character character, Integer integer)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//key存在，value也存在，新值为空，移除节点</span></span><br><span class="line">map.computeIfPresent(<span class="string">&#x27;e&#x27;</span>, (character, integer) -&gt; <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//key存在，value=null，什么都不做</span></span><br><span class="line">map.computeIfPresent(<span class="string">&#x27;d&#x27;</span>, (character, integer) -&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">//key不存在，不新建节点</span></span><br><span class="line">map.computeIfPresent(<span class="string">&#x27;f&#x27;</span>, (character, integer) -&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;Character, Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Character character, Integer integer)</span> &#123;</span><br><span class="line">System.out.println(character+<span class="string">&quot; &quot;</span>+integer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/computeIfPresent%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.15npz7f010zg.webp" alt="computeIfPresent方法运行结果"></p><p>compute方法总结：</p><table><thead><tr><th></th><th>compute</th><th>computeIfAbsent</th><th>computeIfPresent</th></tr></thead><tbody><tr><td>key!&#x3D;null,value!&#x3D;null,V!&#x3D;null</td><td>update</td><td>nothing</td><td>update</td></tr><tr><td>key!&#x3D;null,value!&#x3D;null,V&#x3D;&#x3D;null</td><td>delete</td><td>nothing</td><td>delete</td></tr><tr><td>key!&#x3D;null,value&#x3D;null,V!&#x3D;null</td><td>update</td><td>update</td><td>nothing</td></tr><tr><td>key!&#x3D;null,value&#x3D;null,V&#x3D;&#x3D;null</td><td>delete</td><td>nothing</td><td>nothing</td></tr><tr><td>key&#x3D;&#x3D;null,V!&#x3D;null</td><td>insert</td><td>insert</td><td>nothing</td></tr><tr><td>key&#x3D;&#x3D;null,V&#x3D;&#x3D;null</td><td>nothing</td><td>nothing</td><td>nothing</td></tr></tbody></table><p>compute：V非空则更新或插入，V为空则删除</p><p>computeIfAbsent：在key和value至少有一个不存在的前提下，V非空则更新或插入</p><p>computeIfPresent：key和value都存在的前提下，V非空则更新，V为空则删除</p><h3 id="2-4-13-merge方法"><a href="#2-4-13-merge方法" class="headerlink" title="2.4.13. merge方法"></a>2.4.13. merge方法</h3><p>相当于带有默认值的compute方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">merge</span><span class="params">(K key, V value,</span></span><br><span class="line"><span class="params">               BiFunction&lt;? <span class="built_in">super</span> V, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">    <span class="comment">//value参数不能为空</span></span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="keyword">if</span> (remappingFunction == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">Node&lt;K,V&gt;[] tab;</span><br><span class="line">Node&lt;K,V&gt; first;</span><br><span class="line"><span class="type">int</span> n, i;</span><br><span class="line"><span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">TreeNode&lt;K,V&gt; t = <span class="literal">null</span>;</span><br><span class="line">Node&lt;K,V&gt; old = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="literal">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">n = (tab = resize()).length;</span><br><span class="line"><span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;K,V&gt; e = first;</span><br><span class="line">K k;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">old = e;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">++binCount;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到目标节点</span></span><br><span class="line"><span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">V v;</span><br><span class="line"><span class="keyword">if</span> (old.value != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//目标节点的value存在则把该value和merge方法入参value作用的结果，或其他自定义值赋值给v</span></span><br><span class="line">v = remappingFunction.apply(old.value, value);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            <span class="comment">//目标节点的value为空则把merge方法入参value赋值给v</span></span><br><span class="line">v = value;</span><br><span class="line"><span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//新值不为空则更新旧值</span></span><br><span class="line">old.value = v;</span><br><span class="line">afterNodeAccess(old);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//新值为空则移除节点</span></span><br><span class="line">removeNode(hash, key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//没查询到目标节点则创建新节点，这个判断有点多余？之前已经判断value==null会抛异常</span></span><br><span class="line"><span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">t.putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tab[i] = newNode(hash, key, value, first);</span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line">&#125;</span><br><span class="line">++modCount;</span><br><span class="line">++size;</span><br><span class="line">afterNodeInsertion(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&#x27;c&#x27;</span>,<span class="number">4</span>);</span><br><span class="line">map.put(<span class="string">&#x27;e&#x27;</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="string">&#x27;d&#x27;</span>,<span class="literal">null</span>);</span><br><span class="line">map.put(<span class="string">&#x27;f&#x27;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//key!=null,value!=null,V!=null</span></span><br><span class="line">map.merge(<span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer integer, Integer integer2)</span> &#123;</span><br><span class="line">System.out.println(integer+<span class="string">&quot; &quot;</span>+integer2);</span><br><span class="line"><span class="keyword">return</span> integer+integer2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//key!=null,value!=null,V==null</span></span><br><span class="line">map.merge(<span class="string">&#x27;e&#x27;</span>, <span class="number">2</span>, (integer, integer2) -&gt; <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//key!=null,value==null,V!=null</span></span><br><span class="line">map.merge(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>, (integer, integer2) -&gt; integer2);</span><br><span class="line"><span class="comment">//key!=null,value==null,V==null</span></span><br><span class="line">map.merge(<span class="string">&#x27;f&#x27;</span>, <span class="number">4</span>, (integer, integer2) -&gt; <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//key==null=,V!=null</span></span><br><span class="line">map.merge(<span class="string">&#x27;g&#x27;</span>, <span class="number">5</span>, (integer, integer2) -&gt; integer2);</span><br><span class="line"><span class="comment">//key==null=,V==null</span></span><br><span class="line">map.merge(<span class="string">&#x27;h&#x27;</span>, <span class="number">6</span>, (integer, integer2) -&gt; <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;Character, Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Character character, Integer integer)</span> &#123;</span><br><span class="line">System.out.println(character+<span class="string">&quot; &quot;</span>+integer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/merge%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.43dcsk8f7ec0.webp" alt="merge方法运行结果"></p><h3 id="2-4-12-entrySet方法"><a href="#2-4-12-entrySet方法" class="headerlink" title="2.4.12. entrySet方法"></a>2.4.12. entrySet方法</h3><p>将HashMap里的每个&lt;K,V&gt;(键值对)封装成Entry对象，并返回Entry对象的Set集合，是对Map集合进行遍历的一种方法</p><p>Map中用Entry对象来表示一个键值对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="literal">null</span> ? (entrySet = <span class="keyword">new</span> <span class="title class_">EntrySet</span>()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展：</p><p>entrySet属性定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p>Map.Entry接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">    K <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">setValue</span><span class="params">(V value)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下的几个比较方法可以根据key或value进行比较，由于HashMap是不保证顺序的，所以在需要实现Map转换为有序List时就可以使用这些方法</span></span><br><span class="line">    <span class="comment">//返回一个根据key进行比较的比较器(默认升序)，key必须实现Comparable接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() &#123;</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个根据value进行比较的比较器(默认升序)，value必须实现Comparable接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() &#123;</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义比较规则，根据key进行比较</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? <span class="built_in">super</span> K&gt; cmp) &#123;</span><br><span class="line">            Objects.requireNonNull(cmp);</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义比较规则，根据value进行比较</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? <span class="built_in">super</span> V&gt; cmp) &#123;</span><br><span class="line">            Objects.requireNonNull(cmp);</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.5.2</span></span><br></pre></td></tr></table></figure><p>几个comparingByKey&#x2F;Value方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">map.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//原始顺序</span></span><br><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; collect = map.entrySet().stream().collect(Collectors.toList());</span><br><span class="line"><span class="comment">//ComparingByKey()</span></span><br><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; listComparingByKeyNoArgument = map.entrySet().stream().sorted(Map.Entry.comparingByKey()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//ComparingByValue()</span></span><br><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; listComparingByValueNoArgument = map.entrySet().stream().sorted(Map.Entry.comparingByValue()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//comparingByKey(Comparator&lt;? super K&gt; cmp)</span></span><br><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; listComparingByKeyWithArgument = map.entrySet().stream().sorted((o1, o2) -&gt; o2.getKey() - o1.getKey()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//comparingByValue(Comparator&lt;? super K&gt; cmp)</span></span><br><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; listComparingByValueWithArgument = map.entrySet().stream().sorted((o1, o2) -&gt; o2.getValue() - o1.getValue()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/comparingByKey%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95.6lesgcfuw5s0.webp" alt="comparingByKey的几个方法"></p><p>EntrySet内部类定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EntrySet内部类定义</span></span><br><span class="line"><span class="comment">//继承于AbstractSet，是一个Entry对象的Set集合</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EntrySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">//EntrySet的大小，即HashMap的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空HashMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取遍历Entry对象的迭代器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EntryIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断HashMap中是否含有某对键值对，传入的参数应该是个Entry对象，即封装好后的键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="literal">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除HashMap中某对键值对，参数要求同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EntrySpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历EntrySet，在accept()方法中自定义操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">map1.put(<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">map1.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map1.put(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">map2.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map2.put(<span class="number">9</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//iterator()方法获取迭代器，it实际是一个EntryIterator对象</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map1.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">Map.Entry&lt;Integer, Integer&gt; entry1 = it.next();</span><br><span class="line">    <span class="comment">//contains()方法</span></span><br><span class="line">    <span class="keyword">if</span>(map2.entrySet().contains(entry1))&#123;</span><br><span class="line">    flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//remove()方法</span></span><br><span class="line">        map2.entrySet().remove(entry1);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">&quot;key：&quot;</span>+entry1.getKey()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;Value：&quot;</span>+entry1.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//forEach()方法</span></span><br><span class="line">map2.entrySet().forEach(entry2 -&gt; System.out.println(<span class="string">&quot;key：&quot;</span>+entry2.getKey()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;Value：&quot;</span>+entry2.getValue()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//size()方法</span></span><br><span class="line">System.out.println(map1.entrySet().size());</span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/entrySet%E4%B8%BE%E4%BE%8B.3b50cuul0fg0.webp" alt="entrySet举例"></p><h3 id="2-4-13-keySet方法"><a href="#2-4-13-keySet方法" class="headerlink" title="2.4.13. keySet方法"></a>2.4.13. keySet方法</h3><p>返回所有key的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原理和entrySet方法一样</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> <span class="title class_">KeySet</span>();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展：</p><p>keySet属性定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;K&gt;        keySet;</span><br></pre></td></tr></table></figure><p>KeySet内部类定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KeySet内部类定义</span></span><br><span class="line"><span class="comment">//原理和EntrySet内部类一样</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyIterator</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeySpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> K&gt; action)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例类比entrySet方法</p><h3 id="2-4-14-values方法"><a href="#2-4-14-values方法" class="headerlink" title="2.4.14. values方法"></a>2.4.14. values方法</h3><p>返回所有value的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="literal">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> <span class="title class_">Values</span>();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展：</p><p>values属性定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure><p>Values内部类定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Values内部类定义</span></span><br><span class="line"><span class="comment">//原理和EntrySet内部类一样</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Values</span> <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ValueIterator</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ValueSpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例类比entrySet方法</p><h3 id="2-4-15-几个迭代器"><a href="#2-4-15-几个迭代器" class="headerlink" title="2.4.15. 几个迭代器"></a>2.4.15. 几个迭代器<a id="2415"></a></h3><p><img src="https://cdn.staticaly.com/gh/lisj98/image-hosting@master/HashMap/HashMap%E5%87%A0%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8.op8t8pcuwio.webp" alt="HashMap几个迭代器"></p><p>略过</p><p>要说明的一点是HashMap的随机顺序不是说乱序输出，而是顺序和插入顺序不一致，它是根据桶的顺序从前往后一个链表一个链表的输出。这种随机输出也是根据迭代器的实现方式来说的，你要是实现一个遍历输出时元素顺序跟插入顺序一致的迭代器，那也可以说HashMap是有序的，完全是取决于迭代器的情况。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>,<span class="number">0.75f</span>);</span><br><span class="line"><span class="comment">//1，17，33在同一个桶里</span></span><br><span class="line">map.put(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">map.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="number">33</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;Integer, Integer&gt; m = it.next();</span><br><span class="line">System.out.println(m.getKey()+<span class="string">&quot; &quot;</span>+m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个it引用指向的是一个EntryInterator对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap.EntryIterator</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EntryIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Map.Entry&lt;K,V&gt; <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nextNode();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而输出时调用到了next()方法，实际上调用了nextNode()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap.HashIterator.nextNode</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">Node&lt;K,V&gt;[] t;</span><br><span class="line">Node&lt;K,V&gt; e = next;</span><br><span class="line"><span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line"><span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">//注意这里</span></span><br><span class="line"><span class="keyword">if</span> ((next = (current = e).next) == <span class="literal">null</span> &amp;&amp; (t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法就可以看出，EntryInterator这个迭代器在进行迭代输出时，是根据桶的顺序从前往后一个链表一个链表的输出，而这与我们的插入顺序是不一致的，同时从主观层面上讲，不同的key映射到不同的桶这一点对于我们来说是不清晰的，我们也没必要知道映射到了哪里，只要知道它映射到了正确的位置就行了，所以才说HashMap是不保证顺序的，完全取决于迭代器的实现逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">17</span> <span class="number">8</span></span><br><span class="line"><span class="number">33</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="x2F-x2F-TODO-2-4-16-树的几种方法"><a href="#x2F-x2F-TODO-2-4-16-树的几种方法" class="headerlink" title="&#x2F;&#x2F;TODO 2.4.16. 树的几种方法"></a>&#x2F;&#x2F;TODO 2.4.16. 树的几种方法</h3><h2 id="2-5-补充"><a href="#2-5-补充" class="headerlink" title="2.5. 补充"></a>2.5. 补充</h2><h3 id="2-5-1-遍历Map的几种方法"><a href="#2-5-1-遍历Map的几种方法" class="headerlink" title="2.5.1.遍历Map的几种方法"></a>2.5.1.遍历Map的几种方法</h3><ol><li>通过keySet方法得到key的集合，再通过key得到value</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">map.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer i : map.keySet()) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;key：&quot;</span>+i+<span class="string">&quot; &quot;</span>+<span class="string">&quot;Value：&quot;</span>+map.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过entrySet方法和iterator</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">map.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">Map.Entry&lt;Integer, Integer&gt; e = it.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;key：&quot;</span>+e.getKey()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;Value：&quot;</span>+e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>只通过entrySet方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">map.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; e : map.entrySet()) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;key：&quot;</span>+e.getKey()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;Value：&quot;</span>+e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>通过values方法，但是只能得到value</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">map.put(<span class="number">17</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer i : map.values()) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol start="5"><li>通过forEach方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&#x27;c&#x27;</span>,<span class="number">9</span>);</span><br><span class="line">map.put(<span class="string">&#x27;e&#x27;</span>,<span class="number">8</span>);</span><br><span class="line">map.put(<span class="string">&#x27;d&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;Character, Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Character c, Integer i)</span> &#123;    <span class="comment">//两个参数分别为key和value</span></span><br><span class="line">    System.out.println(c+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-5-2-Comparable和Comparator区别"><a href="#2-5-2-Comparable和Comparator区别" class="headerlink" title="2.5.2. Comparable和Comparator区别"></a>2.5.2. Comparable和Comparator区别</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TODO：红黑树的逻辑&lt;/p&gt;
&lt;h1 id=&quot;1-前情提要&quot;&gt;&lt;a href=&quot;#1-前情提要&quot; class=&quot;headerlink&quot; title=&quot;1. 前情提要&quot;&gt;&lt;/a&gt;1. 前情提要&lt;/h1&gt;&lt;p&gt;HashMap实现了Map接口，允许空键和空值；&lt;/p&gt;
&lt;p&gt;H</summary>
      
    
    
    
    <category term="集合" scheme="https://lisj98.github.io/categories/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="HashMap" scheme="https://lisj98.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC之applicationContext与xxx-servlet.xml的区别</title>
    <link href="https://lisj98.github.io/2022/04/11/SpringMVC%E4%B9%8BapplicationContext%E4%B8%8Exxx-servlet-xml%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://lisj98.github.io/2022/04/11/SpringMVC%E4%B9%8BapplicationContext%E4%B8%8Exxx-servlet-xml%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-04-11T08:00:32.000Z</published>
    <updated>2022-09-13T09:03:07.913Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 官方文档介绍如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spring lets you define multiple contexts in a parent-child hierarchy.  　　The applicationContext.xml defines the beans for the &quot;root webapp context&quot;, i.e. the context associated with the webapp.  </span><br><span class="line">　　The spring-servlet.xml (or whatever else you call it) defines the beans for one servlet&#x27;s app context. There can be many of these in a webapp, one per Spring servlet (e.g. spring1-servlet.xml for servlet spring1, spring2-servlet.xml for servlet spring2).  </span><br><span class="line">　　Beans in spring-servlet.xml can reference beans in applicationContext.xml, but not vice versa.  </span><br><span class="line">　　All Spring MVC controllers must go in the spring-servlet.xml context.  </span><br><span class="line">　　In most simple cases, the applicationContext.xml context is unnecessary. It is generally used to contain beans that are shared between all servlets in a webapp. If you only have one servlet, then there&#x27;s not really much point, unless you have a specific use for it.</span><br></pre></td></tr></table></figure><p>由此可得，applicationContext.xml 和 diapatcher-servlet.xml 形成了两个父子关系的上下文，区别在于：</p><ol><li>一个 bean 如果在两个文件中都被定义了（比如两个文件中都定义了 component-scan 扫描相同的 package），Spring 会在 application context 和 servlet  context 中都生成一个实例，它们处于不同的上下文中，他们的行为方式可能是不一样的。</li><li>如果在 application context 和 servlet context 中都存在同一个 @Service 的实例，controller 通过 @Resource 引用时，会优先选择 servlet context 中的实例。</li><li>servlet context 可以引用 applicaiton context 里的实例，反之不可以。</li><li>多个 servlet 共享 application context 里的实例。</li><li>在 applicationContext.xml 和 diapatcher-servlet.xml 中定义的 bean 最好不要重复，diapatcher-servlet 最好只扫描 controller，applicationContext 扫描其他。</li><li>applicationContext.xml 是 Spring 全局配置文件，用来控制 Spring 特性的。</li><li>diapatcher-servlet.xml 是 Spring MVC 里面的，主要用来配置控制器、拦截器、视图等 Spring MVC 特有组件。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring 官方文档介绍如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="SpringMVC" scheme="https://lisj98.github.io/categories/SpringMVC/"/>
    
    
  </entry>
  
  <entry>
    <title>精通SpringMVC(八)-杂项</title>
    <link href="https://lisj98.github.io/2022/04/11/%E7%B2%BE%E9%80%9ASpringMVC-%E5%85%AB-%E6%9D%82%E9%A1%B9/"/>
    <id>https://lisj98.github.io/2022/04/11/%E7%B2%BE%E9%80%9ASpringMVC-%E5%85%AB-%E6%9D%82%E9%A1%B9/</id>
    <published>2022-04-11T07:44:29.000Z</published>
    <updated>2022-09-08T14:38:59.106Z</updated>
    
    <content type="html"><![CDATA[<p>本系列笔记所有代码地址：<a class="link"   href="https://github.com/lisj98/SpringMVCSource.git" >https://github.com/lisj98/SpringMVCSource.git<i class="fas fa-external-link-alt"></i></a></p><h4 id="8-1-静态资源处理"><a href="#8-1-静态资源处理" class="headerlink" title="8.1 静态资源处理"></a>8.1 静态资源处理</h4><p>优雅 REST 风格的资源 URL 不希望带 .html 或 .do 等后缀，然而对 Spring MVC 来说，如果将 DispatcherServlet 请求映射配置为“&#x2F;”，则 Spring MVC 将捕获 Web 容器所有的请求，包括静态资源的请求，Spring MVC 会将它们当成一个普通请求来处理，因找不到对应的处理器而导致错误。</p><p>如何让 Spring 框架能够捕获所有 URL 的请求，同时又将静态资源的请求转由 Web 容器处理，是可将 DispatcherServlet 的请求映射配置成“&#x2F;”的前提。有两种解决方案。</p><p>首先需要调整 web.xml 中 DispatcherServlet 的配置，使其可以捕获所有的请求：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>smart<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>smart<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--只配置一个“/”可以保证所有请求都被DispatcherServlet捕获--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="1-采用-lt-mvc-default-servlet-handler-x2F-gt"><a href="#1-采用-lt-mvc-default-servlet-handler-x2F-gt" class="headerlink" title="1. 采用 &lt;mvc:default-servlet-handler&#x2F;&gt;"></a>1. 采用 &lt;mvc:default-servlet-handler&#x2F;&gt;</h5><p>在 smart-servlet.xml 中配置 &lt;mvc:default-servlet-handler&#x2F;&gt; 后，会在 Spring MVC 上下文中定义一个 <code>org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler</code>，它将对进入 DispatcherServlet 的 URL 进行筛查。如果发现是静态资源的请求，就将该请求转由 Web 应用服务器默认的 Servlet 处理；如果不是静态资源，则由 DispatcherServlet 继续处理。</p><p>一般 Web 应用服务器默认的 Servlet 名称都是 default，因此，DefaultServletHttpRequestHandler 可以找到它。如果用户所使用的 Web 服务器的默认 Servlet 名称不是 default，则需要通过 default-servlet-name 属性显式指定：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> <span class="attr">default-servlet-name</span>=<span class="string">&quot;yourServletName&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-采用-lt-mvc-resources-x2F-gt"><a href="#2-采用-lt-mvc-resources-x2F-gt" class="headerlink" title="2. 采用 &lt;mvc:resources&#x2F;&gt;"></a>2. 采用 &lt;mvc:resources&#x2F;&gt;</h5><p>&lt;mvc:default-servlet-handler&#x2F;&gt; 将静态资源的处理经由 Spring MVC 框架交回 Web 应用服务器。而 &lt;mvc:resources&#x2F;&gt; 更进一步，由 Spring MVC 框架自己处理静态资源，并添加一些有用的附加功能。</p><p>&lt;mvc:resources&#x2F;&gt; 允许静态资源放置在任何地方，如 WEB-INF 目录下、类路径下等，甚至可以将 JavaScript 等静态文件打包到 JAR 包中。通过 location 属性指定静态资源的位置，由于 location 属性是 Resource 属性，因此可以使用诸如“classpath:”等的资源前缀指定资源位置。传统 Web 容器的静态资源只能放在 Web 容器的根路径下，&lt;mvc:resources&#x2F;&gt; 则完全打破了这个规则。</p><p>在 smart-servlet.xml 中添加以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/resources/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/,classpath:/META-INF/publicResources/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p> 以上配置将 Web 根路径“&#x2F;“及类路径 &#x2F;META-INF&#x2F;publicResources&#x2F; 下的目录映射为 &#x2F;resources 路径。假设 Web 根路径下拥有 images 和 js 这两个资源目录，则可以通过下图所示的方式引用静态资源：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84.1hzw4tt4lzds.webp" alt="静态资源路径映射"></p><p>类路径下的资源同样如此。</p><p>由于 &lt;mvc:resources&#x2F;&gt; 可以将多个物理路径映射为一个逻辑路径，因此，一个用逻辑路径表示的资源在多个物理路径下都存在。对于这个问题，&lt;mvc:resources&#x2F;&gt; 的处理机制是，只要在一个物理路径下找到匹配的资源后就返回，查找的顺序和物理路径在 location 中的配置顺序一致。</p><p>那么既然将 Web 根路径”&#x2F;“映射为”&#x2F;resources&#x2F;**“，那么是否可以在网页中通过 ”&#x2F;resources&#x2F;WEB-INF&#x2F;web.xml“ 访问这个敏感的文件呢？答案是否定的。Spring MVC 在处理映射的静态资源时，会查看引用路径是否包含 WEB-INF 或 META-INF，如果包括，则直接返回 null 值，以保护文件不泄露出去。当然，如果将 &#x2F;WEB-INF&#x2F; 设置在 location 属性中，则可以通过 &#x2F;resources&#x2F;web.xml 的 URL 查看到 web.xml。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/resources/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/WEB-INF/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>所以使用 &lt;mvc:resources&#x2F;&gt; 时应该小心，只暴露应该暴露的资源，而保护好不应该暴露的资源。</p><p>通过使用 &lt;mvc:resources&#x2F;&gt; 的 cache-period 属性可以设置静态资源在客户端浏览器中的缓存有效时间。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/resources/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/,classpath:/META-INF/publicResources&quot;</span> <span class="attr">cache-period</span>=<span class="string">&quot;3153600&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在发布新版本的应用时，即使服务器端的 JavaScript、CSS 等静态资源文件已经发生了变化，但是由于客户端浏览器本身缓存管理机制的问题，客户端并不会从服务器端下载新的静态资源。一个好的解决方法是：网页中引用静态资源的路径添加应用的发布版本号，这样在发布新的版本时，由于版本号的变更造成网页中静态资源路径发生更改，从而使这些静态资源成为“新的资源”，客户端浏览器就会下载这个“新的资源”，而不会使用缓存中的数据。针对这个解决思路，可以通过 &lt;mvc:resources&#x2F;&gt; 的静态资源逻辑路径给出一个通用的解决方案。</p><p>将发布版本号包含到 &lt;mvc:resources&#x2F;&gt; 的静态资源逻辑路径中，首先创建一个 ServletContextAware 实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcePathExposer</span> <span class="keyword">implements</span> <span class="title class_">ServletContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line">    <span class="keyword">private</span> String resourceRoot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//在实际应用中，可以在外部属性文件或数据库中保存应用的发布版本号，在此处获取之，此处仅仅提供了一个模拟值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> <span class="string">&quot;1.2.1&quot;</span>;</span><br><span class="line">        <span class="comment">//资源逻辑路径带上应用的发布版本号</span></span><br><span class="line">        resourceRoot = <span class="string">&quot;/resources-&quot;</span> + version;</span><br><span class="line">        <span class="comment">//将资源逻辑路径暴露到ServletContext的属性列表中</span></span><br><span class="line">        getServletContext().setAttribute(<span class="string">&quot;resourceRoot&quot;</span>, getServletContext().getContextPath() + resourceRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServletContext</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.servletContext = servletContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getResourceRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resourceRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServletContext <span class="title function_">getServletContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> servletContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ResourcePathExposer 中获取应用程序的发布版本号，产生一个带版本号的静态资源路径 resourceRoot，同时将其值发布到 ServletContext 中，这样 JSP 文件就可以通过 ${resourceRoot} 引用其值了。</p><p>接下来要调整 smart-servlet.xml 的配置，以便使用带版本的静态资源逻辑路径：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置好ResourcePathExposer，并指定初始化方法为init()，以便在容器启动时让其初始化resourceRoot的值，由于其实现了ServletContextAware接口，因此，Spring会在初始化该Bean时将ServletContext引用注入进来--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;rpe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.web.ResourcePathExposer&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--通过Spring EL表达式引用ResourcePathExposer的resourceRoot属性值，生成动态的静态资源逻辑路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;#&#123;rpe.resourceRoot&#125;/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/&quot;</span> <span class="attr">cache-period</span>=<span class="string">&quot;31536000&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>最后修正网页中引用静态资源的方式：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span>      uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;静态资源测试&lt;/title&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;$&#123;resourceRoot&#125;/js/test.js&quot;</span> type=<span class="string">&quot;text/javascript&quot;</span>&gt; &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt; </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    hello!!</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">       test();    </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>由于静态资源中引用的 resourceRoot 值和 &lt;mvc:resources&#x2F;&gt; 通过 #{rpe.resourceRoot} 引用的值是一样的，所以可以正确访问到物理静态资源。这样，每次发布新版本后，随着发布版本号的更改，客户端就会自动下载新的静态资源。</p><h4 id="8-2-装配拦截器"><a href="#8-2-装配拦截器" class="headerlink" title="8.2 装配拦截器"></a>8.2 装配拦截器</h4><p>当收到请求时，DispatcherServlet 将请求交给处理器映射（HandlerMapping）,让它找出对应该请求的 HandlerExecutionChain 对象。</p><p>HandlerExecutionChain 顾名思义是一个执行链，它包含一个处理该请求的处理器（Handler），同时包括若干个对该请求实施拦截的拦截器（HandleInterceptor）。当 HandlerMapping 返回 HandlerExecutionChain 后，DispatcherServlet 将请求交给定义在 HandlerExecutionChain 中的拦截器和处理器一并处理。</p><p>HandlerExecutionChain 是负责处理请求并返回 ModelAndView 的处理执行链，请求在被 Handler 执行的前后，链中装配的 HandlerInterceptor 会实施拦截操作。</p><p>HandlerExecutionChain 的结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/HandlerExecutionChain%E7%BB%93%E6%9E%84%E5%9B%BE.6spvwdh0qlk0.webp" alt="HandlerExecutionChain结构图"></p><p>拦截器到底做了什么事？我们通过考察拦截器的几个接口方法进行了解：</p><ul><li>boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)：在请求到达 Handler 之前，先执行这个前置处理方法。当该方法返回 false 时，请求直接返回，不会传递到链中的下一个拦截器，更不会传递到处理器链末端的 Handler 中。只有返回 true 时，请求才向链中的下一个处理节点传递。</li><li>void postHandler(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)：在请求被 HandlerAdapter 执行后，执行这个后置处理方法。</li><li>void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)：在响应已经被渲染后，执行该方法。</li></ul><p>位于处理器链末端的是一个 Handler，DispatcherServlet 通过 HandlerAdapter 适配器对 Handler 进行疯转，并按统一的适配器接口对 Handler 处理方法进行调用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/secure/*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.web.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以在 smart-servlet.xml 中配置多个拦截器，每个拦截器都可以指定一个匹配的映射路径，以限制拦截器的作用范围。</p><h4 id="8-3-异常处理"><a href="#8-3-异常处理" class="headerlink" title="8.3 异常处理"></a>8.3 异常处理</h4><p>Spring MVC 通过 HandlerExceptionResolver 处理程序的异常，包括处理器映射、数据绑定及处理器执行时发生的异常。HandlerExceptionResolver 仅有一个接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span><br></pre></td></tr></table></figure><p>当发生异常时，Spring MVC 将调用 resolveException() 方法，并转到 ModelAndView 对应的视图中，作为一个异常报告页面反馈给用户。</p><p>HandlerExceptionResolver 拥有 4 个实现类，分别是：</p><ul><li>DefaultHandlerExceptionResolver</li><li>SimpleMappingExceptionResolver</li><li>AnnotationMethodHandlerExceptionResolver</li><li>ResponseStatusExceptionResolver</li></ul><h5 id="1-DefaultHandlerExceptionResolver"><a href="#1-DefaultHandlerExceptionResolver" class="headerlink" title="1. DefaultHandlerExceptionResolver"></a>1. DefaultHandlerExceptionResolver</h5><p>Spring MVC 默认装配了 DefaultHandlerExceptionResolver，它会将 Spring MVC 框架的异常转换为响应的响应状态码。</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E5%BC%82%E5%B8%B8%E5%92%8C%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%E5%AF%B9%E5%BA%94%E8%A1%A81.3wld0fvful80.webp" alt="异常和响应状态码对应表1"></p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E5%BC%82%E5%B8%B8%E5%92%8C%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%E5%AF%B9%E5%BA%94%E8%A1%A82.1quwz4c0lmao.webp" alt="异常和响应状态码对应表2"></p><p>也可以在 web.xml 中为响应状态码配置一个对应的页面，如;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-AnnotationMethodHandlerExceptionResolver"><a href="#2-AnnotationMethodHandlerExceptionResolver" class="headerlink" title="2. AnnotationMethodHandlerExceptionResolver"></a>2. AnnotationMethodHandlerExceptionResolver</h5><p>Spring MVC 默认注册了 AnnotationMethodHandlerExceptionResolver，它允许通过 @ExceptionHandler 注解指定处理特定异常的方法。如：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/@ExceptionHandler%E7%94%A8%E6%B3%95.5kw73rnhdk00.webp" alt="@ExceptionHandler用法"></p><p>@ExceptionHandler 可以指定多个不同类型的异常，如 @ExceptionHandler({AException.class, BException.class})，但是要注意，标注 @ExceptionHandler 的异常处理类只能对同一处理器中的其他方法进行异常响应处理，而不能处理其他控制器中的方法异常。</p><h5 id="3-ResponseStatusExceptionResolver"><a href="#3-ResponseStatusExceptionResolver" class="headerlink" title="3. ResponseStatusExceptionResolver"></a>3. ResponseStatusExceptionResolver</h5><p>ResponseStatusExceptionResolver 和 DefaultHandlerExceptionResolver 类似，通过 @ResponseStatus 注解标注一个方法，用于处理特定类型的响应状态码。</p><h5 id="4-SimpleMappingExceptionResolver"><a href="#4-SimpleMappingExceptionResolver" class="headerlink" title="4. SimpleMappingExceptionResolver"></a>4. SimpleMappingExceptionResolver</h5><p>如果希望对所有的异常进行统一处理，则可以使用 SimpleMappingExceptionResolver，它将异常类名映射为视图名，即发生异常时使用对应的视图报告异常。</p><p>如以下异常映射配置片段：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;handlerExceptionResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.springframework.dao.DataAccessException&quot;</span>&gt;</span>dataAccessFailure1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;org.springframework.transaction.TransactionException&quot;</span>&gt;</span>dataAccessFailure2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当控制器发生 DataAccessException 异常时，使用 dataAccessFailure1 视图显示。</p><p>当控制器发生 TransactionException 异常时，使用 dataAccessFailure2 视图显示。</p><p>当然，也可以自己实现 ExceptionResolver 覆盖 resolveException() 接口方法，编写自己的异常解析器，执行一些特定的工作。</p><h4 id="8-4-RequestContextHolder-的使用"><a href="#8-4-RequestContextHolder-的使用" class="headerlink" title="8.4 RequestContextHolder 的使用"></a>8.4 RequestContextHolder 的使用</h4><p>RequestContextHolder 能够在 Controller 中获取 request 和 session 对象，其使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();</span><br></pre></td></tr></table></figure><p>需要注意的是，如果直接使用该工具类，会抛出一个空指针异常，原因是还需要在 web.xml 中配置一个监听器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    org.springframework.web.context.request.RequestContextListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列笔记所有代码地址：&lt;a class=&quot;link&quot;   href=&quot;https://github.com/lisj98/SpringMVCSource.git&quot; &gt;https://github.com/lisj98/SpringMVCSource.git&lt;i class</summary>
      
    
    
    
    <category term="SpringMVC" scheme="https://lisj98.github.io/categories/SpringMVC/"/>
    
    
  </entry>
  
  <entry>
    <title>精通SpringMVC(七)-WebSocket支持</title>
    <link href="https://lisj98.github.io/2022/04/11/%E7%B2%BE%E9%80%9ASpringMVC-%E4%B8%83-WebSocket%E6%94%AF%E6%8C%81/"/>
    <id>https://lisj98.github.io/2022/04/11/%E7%B2%BE%E9%80%9ASpringMVC-%E4%B8%83-WebSocket%E6%94%AF%E6%8C%81/</id>
    <published>2022-04-11T06:12:49.000Z</published>
    <updated>2022-09-08T14:38:49.017Z</updated>
    
    <content type="html"><![CDATA[<p>本系列笔记所有代码地址：<a class="link"   href="https://github.com/lisj98/SpringMVCSource.git" >https://github.com/lisj98/SpringMVCSource.git<i class="fas fa-external-link-alt"></i></a></p><h4 id="7-1-使用-WebSocket"><a href="#7-1-使用-WebSocket" class="headerlink" title="7.1 使用 WebSocket"></a>7.1 使用 WebSocket</h4><p>通常应用程序之间发送消息会使用诸如 JMS、AMQP 等技术，但是如果实现浏览器和服务器的全双工通信，则以上技术是不适用的。但是这样的需求又是普遍存在的，因此诞生了一项新的技术，这便是 <strong>WebSocket</strong> 协议，它很好地<strong>解决了浏览器与服务器全双工通信的问题</strong>，而且能更好地节省服务器资源和带宽并达到实时通信。</p><p>Spring 4.0 主要为 WebSocket 通信提供了以下几个方面的支持：</p><ul><li>发送和接收消息的 API。</li><li>用来发送消息的模板。</li><li>支持 SockJS，用来解决浏览器、服务器及代理不支持 WebSocket 的问题。</li></ul><p>WebSocket 可以用在任何类型的应用中，其最简单的形式是在两个应用之间建立通信的通道。</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E5%BA%94%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84WebSocket%E9%80%9A%E4%BF%A1.7e2lekcc7dc0.webp" alt="应用之间的WebSocket通信"></p><p>位于 WebSocket 一端的应用发送消息，而另一端的应用处理消息，因为它是全双工通信的，所以每一端既可以发送又可以处理消息。但是 WebSocket 最为常见的应用场景是实现服务器和基于浏览器的应用之间的通信。在浏览器中使用 JavaScript 开启一个到达服务器的连接，服务器通过这个连接发送更新到浏览器中。相对于传统的在 Web 端轮询服务器及使用 Flash 中的 Socket 和 XMLSocket，这种方式更加高效、便捷。</p><p>下面通过一个在 Web 端使用 JavaScript 与服务器端相互传递“Hello World!”文本信息的例子来展示 WebSocket 的用法。</p><p>Spring 提供了一个 <strong>WebSocketHandler</strong> 接口，该接口定义了 5 个 WebSocket 相关的接口方法。</p><p>Spring 拥有一个 WebSocketHandler 接口的抽象实现类 <strong>AbstractWebSocketHandler</strong> 继承该类便可以选择性地实现感兴趣的方法。</p><p>编写 MyWebSocketHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebSocketHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractWebSocketHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//处理文本消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息&quot;</span> + message.getPayload());</span><br><span class="line">        <span class="comment">//模拟延时</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">//发送文本消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息：hello world!&quot;</span>);</span><br><span class="line">        session.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractWebSocketHandler 还定义了以下 3 个方法：</p><ul><li>**handleTextMessage()**：处理文本消息类型的方法。</li><li>handleBinaryMessage()：处理二进制消息类型的方法。</li><li>**handlePongMessage()**：处理Pong消息类型的方法。</li></ul><p>希望 WebSocketHandler 处理什么类型的消息就可以只重载对应的消息类型的方法，而不必重载所有方法。</p><p>通过上述代码，一个简单的消息处理类就完成了，需要在 Spring 上下文中增加相关的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--将helloHandler映射到&quot;/hello&quot;请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">handler</span>=<span class="string">&quot;helloHandler&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--声明MyWebSocketHandler Bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloHandler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.MyWebSocketHandler&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>以上是使用配置文件的形式。</p><p>还能通过编码的形式（但是推荐使用配置文件）装配 WebSocketHandler，编写 MyWebSoketConfig：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWebSoketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry webSocketHandlerRegistry)</span> &#123;</span><br><span class="line">        webSocketHandlerRegistry.addHandler(helloHandler(),<span class="string">&quot;/chapter17/hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyWebSocketHandler <span class="title function_">helloHandler</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyWebSocketHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要在 applicationContext.xml 中装配：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloHandler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.web.MyWebSoketConfig&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>服务器端搭建完毕，接下来便是客户端的实现了：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: LiSJ</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">4</span>/<span class="number">11</span></span><br><span class="line">  Time: <span class="number">14</span>:<span class="number">42</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;WebSocket测试&lt;/title&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        <span class="comment">/* url使用“ws://”前缀，表示这是一个WebSocket连接 */</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&#x27;ws://&#x27;</span> + window.location.host + <span class="string">&#x27;&lt;%=request.getContextPath()%&gt;/hello&#x27;</span>;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>(url);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* opopen事件对应于WebSocketHandler的afterConnectionEstablished()方法 */</span></span><br><span class="line">        sock.onopen = function () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;开启WebSocket连接&#x27;</span>);</span><br><span class="line">            sayHello();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* onmessage事件对应于WebSocketHandler的handleTextMessage()方法 */</span></span><br><span class="line">        sock.onmessage = function (e)&#123;</span><br><span class="line">            console.log(<span class="string">&#x27;接收消息：&#x27;</span>, e.data);</span><br><span class="line">            setTimeout(function ()&#123;sayHello()&#125;, <span class="number">2000</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* onclose事件对应于WebSocketHandler的afterConnectionClosed()方法 */</span></span><br><span class="line">        sock.onclose = function () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;关闭WebSocket连接&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        function <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;发送消息：hello world!&#x27;</span>);</span><br><span class="line">            sock.send(<span class="string">&#x27;hello world!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    hello world!</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在 onopen 事件中会调用 sayHello() 方法，在该 WebSocket 上发送“hello world!”消息，通过发送这个消息，这个双向通信即建立起来。服务器端的 MyWebSocketHandler 作为响应将“hello world!”发送回来，当客户端收到来自服务器端的消息后，onmessage 事件又会发送一个“hello world!”给服务器端，如此循环往复。</p><p>最终结果：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/WebSocket%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81.sob9gy5bdi8.webp" alt="WebSocket消息发送"></p><h4 id="7-2-WebSocket-的限制"><a href="#7-2-WebSocket-的限制" class="headerlink" title="7.2 WebSocket 的限制"></a>7.2 WebSocket 的限制</h4><p>不同的浏览器和应用服务器对 WebSocket 的支持程度不同。通过 SockJS，就可以模拟对 WebSocket 的支持，这样即使浏览器和服务器不支持 WebSocket，SockJS 也可以让它们支持 WebSocket。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列笔记所有代码地址：&lt;a class=&quot;link&quot;   href=&quot;https://github.com/lisj98/SpringMVCSource.git&quot; &gt;https://github.com/lisj98/SpringMVCSource.git&lt;i class</summary>
      
    
    
    
    <category term="SpringMVC" scheme="https://lisj98.github.io/categories/SpringMVC/"/>
    
    
  </entry>
  
  <entry>
    <title>精通SpringMVC(六)-文件上传</title>
    <link href="https://lisj98.github.io/2022/04/11/%E7%B2%BE%E9%80%9ASpringMVC-%E5%85%AD-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://lisj98.github.io/2022/04/11/%E7%B2%BE%E9%80%9ASpringMVC-%E5%85%AD-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2022-04-11T04:00:36.000Z</published>
    <updated>2022-09-08T14:38:31.044Z</updated>
    
    <content type="html"><![CDATA[<p>本系列笔记所有代码地址：<a class="link"   href="https://github.com/lisj98/SpringMVCSource.git" >https://github.com/lisj98/SpringMVCSource.git<i class="fas fa-external-link-alt"></i></a></p><p>Spring MVC 通过 <strong>MultipartResolver</strong> 为文件上传提供了支持。Spring 有一个现成的 MultipartResolver 实现类：<strong>CommonsMultipartResolver</strong>。</p><p>需要注意的是，<strong>在 Spring MVC 上下文中默认没有装配 MultipartResolver</strong>，因此默认情况下不能处理文件上传的工作，如果想使用文件上传的功能，则需要先在上下文中配置 MultipartResolver。</p><h4 id="6-1-配置-MultipartResolver"><a href="#6-1-配置-MultipartResolver" class="headerlink" title="6.1 配置 MultipartResolver"></a>6.1 配置 MultipartResolver</h4><p>下面使用 CommonsMultipartResolver 配置一个 MultipartResolver：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E9%85%8D%E7%BD%AECommonsMultipartResolver.1ip74fi2e82o.webp" alt="配置CommonsMultipartResolver"></p><p>defaultEncoding 必须和用户 JSP 的 pageEncoding 属性一致，以便正确读取表单的内容。</p><p>uploadTempDir 是文件上传过程中所使用的临时目录，文件上传完成后，临时目录中的临时文件会被自动清除。</p><p>为了让 CommonsMultipartResolver 正常工作，必须先将 <code>Jakarta Commons FileUpload</code> 及 <code>Jakarta Commons io</code> 的类包添加到类路径下。</p><h4 id="6-2-编写控制器和文件上传表单页面"><a href="#6-2-编写控制器和文件上传表单页面" class="headerlink" title="6.2 编写控制器和文件上传表单页面"></a>6.2 编写控制器和文件上传表单页面</h4><p>在 UserController 中添加一个用于处理用户头像上传的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;uploadPage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updatePage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;uploadPage&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateThumb</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name,</span></span><br><span class="line"><span class="params">                          <span class="meta">@RequestParam(&quot;file&quot;)</span>MultipartFile file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span>(!file.isEmpty())&#123;</span><br><span class="line">        file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;f:/temp/&quot;</span> + file.getOriginalFilename()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fail&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring MVC 会将上传文件绑定到 MultipartFile 对象中，MultipartFile 提供了获取上传文件内容、文件名等方法，通过其 transferTo() 方法还可将文件存储到硬件中，还包括如下方法：</p><ul><li>byte[] getBytes()：获取文件字节流数据。</li><li>String getContentType()：获取文件 MIME 类型，如 image&#x2F;pjpeg、text&#x2F;plain 等。</li><li>InputStream getInputStream()：获取文件流。</li><li>String getName()：获取表单中文件组件的名字。</li><li>String getOriginFilename()：获取上传文件的原名。</li><li>long getSize()：获取文件的字节大小，单位为 Byte。</li><li>boolean isEmpty()：判断是否有上传的文件。</li><li>void transferTo(File dest)：将上传文件保存到一个目标文件中。</li></ul><p>负责上传文件的表单和一般表单有一些区别，表单的编码类型必须是 multipart&#x2F;form-data 类型。</p><p>uploadPage.jsp 如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span>  uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;请上传用户头像&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;</span><br><span class="line">    请选择上传的头像文件</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;&lt;c:url value=&quot;</span>/user/upload.html<span class="string">&quot;/&gt;&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>上传页面：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E4%B8%8A%E4%BC%A0%E9%A1%B5%E9%9D%A2.1xgpfp5u2aao.webp" alt="上传页面"></p><p>上传成功，对应文件夹下已有文件：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F.4z9g1f88fh80.webp" alt="上传成功"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列笔记所有代码地址：&lt;a class=&quot;link&quot;   href=&quot;https://github.com/lisj98/SpringMVCSource.git&quot; &gt;https://github.com/lisj98/SpringMVCSource.git&lt;i class</summary>
      
    
    
    
    <category term="SpringMVC" scheme="https://lisj98.github.io/categories/SpringMVC/"/>
    
    
  </entry>
  
  <entry>
    <title>精通SpringMVC(五)-本地化解析</title>
    <link href="https://lisj98.github.io/2022/04/11/%E7%B2%BE%E9%80%9ASpringMVC-%E4%BA%94-%E6%9C%AC%E5%9C%B0%E5%8C%96%E8%A7%A3%E6%9E%90/"/>
    <id>https://lisj98.github.io/2022/04/11/%E7%B2%BE%E9%80%9ASpringMVC-%E4%BA%94-%E6%9C%AC%E5%9C%B0%E5%8C%96%E8%A7%A3%E6%9E%90/</id>
    <published>2022-04-11T03:15:11.000Z</published>
    <updated>2022-09-08T14:38:25.823Z</updated>
    
    <content type="html"><![CDATA[<p>本系列笔记所有代码地址：<a class="link"   href="https://github.com/lisj98/SpringMVCSource.git" >https://github.com/lisj98/SpringMVCSource.git<i class="fas fa-external-link-alt"></i></a></p><h4 id="5-1-本地化的概念"><a href="#5-1-本地化的概念" class="headerlink" title="5.1 本地化的概念"></a>5.1 本地化的概念</h4><p>一般情况下，Web 应用根据客户端浏览器的设置判断客户端的本地化类型，例如：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E8%AE%BE%E7%BD%AE%E8%AF%AD%E8%A8%80%E9%A6%96%E9%80%89%E9%A1%B9.3p1p68u0qbc0.webp" alt="设置语言首选项"></p><p>浏览器中设置的<strong>本地化类型</strong>会包含在 HTML 请求报文头中发送给 Web 服务器，确切来说是通过<strong>报文头的 Accept-Language 参数</strong>将“语言首选项”对话框中选择的语言发送到服务器，成为服务器判别客户端本地化类型的依据。</p><p>如果 Web 应用基于这种方式提供本地化页面，则用户只得通过改变浏览器的设置进行本地化类型的切换。也有一种其他的形式，比如浏览器右上角有一个转换语言的图标，这种语言切换功能不要求用户更改浏览器的设置，<strong>它们通过 Cookie、Session 或请求参数即可切换本地化类型</strong>，这种方式明显更为便利。</p><p><strong>在默认情况下，Spring MVC 根据 Accept-Language 参数判断客户端的本地化类型。</strong>此外，它还提供了多种指定客户端本地化类型的方式，如<strong>通过设置 Cookie、Session 指定</strong>。</p><p><strong>事实上，当收到请求时，Spring MVC 在上下文中寻找一个本地化解析器（LocaleResolver），找到后使用它获取请求所对应的本地化类型信息。</strong></p><p><strong>除此之外，Spring MVC 还允许装配一个动态更改本地化类型的拦截器，这样通过指定一个请求参数就可以控制单个请求的本地化类型。</strong></p><p>本地化解析器和拦截器都定义在 <code>org.springframework.web.servlet.i18n</code> 包中，用户可以在 DispatcherServlet 上下文中配置它们。</p><p>Spring 提供了以下 4 个本地化解析器：</p><ul><li><strong>AcceptHeaderLocaleResolver</strong>：根据 HTTP 报文头的 Accept-Language 参数确定本地化类型。如果没有显式化定义本地化解析器，则 Spring MVC 默认采用该解析器。</li><li><strong>CookieLocaleResolver</strong>：根据指定的 Cookie 值确定本地化类型。</li><li><strong>SessionLocaleResolver</strong>：根据 Session 中特定的属性值确定本地化类型。</li><li><strong>LocaleChangeInterceptor</strong>：从请求参数中获取本次请求对应的本地化类型。</li></ul><p>在 3.4 节的实例中，我们为表单校验错误信息提供了国家化支持，当表单数据校验存在错误时，Spring MVC 使用默认的 AcceptHeaderLocaleResolver 抽取请求报文头的 Accept-Language 属性以确定客户端本地化类型，并返回对应的本地化错误信息。</p><h4 id="5-2-使用-CookieLocaleResolver"><a href="#5-2-使用-CookieLocaleResolver" class="headerlink" title="5.2 使用 CookieLocaleResolver"></a>5.2 使用 CookieLocaleResolver</h4><p>要使用 Cookie 保存本地化类型信息，只需在 Spring MVC 上下文中配置一个 CookieLocaleResolver 就可以了，DispatcherServlet 会自动识别本地化解析器并装配它。</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/CookieLocaleResolver%E9%85%8D%E7%BD%AE.1k24u9zbr0ow.webp" alt="CookieLocaleResolver配置"></p><h4 id="5-3-使用-SessionLocaleResolver"><a href="#5-3-使用-SessionLocaleResolver" class="headerlink" title="5.3 使用 SessionLocaleResolver"></a>5.3 使用 SessionLocaleResolver</h4><p>SessionLocaleResolver 查找 Session 中属性名为 <strong>SessionLocaleResolver.LOCALE.SESSION_ATTRIBUTE_NAME</strong> 的属性，并将其转换为 Locale 对象，以此作为客户端的本地化类型。</p><p>配置过程如 CookieLocaleResolver 一样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localeResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.i18n.SessionLocaleResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>SessionLocaleResolver 和 CookieLocaleResolver 的区别是，前者一般要求用户登录后产生相应的用户会话才有效，而后者只要浏览器有 Cookie 存在即可生效。</p><h4 id="5-4-使用-LocaleChangeInterceptor"><a href="#5-4-使用-LocaleChangeInterceptor" class="headerlink" title="5.4 使用 LocaleChangeInterceptor"></a>5.4 使用 LocaleChangeInterceptor</h4><p>很多国际化网站都允许通过一个请求参数控制网站的本地化，如 <a class="link"   href="http://www.xxx.com/?locale=zh_CN" >www.xxx.com?locale=zh_CN<i class="fas fa-external-link-alt"></i></a> 返回对应中国大陆的本地化网页，而 <a class="link"   href="http://www.xxx.com/?locale=en_US" >www.xxx.com?locale=en_US<i class="fas fa-external-link-alt"></i></a> 返回本地化为英语的网页。这样，网页使用者可以通过对 URL 的控制返回不同本地化的页面。</p><p>在 Spring MVC 中，可以通过 LocaleChangeInterceptor 过滤器来完成这一需求。</p><p>在 Spring MVC 上下文中通过 <strong>&lt;mvc:interceptors&gt;</strong> 配置过滤器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localeResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:cookieName</span>=<span class="string">&quot;clientLanguage&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:cookieMaxAge</span>=<span class="string">&quot;100000&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:cookiePath</span>=<span class="string">&quot;/&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:defaultLocale</span>=<span class="string">&quot;zh_CN&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>LocaleChangeInterceptor 的角色类似于 ContentNegotiatingViewResolver，相当于一个中介。</strong></p><p>LocaleChangeInterceptor 在默认情况下通过 locale 请求参数获取本次请求对应的本地化类型，用户可以通过其 paramName 属性指定一个其他参数名。由于 LocaleChangeInterceptor 的主要任务是从请求中获取本地化类型并将其设置给真正的本地化解析器，所以在配置 LocaleChangeInterceptor 之前，必须在上下文中先配置一个本地化解析器，如 AcceptHeaderLocaleResolver、CookieLocaleResolver、SessionLocaleResolver 等。</p><p>值得注意的是，由于 AcceptHeaderLocaleResolver 是从请求报文头中获取本地化信息的，因此不能被动态更改，<strong>如果配置了 LocaleChangeInterceptor，则只能选择 CookieLocaleResolver 或 SessionLocaleResolver</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列笔记所有代码地址：&lt;a class=&quot;link&quot;   href=&quot;https://github.com/lisj98/SpringMVCSource.git&quot; &gt;https://github.com/lisj98/SpringMVCSource.git&lt;i class</summary>
      
    
    
    
    <category term="SpringMVC" scheme="https://lisj98.github.io/categories/SpringMVC/"/>
    
    
  </entry>
  
  <entry>
    <title>精通SpringMVC(四)-视图和视图解析器</title>
    <link href="https://lisj98.github.io/2022/04/09/%E7%B2%BE%E9%80%9ASpringMVC-%E5%9B%9B-%E8%A7%86%E5%9B%BE%E5%92%8C%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    <id>https://lisj98.github.io/2022/04/09/%E7%B2%BE%E9%80%9ASpringMVC-%E5%9B%9B-%E8%A7%86%E5%9B%BE%E5%92%8C%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8/</id>
    <published>2022-04-09T04:40:56.000Z</published>
    <updated>2022-09-08T14:38:37.395Z</updated>
    
    <content type="html"><![CDATA[<p>请求处理方法执行完成后，最终返回一个 ModelAndView 对象。对于那些返回 String、View 或 ModelMap 等类型的处理方法，Spring MVC 也会在内部将它们装配成一个 ModelAndView 对象，该对象包含了视图逻辑名和模型对象的信息。</p><p>Spring MVC 借助视图解析器（ViewResolver）得到最终的视图对象（View）。</p><p>对于最终究竟采取何种视图对象对模型数据进行渲染，处理器并不关心，处理器的工作重点聚焦在生产模型数据的工作上。</p><h4 id="4-1-认识视图"><a href="#4-1-认识视图" class="headerlink" title="4.1 认识视图"></a>4.1 认识视图</h4><p>视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户。视图对象可以是多种形式，如 JSP、PDF 等，Spring 在 <code>org.springframework.web.servlet</code> 包中定义了一个高度抽象的 View 接口，其中包含了两个方法：</p><ul><li>String getContentType()：获取视图对应的 MIME 类型，如 text&#x2F;html，application&#x2F;xml 等。</li><li>void render(Map model, HttpServletRequest request, HttpServletResponse response)：将模型数据以某种 MIME 类型渲染出来。</li></ul><p>视图对象是一个 Bean，视图对象由视图解析器负责实例化。</p><p>不同类型的视图实现技术对应不同的 View 实现类。常见的有如下几种：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%86%E5%9B%BE%E5%AE%9E%E7%8E%B0%E7%B1%BB.4wlxocnzqmm0.webp" alt="不同的视图实现类"></p><h4 id="4-2-认识视图解析器"><a href="#4-2-认识视图解析器" class="headerlink" title="4.2 认识视图解析器"></a>4.2 认识视图解析器</h4><p>Spring MVC 为逻辑视图名的解析提供了不同的策略，可以在 Spring Web 上下文中配置一种或多种解析策略，并指定它们之间的先后顺序。每种解析策略对应一个具体的视图解析器实现类。视图解析器的工作比较单一，即将逻辑视图名解析为一个具体的视图对象。所有的视图解析器都实现了 ViewResolver 接口，该接口仅有一个方法：</p><ul><li>View resolveViewName(String viewName, Locale locale)</li></ul><p>该方法的签名（入参）清楚地展示了视图解析器的工作原理，根据逻辑视图名和本地化对象得到一个视图对象。</p><p>Spring 拥有众多的视图解析器实现类，如：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB.40vcxglbwfm0.webp" alt="视图解析器实现类"></p><p>使用时可以选择单一视图解析器也可以混用多种视图解析器，每个视图解析器都实现了 Ordered 接口并开放出一个 orderNo 属性，可以通过该属性指定视图解析器的优先顺序，值越小优先级越高，值越大优先级越低。有些视图解析器默认为最高优先级（如 ContentNegotiatingViewResolver），而有些则默认为最低优先级（如 InternalResourceViewResolver、XstlViewResolver等）。</p><p>Spring MVC 会根据视图解析器的优先级顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则将抛出异常。</p><h4 id="4-3-JSP-和-JSTL"><a href="#4-3-JSP-和-JSTL" class="headerlink" title="4.3 JSP 和 JSTL"></a>4.3 JSP 和 JSTL</h4><h5 id="1-使用-InternalResourceViewResolver"><a href="#1-使用-InternalResourceViewResolver" class="headerlink" title="1. 使用 InternalResourceViewResolver"></a>1. 使用 InternalResourceViewResolver</h5><p>使用 InternalResourceViewResolver 作为视图解析器的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:prefix</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:suffix</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>控制器中的相关方法处理完成后返回一个 String 类型的逻辑视图名，InternalResourceViewResolver 对逻辑视图名进行解析，便得到相应的视图对象如 xxx.jsp 等。</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E9%80%BB%E8%BE%91%E8%A7%86%E5%9B%BE%E5%90%8D%E8%A7%A3%E6%9E%90%E4%B8%BAuri%E8%B5%84%E6%BA%90.2mg2rhsyrpq0.webp" alt="逻辑视图名解析为uri资源"></p><p>如果 JSP 使用了 JSTL 的国际化功能，确切地说，当 JSP 页面使用 JSTL 的 &lt;fmt:message&#x2F;&gt; 标签时，用户就需要使用 JstlView 替换默认的视图实现类，注意视图解析器和视图对象类不是一回事，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:viewClass</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:prefix</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:suffix</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>举一个例子演示使用 JSTL 的 &lt;fmt:message&#x2F;&gt; 标签让 JSP 页面实现本地化输出，首先编写 UserController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/showUserList&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showUserList</span><span class="params">(ModelMap mm)</span>&#123;</span><br><span class="line">        <span class="type">GregorianCalendar</span> <span class="variable">calendar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line">        ArrayList&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setUserName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        user1.setRealName(<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        calendar.set(<span class="number">2022</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line">        user1.setBirthday(calendar.getTime());</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setUserName(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">        user2.setRealName(<span class="string">&quot;约翰&quot;</span>);</span><br><span class="line">        user1.setBirthday(calendar.getTime());</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        mm.addAttribute(<span class="string">&quot;userList&quot;</span>, userList);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user/userList&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再编写 userList.jsp：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span>%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;fmt&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/fmt&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;&lt;fmt:message key=<span class="string">&quot;website.title&quot;</span>/&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;fmt:message  key=<span class="string">&quot;user.userList.title&quot;</span>/&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;userList&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;user&quot;</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;&lt;c:url value=&quot;</span>/user/showUser/$&#123;user.userName&#125;.html<span class="string">&quot;/&gt;&quot;</span>&gt;</span><br><span class="line">$&#123;user.userName&#125;</span><br><span class="line">                        &lt;/a&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line">&lt;td&gt;</span><br><span class="line">$&#123;user.realName&#125;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line">&lt;td&gt;</span><br><span class="line">&lt;fmt:formatDate value=<span class="string">&quot;$&#123;topic.createDate&#125;&quot;</span> pattern=<span class="string">&quot;yyyy-MM-dd&quot;</span> /&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>userList.jsp 所使用的国际化资源在 content 资源文件中定义。</p><p>content.properties 配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">website.title</span>=<span class="string">smart</span></span><br><span class="line"><span class="attr">user.userList.title</span>=<span class="string">user list</span></span><br></pre></td></tr></table></figure><p>对应于 JSP 页面中的 key&#x3D;”website.title” 与 key&#x3D;”user.userList.title”，相应的 value 就是 smart 与 userList，采用的是一种键值对的形式，这样不同国家地区的用户在使用这一 JSP 页面时就不必频繁地更改页面了而是只用修改对应地国际化资源文件 content.properties 与 content_zh_CN.properties，国际化资源文件会根据键填充相应的值。</p><p>更改 smart-servlet.xml 中 ResourceBundleMessageSource 的配置，添加此国际化资源：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageRecouce&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basenames&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>i18n/messages<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>i18n/content<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，userList.jsp 就会根据 i18n&#x2F;content 来寻找 content.properties 与 content_zh_CN.properties 文件，就可以根据客户端的不同显示相应的本地化页面，除了可以使用 JSTL 的标签外，还能使用 Spring 提供的表单标签。</p><h5 id="2-使用表单标签"><a href="#2-使用表单标签" class="headerlink" title="2. 使用表单标签"></a>2. 使用表单标签</h5><p>通过 Spring 表单标签，可以很容易地将模型数据中地表单&#x2F;命令对象（实体类对象）绑定到 HTML 表单元素中。</p><p>和使用任何 JSP 扩展标签一样，在使用 Spring 表单标签之前，必须在 JSP 页面中添加一行引用 Spring 表单标签的声明：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%--引用表单标签的声明，声明后就可以使用了--%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class="string">&quot;c&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;form&quot;</span> uri=<span class="string">&quot;http://www.springframework.org/tags/form&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><p>下面是一个使用 &lt;form:form&gt; 表单标签的实例，它将最终生成一个 HTML 的 form 表单：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form:form modelAttribute=<span class="string">&quot;user&quot;</span>&gt;</span><br><span class="line">用户名：&lt;form:input path=<span class="string">&quot;userName&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">密码：&lt;form:input path=<span class="string">&quot;password&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">真实姓名：&lt;form:input path=<span class="string">&quot;realName&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;注册&quot;</span> name=<span class="string">&quot;testSubmit&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;reset&quot;</span> value=<span class="string">&quot;重置&quot;</span>&gt;</span><br><span class="line">&lt;/form:form&gt;</span><br></pre></td></tr></table></figure><p>一般情况下，通过 GET 请求获取表单页面，通过 POST 请求提交表单页面。</p><p>可以通过 modelAttribute 指定绑定的模型属性。如果 modelAttribute 不指定，那么默认从模型中尝试获取名为 command 的表单对象，如果 command 也不存在的话，则将发生错误。通过 action 指定处理表单提交的 URL 地址。此外， &lt;form:form&gt; 标签还拥有多种属性，此处不一一列举。</p><p>Spring 提供了十多个表单组件标签，用以绑定表单对象的属性值，这些标签大都拥有如下属性：</p><ul><li>path：用属性路径表示的表单对象属性。如 userName、dept.deptName、dept.address.tel等。</li><li>htmlEscape：表示绑定的表单属性值是否要对 HTML 特殊字符进行转换，默认值为 true。</li><li>cssClass：表单组件对应的 CSS 样式类名。</li><li>cssErrorClass：当表单组件的数据存在相应的错误时（提交表单后由服务器产生）采用的 CSS 样式类。</li></ul><p>常见表单标签如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/Spring%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE1.7kxfz79o2cw0.webp" alt="Spring表单标签1"></p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/Spring%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE2.nkrxn2xxfow.webp" alt="Spring表单标签2"></p><h5 id="3-关于复选框、单选框、下拉框和表单对象属性的映射问题"><a href="#3-关于复选框、单选框、下拉框和表单对象属性的映射问题" class="headerlink" title="3. 关于复选框、单选框、下拉框和表单对象属性的映射问题"></a>3. 关于复选框、单选框、下拉框和表单对象属性的映射问题</h5><p>对于以下复选框标签：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form:checkboxes path=<span class="string">&quot;preferences.interests&quot;</span> items=<span class="string">&quot;$&#123;interests&#125;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>其生成的对应 HTML 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;favorites1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;favorites&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;favorites2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;favorites&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;favorites3&quot;</span> <span class="attr">name</span>=<span class="string">&quot;favorites&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;favorites4&quot;</span> <span class="attr">name</span>=<span class="string">&quot;favorites&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;_favorites&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为什么 HTML 后面多了一个 hidden 组件呢？因为当 HTML 页面中的所有复选框都没有勾选时，表单提交所对应的 HTTP 请求报文不会包含这个复选框的参数名，这样就给 Spring 的表单绑定机制带来了麻烦。解决方法就是在每个复选框后添加一个隐藏组件，并且在对应的复选框名字前添加一个下划线作为隐藏组件的名字，这样一来，就相当于告诉 Spring MVC ：在这个表单中存在这个复选框，Spring MVC 可以据此保证表单对象和页面表单组件数据的一致性。编写 HTML 页面时应当注意这一点。</p><p>复选框、单选框及下拉框都有这个问题。</p><h4 id="4-4-模板视图"><a href="#4-4-模板视图" class="headerlink" title="4.4 模板视图"></a>4.4 模板视图</h4><p>FreeMarker 和 Velocity 是除 JSP 外被使用最多的页面模板技术。页面模板编写好页面结构，模板页面中使用一些特殊的变量标识符绑定 Java 对象的动态数据。</p><p>虽然 FreeMarker 具有一些编程能力，但通常由 Java 程序准备模型数据，FreeMarker 仅负责基于模板对模型数据进行渲染。</p><h5 id="1-编写一个-FreeMarker-模板"><a href="#1-编写一个-FreeMarker-模板" class="headerlink" title="1. 编写一个 FreeMarker 模板"></a>1. 编写一个 FreeMarker 模板</h5><p>重新编写 userList.jsp，并把它放在&#x2F;WEB-INF&#x2F;ftl 目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;smart&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">用户列表</span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;%-- #list 用于对模型数据中的userList属性对象进行迭代 --%&gt;</span><br><span class="line">    &lt;#list userList as user&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">            &lt;%-- 显示模型属性对象中的值 --%&gt;</span><br><span class="line">                &lt;a href=&quot;/user/showUser/$&#123;user.userName&#125;.html&#x27;/&gt;$&#123;user.userName&#125;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;user.realName&#125;&lt;/td&gt;</span><br><span class="line">            &lt;%-- 格式化日期 --%&gt;</span><br><span class="line">            &lt;td&gt; $&#123;user.birthday?string(&quot;yyyy-MM-dd&quot;)&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在 UserController 中添加一个处理方法，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showUserListByFtl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showUserListByFtl</span><span class="params">(ModelMap mm)</span>&#123;</span><br><span class="line">    ArrayList&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">    <span class="comment">//以userList为属性名，将User列表添加到模型数据中</span></span><br><span class="line">    mm.addAttribute(<span class="string">&quot;userList&quot;</span>, userList);</span><br><span class="line">    <span class="comment">//逻辑视图名为userListFtl</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;userListFtl&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就需要在 Spring 上下文中装配好 FreeMarker 的工作环境及 FreeMarker 视图解析器了：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E8%A3%85%E9%85%8DFreeMarker%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8.60k3mictbwc0.webp" alt="装配FreeMarker基础设施和解析器"></p><h5 id="3-使用-Spring-为-FreeMaker-提供的宏"><a href="#3-使用-Spring-为-FreeMaker-提供的宏" class="headerlink" title="3. 使用 Spring 为 FreeMaker 提供的宏"></a>3. 使用 Spring 为 FreeMaker 提供的宏</h5><p>考虑以下如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/user/showUser/$&#123;user.userName&#125;.html&quot;</span>&gt;</span>$&#123;user.userName&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里使用的 URL 地址没有指定部署路径，如果部署路径不是 “&#x2F;”，则将发生错误。由于应用部署路径通常在最终部署时才能确定，因此不能直接通过硬编码的方式指定。在 JSP 中，通常使用 &lt;c:url&gt; 将 URL 转换为包含应用部署路径的绝对 URL。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;c:url value=&quot;</span>/<span class="attr">user</span>/<span class="attr">showUser</span>/$&#123;<span class="attr">user.userName</span>&#125;<span class="attr">.html</span>&quot;/&gt;</span>&quot;&gt;$&#123;topic.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 FreeMaker 中，一般使用 Spring 的 FreeMaker 宏完成这一功能。此外，Spring 的 FreeMaker 宏还提供了本地化信息显示功能。</p><p>使用 Spring 的 FreeMaker 宏：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/%E4%BD%BF%E7%94%A8Spring%E7%9A%84%E5%AE%8F.h3ezhdz1ir4.webp" alt="使用Spring的宏"></p><p>Spring 为 FreeMaker 提供的宏有如下几种：</p><p><img src="https://cdn.jsdelivr.net/gh/lisj98/image-hosting@master/SpringMVC/Spring-%E4%B8%BA-FreeMaker-%E6%8F%90%E4%BE%9B%E7%9A%84%E5%AE%8F.6fhimc7jtjw0.webp" alt="Spring-为-FreeMaker-提供的宏"></p><h4 id="4-5-Excel"><a href="#4-5-Excel" class="headerlink" title="4.5 Excel"></a>4.5 Excel</h4><p>如果希望使用 Excel 展示用户列表，则仅需扩展 Spring 的 AbstractExcelView 或者 AbstractJExcelView 即可。实现 buildExcelDocument() 方法，在方法中使用模型数据对象即可构造 Excel 文档。</p><p>下面通过扩展 AbstractExcelView 定义显示用户列表的 Excel 视图类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserListExcelView</span> <span class="keyword">extends</span> <span class="title class_">AbstractExcelView</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildExcelDocument</span><span class="params">(Map&lt;String, Object&gt; model, org.apache.poi.hssf.usermodel.HSSFWorkbook workbook, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;inline;filename=&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;用户列表&quot;</span>.getBytes(), <span class="string">&quot;iso-8859-1&quot;</span>));</span><br><span class="line">        List&lt;User&gt; userList = (List&lt;User&gt;) model.get(<span class="string">&quot;userList&quot;</span>);</span><br><span class="line">        <span class="type">HSSFSheet</span> <span class="variable">sheet</span> <span class="operator">=</span> workbook.createSheet(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        <span class="type">HSSFRow</span> <span class="variable">header</span> <span class="operator">=</span> sheet.createRow(<span class="number">0</span>);</span><br><span class="line">        header.createCell(<span class="number">0</span>).setCellValue(<span class="string">&quot;账号&quot;</span>);</span><br><span class="line">        header.createCell(<span class="number">1</span>).setCellValue(<span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">        header.createCell(<span class="number">2</span>).setCellValue(<span class="string">&quot;生日&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rowNum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            <span class="type">HSSFRow</span> <span class="variable">row</span> <span class="operator">=</span> sheet.createRow(rowNum++);</span><br><span class="line">            row.createCell(<span class="number">0</span>).setCellValue(user.getUserName());</span><br><span class="line">            row.createCell(<span class="number">1</span>).setCellValue(user.getRealName());</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">createDate</span> <span class="operator">=</span> sdf.format(user.getBirthday());</span><br><span class="line">            row.createCell(<span class="number">2</span>).setCellValue(createDate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>response.setHeader(&quot;Content-Disposition&quot;, &quot;inline;filename=&quot; + new String(&quot;用户列表&quot;.getBytes(), &quot;iso-8859-1&quot;));</code> 处代码让浏览器直接在页面中显示 Excel 文件，而非显示一个对话框提示用户下载或打开文件。如果希望显示一个对话框提示用户下载或打开文件，则可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attchment;filename=&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;用户列表&quot;</span>.getBytes(), <span class="string">&quot;iso-8859-1&quot;</span>));</span><br></pre></td></tr></table></figure><p>编写好 Excel 视图类后，必须在 smart-servlet.xml 中进行相应的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:order</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userListExcel&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.controller.UserListExcelView&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>由于 UserListExcelView 代表的 Excel 视图对象是一个 Bean，因此我们使用 BeanNameViewResolver 作为视图解析器。</p><p>在 UserController 中添加一个相应的请求处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showUserListByXls&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showUserListByXls</span><span class="params">(ModelMap mm)</span>&#123;</span><br><span class="line">    <span class="type">GregorianCalendar</span> <span class="variable">calendar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line">    ArrayList&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user1.setUserName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    user1.setRealName(<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">    calendar.set(<span class="number">2022</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line">    user1.setBirthday(calendar.getTime());</span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user2.setUserName(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">    user2.setRealName(<span class="string">&quot;约翰&quot;</span>);</span><br><span class="line">    user1.setBirthday(calendar.getTime());</span><br><span class="line">    userList.add(user1);</span><br><span class="line">    userList.add(user2);</span><br><span class="line">    mm.addAttribute(<span class="string">&quot;userList&quot;</span>, userList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;userListExcel&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器输入 <code>http://localhost:8080/springmvc4/user/showUserListByXls.html</code> 根据浏览器的不同，将显示或下载一个 Excel 文件。</p><h4 id="4-6-PDF"><a href="#4-6-PDF" class="headerlink" title="4.6 PDF"></a>4.6 PDF</h4><p>PDF 视图和 Excel 类似，也使用一个 Bean 作为视图对象。</p><p>先编写 PDF 视图类，PDF 视图类需继承 AbstractPdfView：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserListPdfView</span> <span class="keyword">extends</span> <span class="title class_">AbstractPdfView</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildPdfDocument</span><span class="params">(Map&lt;String, Object&gt; model,</span></span><br><span class="line"><span class="params">Document document, PdfWriter writer, HttpServletRequest request,</span></span><br><span class="line"><span class="params">HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;inline; filename=&quot;</span>+ </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;用户列表&quot;</span>.getBytes(), <span class="string">&quot;iso8859-1&quot;</span>));  </span><br><span class="line">List&lt;User&gt; userList = (List&lt;User&gt;) model.get(<span class="string">&quot;userList&quot;</span>);</span><br><span class="line"><span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>(<span class="number">3</span>);</span><br><span class="line">table.setWidth(<span class="number">80</span>);</span><br><span class="line">table.setBorder(<span class="number">1</span>);</span><br><span class="line">table.getDefaultCell().setHorizontalAlignment(Element.ALIGN_CENTER);</span><br><span class="line">table.getDefaultCell().setVerticalAlignment(Element.ALIGN_MIDDLE);</span><br><span class="line"></span><br><span class="line"><span class="type">BaseFont</span> <span class="variable">cnBaseFont</span> <span class="operator">=</span> BaseFont.createFont(<span class="string">&quot;STSongStd-Light&quot;</span>, <span class="string">&quot;UniGB-UCS2-H&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">Font</span> <span class="variable">cnFont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Font</span>(cnBaseFont, <span class="number">10</span>, Font.NORMAL, Color.BLUE);</span><br><span class="line"></span><br><span class="line">table.addCell(buildFontCell(<span class="string">&quot;帐号&quot;</span>,cnFont));</span><br><span class="line">table.addCell(buildFontCell(<span class="string">&quot;姓名&quot;</span>,cnFont));</span><br><span class="line">table.addCell(buildFontCell(<span class="string">&quot;生日&quot;</span>,cnFont));</span><br><span class="line"><span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">table.addCell( user.getUserName());</span><br><span class="line">table.addCell(buildFontCell(user.getRealName(),cnFont));</span><br><span class="line"><span class="type">String</span> <span class="variable">createDate</span> <span class="operator">=</span> DateFormatUtils.format(user.getBirthday(),</span><br><span class="line"><span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">table.addCell(createDate);</span><br><span class="line">&#125;</span><br><span class="line">document.add(table);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Cell <span class="title function_">buildFontCell</span><span class="params">(String content,Font font)</span> <span class="keyword">throws</span> RuntimeException&#123; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="type">Phrase</span> <span class="variable">phrase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phrase</span>(content, font);</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(phrase);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserListPdfView 和 UserListExcelView 视图一样，可以采用 BeanNameViewResolver 作为视图解析器，在 smart-servlet.xml 中添加视图 Bean 声明即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userListPdf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.controller.UserListPdfView&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>同样，在 UserController 中添加一个 showUserListInPdf() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showUserListByPdf&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showUserListByPdf</span><span class="params">(ModelMap mm)</span>&#123;</span><br><span class="line">        <span class="type">GregorianCalendar</span> <span class="variable">calendar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line">        ArrayList&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setUserName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        user1.setRealName(<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        calendar.set(<span class="number">2022</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line">        user1.setBirthday(calendar.getTime());</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setUserName(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">        user2.setRealName(<span class="string">&quot;约翰&quot;</span>);</span><br><span class="line">        user1.setBirthday(calendar.getTime());</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        mm.addAttribute(<span class="string">&quot;userList&quot;</span>, userList);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userListPdf&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在浏览器输入 <code>http://localhost:8080/springmvc4/user/showUserListByPdf.html</code> 根据浏览器的不同，将显示或下载一个 PDF 文件。</p><h4 id="4-7-输出-XML"><a href="#4-7-输出-XML" class="headerlink" title="4.7 输出 XML"></a>4.7 输出 XML</h4><p>Spring MVC 还可以将模型中的数据以 XML 的形式输出，其对应的视图对象为 MashallingView。</p><p>在 smart-servlet.xml 中添加 MashallingView 的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userListXml&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.xml.MarshallingView&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:modelKey</span>=<span class="string">&quot;userList&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:marshaller-ref</span>=<span class="string">&quot;xmlMarshaller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;xmlMarshaller&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.oxm.xstream.XStreamMarshaller&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;streamDriver&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.thoughtworks.xstream.io.xml.StaxDriver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;annotatedClasses&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.smart.domain.User<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MarshallingView 使用 Marshaller 将模型数据转换为 XML，通过 marshaller 属性注入一个 Marshaller 实例。在默认情况下，MarshallingView 会将模型中的所有属性都转换为 XML。由于模型属性包含很多隐式数据，直接将模型中的所有数据全部输出往往并不是我们所期望的。MarshallingView 允许通过 modelKey 指定模型中的哪个属性需要输出为 XML。</p><p>在 UserController 中添加一个方法，返回 userListXml 逻辑视图名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showUserListByXml&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showUserListByXml</span><span class="params">(ModelMap mm)</span>&#123;</span><br><span class="line">        <span class="type">GregorianCalendar</span> <span class="variable">calendar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line">        ArrayList&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setUserName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        user1.setRealName(<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        calendar.set(<span class="number">2022</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line">        user1.setBirthday(calendar.getTime());</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setUserName(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">        user2.setRealName(<span class="string">&quot;约翰&quot;</span>);</span><br><span class="line">        user1.setBirthday(calendar.getTime());</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        mm.addAttribute(<span class="string">&quot;userList&quot;</span>, userList);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userListXml&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在浏览器输入 <code>http://localhost:8080/springmvc4/user/showUserListByXml.html</code> 将返回 XML 内容的响应。</p><h4 id="4-8-输出-JSON"><a href="#4-8-输出-JSON" class="headerlink" title="4.8 输出 JSON"></a>4.8 输出 JSON</h4><p>Spring MVC 的 MappingJackson2JsonView 借助 Jackson 框架的 ObjectMapper 将模型数据转换为 JSON 格式输出。由于 MappingJackson2JsonView 也是一个 Bean，因此可以通过 BeanNameViewResolver 进行解析，因此仅需在 smart-servlet.xml 中配置即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userListJson&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:modelKeys</span>=<span class="string">&quot;userList&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>默认情况下，MappingJackson2JsonView 会将模型中的所有数据全部输出为 JSON，这显然是不合理的，可以通过 modelKeys 属性指定模型中的哪些属性需要输出。</p><p>在 UserController 中添加一个方法，返回 userListJson 逻辑视图名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showUserListByJson&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showUserListByJson</span><span class="params">(ModelMap mm)</span>&#123;</span><br><span class="line">        <span class="type">GregorianCalendar</span> <span class="variable">calendar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line">        ArrayList&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setUserName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        user1.setRealName(<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        calendar.set(<span class="number">2022</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line">        user1.setBirthday(calendar.getTime());</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setUserName(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">        user2.setRealName(<span class="string">&quot;约翰&quot;</span>);</span><br><span class="line">        user1.setBirthday(calendar.getTime());</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        mm.addAttribute(<span class="string">&quot;userList&quot;</span>, userList);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userListJson&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在浏览器输入 <code>http://localhost:8080/springmvc4/user/showUserListByJson.html</code> 将以 JOSN 格式输出模型中名为 userList 的属性对象。</p><h4 id="4-9-使用-XmlViewResolver"><a href="#4-9-使用-XmlViewResolver" class="headerlink" title="4.9 使用 XmlViewResolver"></a>4.9 使用 XmlViewResolver</h4><p>XmlViewResolver 和 BeanNameViewResolver 功能相似，唯一不同的是它可以将视图 Bean 定义在一个独立的 XML 文件中，而不是将所有视图 Bean 都定义在 smart-servlet.xml 中。</p><p>要使用 XmlViewResolver，必须在 smart-servlet.xml 中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.XmlViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:order</span>=<span class="string">&quot;20&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:location</span>=<span class="string">&quot;WEB-INF/views/smart-views.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>默认情况下，XmlViewResolver 在 WEB-INF&#x2F;views.xml 中查找视图 Bean 的定义，我们将视图 Bean 定义在 WEB-INF&#x2F;views&#x2F;smart-views.xml 中，所以需要通过 location 显示指定。</p><p>定义 smart-views.xml 文件，和普通的 Spring 配置文件没有任何区别：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span> <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.smart.*&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userListJson1&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:modelKeys</span>=<span class="string">&quot;userList&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userListExcel1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.controller.UserListExcelView&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过在 smart-views.xml 文件中定义的 Bean 不能被 Spring Web 上下文的其他 Bean 引用，它是被 XmlViewResolver 独享的。</p><h4 id="4-10-使用-ResourceBundleViewResolver"><a href="#4-10-使用-ResourceBundleViewResolver" class="headerlink" title="4.10 使用 ResourceBundleViewResolver"></a>4.10 使用 ResourceBundleViewResolver</h4><p>对于同一个逻辑视图名，如果希望为不同地区的用户提供不同类型的视图，则应该考虑使用 ResourceBundleViewResolver。和 XmlViewResolver 将视图定义在 XML 文件中不同，ResourceBundleViewResolver 通过一个国家化资源文件定义视图对象。</p><p>假如有个需求，对同一个页面的展现方式，一个人要求用 HTML 展现，另一个人要求用 PDF 展现，这个时候就可以通过 ResourceBundleViewResolver 来实现。</p><p>在 smart-servlet.xml 中添加代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.ResourceBundleViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:order</span>=<span class="string">&quot;30&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:basenames</span>=<span class="string">&quot;i18n/views&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>通过 basenames 属性指定视图国际化资源文件的基名，对应于中国大陆的视图资源文件为 views_zh_CN.properties，内容为：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userListi18n.(class)</span>=<span class="string">org.springframework.web.servlet.view.JstlView</span></span><br><span class="line"><span class="attr">userListi18n.url</span>=<span class="string">/WEB-INF/views/user/userList.jsp</span></span><br></pre></td></tr></table></figure><p>其中通过 &lt;逻辑视图名&gt;.(class) 属性设置试图实现类。</p><p>通过 &lt;逻辑视图名&gt;.url 设置 URL 资源。</p><p>对应的 views_en_US.properties 内容为：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userListi18n.(class)</span>=<span class="string">com.smart.web.UserListPdfView</span></span><br></pre></td></tr></table></figure><p>ResourceBundleViewResolver 视图解析器会根据具体的用户请求调用不同的 properties。</p><p>在一个视图国际化资源中也可以定义多个视图对象：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个视图</span></span><br><span class="line"><span class="attr">welcomeView.(class)</span>=<span class="string">org.springframework.web.servlet.view.JstlView</span></span><br><span class="line"><span class="attr">welcomeView.url</span>=<span class="string">/WEB-INF/jsp/welcome.jsp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 第二个视图</span></span><br><span class="line"><span class="attr">vetsView.(class)</span>=<span class="string">org.springframework.web.servlet.view.JstlView</span></span><br><span class="line"><span class="attr">vetsView.url</span>=<span class="string">/WEB-INF/jsp/vets.jsp</span></span><br><span class="line"><span class="attr">...</span></span><br></pre></td></tr></table></figure><h4 id="4-11-混合使用多种视图技术"><a href="#4-11-混合使用多种视图技术" class="headerlink" title="4.11 混合使用多种视图技术"></a>4.11 混合使用多种视图技术</h4><h5 id="1-ContentNegotiatingViewResolver"><a href="#1-ContentNegotiatingViewResolver" class="headerlink" title="1. ContentNegotiatingViewResolver"></a>1. ContentNegotiatingViewResolver</h5><p>先前介绍过使用了 HttpMessageConverter 对标注了 @ResponseBody 或返回值为 ResponseEntity 的处理器方法进行响应信息转换的内容。Spring MVC 可以根据请求报文头的 Accept 属性选择合适的 HttpMessageConverter 将处理方法的返回值以 XML、JSON 等不同形式输出响应。也就是说，调用者可以通过设置请求报文头的 Accept 值控制服务器端返回的数据格式，从而实现对同一资源采用相同 URL 的 REST 编程风格。</p><p>但是基于 HttpMessageConverter 的实现方式存在以下限制：</p><ul><li>只能通过请求报文头的 Accept 值控制服务器端返回的数据格式。如果客户端是浏览器，那么很难控制 Accept 报文头的值，一般情况下，该值是由浏览器自己决定的。</li><li>无法通过 URL 扩展名或请求参数控制服务器端的资源输出形式，因此无法将其对应一个 URL 发布出去。</li><li>如果希望使用 XML、JSON、一个网页等形式输出资源，则 HttpMessageConverter 很难达到要求。因为 HttpMessageConverter 很难调用一个视图对象渲染模型，它直接负责将资源输出为某一内容形式。</li></ul><p>所以，如果希望将资源以 XML、JSON 等纯数据的格式输出，且不在意使用报文头控制资源输出，那么适合选择 HttpMessageConverter 实现方式。否则，建议采用 Spring MVC 的 ContentNegotiatingViewResolver 视图解析器。</p><p>ContentNegotiatingViewResolver 并不是一个传统的视图解析器，它实际上更像是一个中介人，根据请求信息从上下文中选择一个合适的视图解析器进行解析。因此，一般将 ContentNegotiatingViewResolver 的优先级设为最高，以便它可以方便的选择其他视图解析器。</p><p>ContentNegotiatingViewResolver 根据请求所要求的资源类型决定由哪个视图解析器负责处理，它按照如下方式工作：</p><ol><li>如果其 favorPathExtension 属性设置为 true，则根据 URL 中的文件扩展名确定其 MIME 类型（如userList.xml，userList.json 等）。</li><li>如果其 favorPathExtension 属性设置为 true，则根据请求参数的值确定其 MIME 类型。默认的请求参数是 formart。可以通过 parameterName 属性指定一个自定义的参数。</li><li>如果还没有找到对应的 MIME 类型，且 Java Activation Framework（JAF）位于类路径下，则通过 JAF 的 FileTypeMap.getContentType(url) 方法对 URL 进行判断，以便获取对应的 MIME 类型。</li><li>如果以上步骤都失败，且 ignoreAcceptHeader 属性设置为 false，则采用 Accept 请求报文头的值确定 MIME 类型。由于不同浏览器产生的 Accept 头都是不一样的，所以一般不建议采用 Accept 确定 MIME 类型。</li></ol><h5 id="2-使用同一-URL-获取不同形式的返回内容"><a href="#2-使用同一-URL-获取不同形式的返回内容" class="headerlink" title="2. 使用同一 URL 获取不同形式的返回内容"></a>2. 使用同一 URL 获取不同形式的返回内容</h5><p>假设希望使用以下 REST 风格的 URL 以不同的 MIME 格式获取相同的资源：</p><ul><li>&#x2F;user&#x2F;showUserListMix.html：返回一个 HTML 页面显示的用户列表。</li><li>&#x2F;user&#x2F;showUserListMix.html?content&#x3D;xml：返回一个 XML 格式的用户列表。</li><li>&#x2F;user&#x2F;showUserListMix.html?content&#x3D;json：返回一个 JSON 格式的用户列表。</li></ul><p>首先，在 UserController 中添加一个处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showUserListMix&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showUserListMix</span><span class="params">(ModelMap mm)</span>&#123;</span><br><span class="line">        <span class="type">GregorianCalendar</span> <span class="variable">calendar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line">        ArrayList&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setUserName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        user1.setRealName(<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        calendar.set(<span class="number">2022</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line">        user1.setBirthday(calendar.getTime());</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setUserName(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">        user2.setRealName(<span class="string">&quot;约翰&quot;</span>);</span><br><span class="line">        user1.setBirthday(calendar.getTime());</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        mm.addAttribute(<span class="string">&quot;userList&quot;</span>, userList);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userListMix&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接着，在 smart-servlet.xml 中添加以下配置片段，配置一个 ContentNegotiatingViewResolver，采用请求参数指定内容资源的返回类型：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;contentNegotiationManager&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.accept.ContentNegotiationManagerFactoryBean&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:ignoreAcceptHeader</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:favorPathExtension</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:favorParameter</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:parameterName</span>=<span class="string">&quot;format&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:defaultContentType</span>=<span class="string">&quot;text/html&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mediaTypes&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">                html=text/html</span><br><span class="line">                xml=application/xml</span><br><span class="line">                json=application/json</span><br><span class="line">            <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 协商多种视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;</span> <span class="attr">p:order</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;contentNegotiationManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;contentNegotiationManager&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultViews&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">p:modelKeys</span>=<span class="string">&quot;userList&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.xml.MarshallingView&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">p:modelKey</span>=<span class="string">&quot;userList&quot;</span> <span class="attr">p:marshaller-ref</span>=<span class="string">&quot;xmlMarshaller&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">加上之前配置的视图解析器</span><br></pre></td></tr></table></figure><p>ContentNegotiatingViewResolver 会在上下文中查找和 MIME 类型匹配的视图解析器，并委托它们进行视图解析。这样通过 content 请求参数就可以控制资源的输出格式了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;请求处理方法执行完成后，最终返回一个 ModelAndView 对象。对于那些返回 String、View 或 ModelMap 等类型的处理方法，Spring MVC 也会在内部将它们装配成一个 ModelAndView 对象，该对象包含了视图逻辑名和模型对象的信息。&lt;/</summary>
      
    
    
    
    <category term="SpringMVC" scheme="https://lisj98.github.io/categories/SpringMVC/"/>
    
    
  </entry>
  
</feed>
